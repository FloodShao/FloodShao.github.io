<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Ros2 源码解析与实践 - Node</title>
      <link href="/2020/03/06/ros2-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E8%B7%B5-Node/"/>
      <url>/2020/03/06/ros2-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E8%B7%B5-Node/</url>
      
        <content type="html"><![CDATA[<h3 id="Node定义"><a href="#Node定义" class="headerlink" title="Node定义"></a>Node定义</h3><h4 id="ROS1与ROS2的定义区别"><a href="#ROS1与ROS2的定义区别" class="headerlink" title="ROS1与ROS2的定义区别"></a>ROS1与ROS2的定义区别</h4><ul><li>ROS1和ROS2在功能上没有区别（提供publish，subscribe，client，service等角色功能）</li><li><strong>生命周期</strong>：<ul><li>ROS1中每个node的初始化都在一个main函数中，都对应一个进程。main函数中，通过初始化一个node得到一个node handle传入自定义的node behavior构造函数来定义node行为</li><li>ROS2中每个node都继承自一个基类rclcpp::Node，采用子类继承的方式来暴露接口，这样每个node的生命周期都得到有效的控制。（这个lifecycle定义在更底层rcl层）</li></ul></li><li>ROS2 Node提供的创建服务接口，node实例继承自基类，创建函数返回的都是SharedPtr：<ul><li>rclcpp::Node-&gt;create_callback_group </li><li>rclcpp::Node-&gt;create_publisher</li><li>rclcpp::Node-&gt;create_subscription</li><li>rclcpp::Node-&gt;create_client</li><li>rclcpp::Node-&gt;create_service</li><li>rclcpp::Node-&gt;create_subnode</li><li>rclcpp::Node-&gt;create_wall_timer</li></ul></li></ul><h4 id="node-hpp"><a href="#node-hpp" class="headerlink" title="node.hpp"></a>node.hpp</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//std::enable_shared_from_this&lt;T&gt; 能让一个（类型是T，且已经被shared_ptr管理）安全地生成额外的std::shared_ptr。（定义于&lt;memory&gt;, 所以只要继承rclcpp::Node就必须要添加memory）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> :</span> <span class="keyword">public</span> <span class="built_in">std</span>::enable_shared_from_this&lt;Node&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  RCLCPP_SMART_PTR_DEFINITIONS(Node) <span class="comment">//"rclcpp/macros.hpp" 生成指针SharedPtr</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Create a new node with the specified name.</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * \param[in] node_name Name of the node.</span></span><br><span class="line"><span class="comment">   * \param[in] options Additional options to control creation of the node.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  RCLCPP_PUBLIC <span class="comment">//"rclcpp/visibility_control.hpp"</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Node</span><span class="params">( <span class="comment">//禁止隐式转换的构造函数。</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; node_name,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> NodeOptions &amp; options = NodeOptions())</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Create a new node with the specified name.</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * \param[in] node_name Name of the node.</span></span><br><span class="line"><span class="comment">   * \param[in] namespace_ Namespace of the node.</span></span><br><span class="line"><span class="comment">   * \param[in] options Additional options to control creation of the node.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  RCLCPP_PUBLIC</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Node</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; node_name,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; namespace_,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> NodeOptions &amp; options = NodeOptions())</span></span>;</span><br><span class="line"></span><br><span class="line">  RCLCPP_PUBLIC</span><br><span class="line">  <span class="keyword">virtual</span> ~Node();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Get the name of the node.</span></span><br><span class="line">  <span class="comment">/** \return The name of the node. */</span></span><br><span class="line">  RCLCPP_PUBLIC</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> * <span class="comment">//Node::name一旦定义就不能改变</span></span><br><span class="line">  get_name() <span class="keyword">const</span>; <span class="comment">//声明const不可修改成员变量</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Get the namespace of the node.</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * This namespace is the "node's" namespace, and therefore is not affected</span></span><br><span class="line"><span class="comment">   * by any sub-namespace's that may affect entities created with this instance.</span></span><br><span class="line"><span class="comment">   * Use get_effective_namespace() to get the full namespace used by entities.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * \sa get_sub_namespace()</span></span><br><span class="line"><span class="comment">   * \sa get_effective_namespace()</span></span><br><span class="line"><span class="comment">   * \return The namespace of the node.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  RCLCPP_PUBLIC</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *</span><br><span class="line">  get_namespace() <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Get the fully-qualified name of the node.</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The fully-qualified name includes the local namespace and name of the node.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  RCLCPP_PUBLIC</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *</span><br><span class="line">  get_fully_qualified_name() <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Get the logger of the node.</span></span><br><span class="line">  <span class="comment">/** \return The logger of the node. */</span></span><br><span class="line">  RCLCPP_PUBLIC</span><br><span class="line">  rclcpp::Logger</span><br><span class="line">  get_logger() <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Create and return a callback group.</span></span><br><span class="line">  RCLCPP_PUBLIC</span><br><span class="line">  rclcpp::callback_group::CallbackGroup::SharedPtr</span><br><span class="line">  create_callback_group(rclcpp::callback_group::CallbackGroupType group_type);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Return the list of callback groups in the node.</span></span><br><span class="line">  RCLCPP_PUBLIC</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;rclcpp::callback_group::CallbackGroup::WeakPtr&gt; &amp;</span><br><span class="line">  get_callback_groups() <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Create and return a Publisher.</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The rclcpp::QoS has several convenient constructors, including a</span></span><br><span class="line"><span class="comment">   * conversion constructor for size_t, which mimics older API's that</span></span><br><span class="line"><span class="comment">   * allows just a string and size_t to create a publisher.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * For example, all of these cases will work:</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * cpp</span></span><br><span class="line"><span class="comment">   * pub = node-&gt;create_publisher&lt;MsgT&gt;("chatter", 10);  // implicitly KeepLast</span></span><br><span class="line"><span class="comment">   * pub = node-&gt;create_publisher&lt;MsgT&gt;("chatter", QoS(10));  // implicitly KeepLast</span></span><br><span class="line"><span class="comment">   * pub = node-&gt;create_publisher&lt;MsgT&gt;("chatter", QoS(KeepLast(10)));</span></span><br><span class="line"><span class="comment">   * pub = node-&gt;create_publisher&lt;MsgT&gt;("chatter", QoS(KeepAll()));</span></span><br><span class="line"><span class="comment">   * pub = node-&gt;create_publisher&lt;MsgT&gt;("chatter", QoS(1).best_effort().volatile());</span></span><br><span class="line"><span class="comment">   * &#123;</span></span><br><span class="line"><span class="comment">   *   rclcpp::QoS custom_qos(KeepLast(10), rmw_qos_profile_sensor_data);</span></span><br><span class="line"><span class="comment">   *   pub = node-&gt;create_publisher&lt;MsgT&gt;("chatter", custom_qos);</span></span><br><span class="line"><span class="comment">   * &#125;</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * The publisher options may optionally be passed as the third argument for</span></span><br><span class="line"><span class="comment">   * any of the above cases.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * \param[in] topic_name The topic for this publisher to publish on.</span></span><br><span class="line"><span class="comment">   * \param[in] qos The Quality of Service settings for the publisher.</span></span><br><span class="line"><span class="comment">   * \param[in] options Additional options for the created Publisher.</span></span><br><span class="line"><span class="comment">   * \return Shared pointer to the created publisher.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">template</span>&lt;</span><br><span class="line">    <span class="keyword">typename</span> MessageT,</span><br><span class="line">    <span class="keyword">typename</span> AllocatorT = <span class="built_in">std</span>::allocator&lt;<span class="keyword">void</span>&gt;,</span><br><span class="line">    <span class="keyword">typename</span> PublisherT = rclcpp::Publisher&lt;MessageT, AllocatorT&gt;&gt;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;PublisherT&gt;</span><br><span class="line">  create_publisher(</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; topic_name,</span><br><span class="line">    <span class="keyword">const</span> rclcpp::QoS &amp; qos,</span><br><span class="line">    <span class="keyword">const</span> PublisherOptionsWithAllocator&lt;AllocatorT&gt; &amp; options =</span><br><span class="line">    PublisherOptionsWithAllocator&lt;AllocatorT&gt;()</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line"><span class="comment">//publisherT指针，定义topic_name, qos和相关options</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// Create and return a Subscription.</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * \param[in] topic_name The topic to subscribe on.</span></span><br><span class="line"><span class="comment">   * \param[in] callback The user-defined callback function to receive a message</span></span><br><span class="line"><span class="comment">   * \param[in] qos_history_depth The depth of the subscription's incoming message queue.</span></span><br><span class="line"><span class="comment">   * \param[in] options Additional options for the creation of the Subscription.</span></span><br><span class="line"><span class="comment">   * \param[in] msg_mem_strat The message memory strategy to use for allocating messages.</span></span><br><span class="line"><span class="comment">   * \return Shared pointer to the created subscription.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">template</span>&lt;</span><br><span class="line">    <span class="keyword">typename</span> MessageT,</span><br><span class="line">    <span class="keyword">typename</span> CallbackT,</span><br><span class="line">    <span class="keyword">typename</span> AllocatorT = <span class="built_in">std</span>::allocator&lt;<span class="keyword">void</span>&gt;,</span><br><span class="line">    <span class="keyword">typename</span> CallbackMessageT =</span><br><span class="line">    <span class="keyword">typename</span> rclcpp::subscription_traits::has_message_type&lt;CallbackT&gt;::type,</span><br><span class="line">    <span class="keyword">typename</span> SubscriptionT = rclcpp::Subscription&lt;CallbackMessageT, AllocatorT&gt;,</span><br><span class="line">    <span class="keyword">typename</span> MessageMemoryStrategyT = rclcpp::message_memory_strategy::MessageMemoryStrategy&lt;</span><br><span class="line">      CallbackMessageT,</span><br><span class="line">      AllocatorT</span><br><span class="line">    &gt;</span><br><span class="line">  &gt;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;SubscriptionT&gt;</span><br><span class="line">  create_subscription(</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; topic_name,</span><br><span class="line">    <span class="keyword">const</span> rclcpp::QoS &amp; qos,</span><br><span class="line">    CallbackT &amp;&amp; callback,</span><br><span class="line">    <span class="keyword">const</span> SubscriptionOptionsWithAllocator&lt;AllocatorT&gt; &amp; options =</span><br><span class="line">    SubscriptionOptionsWithAllocator&lt;AllocatorT&gt;(),</span><br><span class="line">    <span class="keyword">typename</span> MessageMemoryStrategyT::SharedPtr msg_mem_strat = (</span><br><span class="line">      MessageMemoryStrategyT::create_default()</span><br><span class="line">    )</span><br><span class="line">  );</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//sub消息指针，qos，相关triger callback， options</span></span><br><span class="line">  </span><br><span class="line"> <span class="comment">/// Create a timer.</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * \param[in] period Time interval between triggers of the callback.</span></span><br><span class="line"><span class="comment">   * \param[in] callback User-defined callback function.</span></span><br><span class="line"><span class="comment">   * \param[in] group Callback group to execute this timer's callback in.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> DurationRepT = <span class="keyword">int64_t</span>, <span class="keyword">typename</span> DurationT = <span class="built_in">std</span>::milli, <span class="keyword">typename</span> CallbackT&gt;</span><br><span class="line">  <span class="keyword">typename</span> rclcpp::WallTimer&lt;CallbackT&gt;::SharedPtr</span><br><span class="line">  create_wall_timer(</span><br><span class="line">    <span class="built_in">std</span>::chrono::duration&lt;DurationRepT, DurationT&gt; period,</span><br><span class="line">    CallbackT callback,</span><br><span class="line">    rclcpp::callback_group::CallbackGroup::SharedPtr group = <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//timer定时器，定时区间period，trigger callback</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//service和client</span></span><br><span class="line">  <span class="comment">/* Create and return a Client. */</span></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> ServiceT&gt;</span><br><span class="line">  <span class="keyword">typename</span> rclcpp::Client&lt;ServiceT&gt;::SharedPtr</span><br><span class="line">  create_client(</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; service_name,</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">rmw_qos_profile_t</span> &amp; qos_profile = rmw_qos_profile_services_default,</span><br><span class="line">    rclcpp::callback_group::CallbackGroup::SharedPtr group = <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Create and return a Service. */</span></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> ServiceT, <span class="keyword">typename</span> CallbackT&gt;</span><br><span class="line">  <span class="keyword">typename</span> rclcpp::Service&lt;ServiceT&gt;::SharedPtr</span><br><span class="line">  create_service(</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; service_name,</span><br><span class="line">    CallbackT &amp;&amp; callback,</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">rmw_qos_profile_t</span> &amp; qos_profile = rmw_qos_profile_services_default,</span><br><span class="line">    rclcpp::callback_group::CallbackGroup::SharedPtr group = <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//参数设置部分</span></span><br><span class="line">  RCLCPP_PUBLIC</span><br><span class="line">  <span class="keyword">const</span> rclcpp::ParameterValue &amp;</span><br><span class="line">  declare_parameter(</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; name,</span><br><span class="line">    <span class="keyword">const</span> rclcpp::ParameterValue &amp; default_value = rclcpp::ParameterValue(),</span><br><span class="line">    <span class="keyword">const</span> rcl_interfaces::msg::ParameterDescriptor &amp; parameter_descriptor =</span><br><span class="line">    rcl_interfaces::msg::ParameterDescriptor(),</span><br><span class="line">    <span class="keyword">bool</span> ignore_override = <span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//泛型编程重载函数1</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ParameterT&gt;</span><br><span class="line">  <span class="keyword">auto</span></span><br><span class="line">  declare_parameter(</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; name,</span><br><span class="line">    <span class="keyword">const</span> ParameterT &amp; default_value,</span><br><span class="line">    <span class="keyword">const</span> rcl_interfaces::msg::ParameterDescriptor &amp; parameter_descriptor =</span><br><span class="line">    rcl_interfaces::msg::ParameterDescriptor(),</span><br><span class="line">    <span class="keyword">bool</span> ignore_override = <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载2</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ParameterT&gt;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;ParameterT&gt;</span><br><span class="line">  declare_parameters(</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; namespace_,</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, ParameterT&gt; &amp; parameters,</span><br><span class="line">    <span class="keyword">bool</span> ignore_overrides = <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载3</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ParameterT&gt;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;ParameterT&gt;</span><br><span class="line">  declare_parameters(</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; namespace_,</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">string</span>,</span><br><span class="line">      <span class="built_in">std</span>::pair&lt;ParameterT, rcl_interfaces::msg::ParameterDescriptor&gt;</span><br><span class="line">    &gt; &amp; parameters,</span><br><span class="line">    <span class="keyword">bool</span> ignore_overrides = <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除parameter</span></span><br><span class="line">RCLCPP_PUBLIC</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">undeclare_parameter(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; name);</span><br><span class="line"></span><br><span class="line">RCLCPP_PUBLIC</span><br><span class="line"><span class="keyword">bool</span></span><br><span class="line">has_parameter(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; name) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">RCLCPP_PUBLIC</span><br><span class="line">rcl_interfaces::msg::SetParametersResult</span><br><span class="line">set_parameter(<span class="keyword">const</span> rclcpp::Parameter &amp; parameter);</span><br><span class="line"></span><br><span class="line">RCLCPP_PUBLIC</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;rcl_interfaces::msg::SetParametersResult&gt;</span><br><span class="line">set_parameters(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;rclcpp::Parameter&gt; &amp; parameters);</span><br><span class="line"></span><br><span class="line">RCLCPP_PUBLIC</span><br><span class="line">  rcl_interfaces::msg::SetParametersResult</span><br><span class="line">  set_parameters_atomically(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;rclcpp::Parameter&gt; &amp; parameters);</span><br><span class="line"></span><br><span class="line">... <span class="comment">//相关parameters的重载函数非常多。不列举了</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//成员变量</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="comment">/// Construct a sub-node, which will extend the namespace of all entities created with it.</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * \sa create_sub_node()</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * \param[in] other The node from which a new sub-node is created.</span></span><br><span class="line"><span class="comment">   * \param[in] sub_namespace The sub-namespace of the sub-node.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  RCLCPP_PUBLIC</span><br><span class="line">  Node(</span><br><span class="line">    <span class="keyword">const</span> Node &amp; other,</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; sub_namespace);</span><br><span class="line"></span><br><span class="line"><span class="comment">//私有成员变量</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  RCLCPP_DISABLE_COPY(Node) <span class="comment">//删除拷贝构造函数</span></span><br><span class="line"></span><br><span class="line">  RCLCPP_PUBLIC</span><br><span class="line">  <span class="keyword">bool</span></span><br><span class="line">  group_in_node(callback_group::CallbackGroup::SharedPtr group);</span><br><span class="line"></span><br><span class="line">  rclcpp::node_interfaces::NodeBaseInterface::SharedPtr node_base_;</span><br><span class="line">  rclcpp::node_interfaces::NodeGraphInterface::SharedPtr node_graph_;</span><br><span class="line">  rclcpp::node_interfaces::NodeLoggingInterface::SharedPtr node_logging_;</span><br><span class="line">  rclcpp::node_interfaces::NodeTimersInterface::SharedPtr node_timers_;</span><br><span class="line">  rclcpp::node_interfaces::NodeTopicsInterface::SharedPtr node_topics_;</span><br><span class="line">  rclcpp::node_interfaces::NodeServicesInterface::SharedPtr node_services_;</span><br><span class="line">  rclcpp::node_interfaces::NodeClockInterface::SharedPtr node_clock_;</span><br><span class="line">  rclcpp::node_interfaces::NodeParametersInterface::SharedPtr node_parameters_;</span><br><span class="line">  rclcpp::node_interfaces::NodeTimeSourceInterface::SharedPtr node_time_source_;</span><br><span class="line">  rclcpp::node_interfaces::NodeWaitablesInterface::SharedPtr node_waitables_;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> rclcpp::NodeOptions node_options_;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> sub_namespace_;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> effective_namespace_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="相关C-11的语法："><a href="#相关C-11的语法：" class="headerlink" title="相关C++11的语法："></a>相关C++11的语法：</h3><h4 id="继承自std-enable-shared-from-this"><a href="#继承自std-enable-shared-from-this" class="headerlink" title="继承自std::enable_shared_from_this"></a>继承自std::enable_shared_from_this</h4><p><a href="https://blog.csdn.net/fm_VAE/article/details/79660768" target="_blank" rel="noopener">https://blog.csdn.net/fm_VAE/article/details/79660768</a><br>在智能指针的使用过程中我们会遇到这样一种情况，我们在类的成员函数调用某一个函数，而该函数需要传递一个当前对象的智能指针作为参数时，我们需要能够在成员函数中获得自己的智能指针。传递这个智能指针可以增加指针的引用次数，放置在函数执行的过程中，对象被释放而引发引用错误。<br>但是我们不能在类中使用this构建一个这样的shared_ptr, 不是成员函数的shared_ptr是在栈中生成的，一旦超出作用域，shared_ptr被析构，会导致这个对象本身的this被析构，从而导致致命错误。</p><p>为了解决这个问题，在c++11中提供了enable_shared_from_this这个模板类。他提供了一个shared_from_this方法返回自己的智能指针。而这个返回的shared_from_this是基类成员变量，会在返回的过程中增加指针的引用次数。</p><p>注意这个shared_from_this()必须要等待构造函数将对象构造完成之后才能返回。</p><h4 id="SharedPtr成员变量来自哪里？"><a href="#SharedPtr成员变量来自哪里？" class="headerlink" title="SharedPtr成员变量来自哪里？"></a>SharedPtr成员变量来自哪里？</h4><p>出现在<code>RCLCPP_SMART_PTR_DEFINITIONS(Node)</code><br>定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RCLCPP_SMART_PTR_DEFINITIONS(...) \</span></span><br><span class="line">  RCLCPP_SHARED_PTR_DEFINITIONS(__VA_ARGS__) \</span><br><span class="line">  RCLCPP_WEAK_PTR_DEFINITIONS(__VA_ARGS__) \</span><br><span class="line">  RCLCPP_UNIQUE_PTR_DEFINITIONS(__VA_ARGS__)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RCLCPP_SHARED_PTR_DEFINITIONS(...) \</span></span><br><span class="line">  __RCLCPP_SHARED_PTR_ALIAS(__VA_ARGS__) \</span><br><span class="line">  __RCLCPP_MAKE_SHARED_DEFINITION(__VA_ARGS__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __RCLCPP_SHARED_PTR_ALIAS(...) \</span></span><br><span class="line">  <span class="keyword">using</span> SharedPtr = <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;__VA_ARGS__&gt;; \</span><br><span class="line">  <span class="keyword">using</span> ConstSharedPtr = <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">const</span> __VA_ARGS__&gt;;</span><br></pre></td></tr></table></figure></p><p>这里都是宏定义，最终落在<code>using SharedPtr = std::shared_ptr&lt;__VA_ARGS__&gt;</code>等定义。在这里<strong>SharedPtr</strong>就是<code>shared_ptr&lt;__VA_ARGS__&gt;</code>的别名。</p><p><strong>注意这里的SharedPtr</strong>。在看代码的时候经常会发现有如下：<br><code>rclcpp::Subscription&lt;std_msgs::msg::String&gt;::SharedPtr sub_;</code><br>你就会发现说这个类里边没有定义SharedPtr这个成员变量啊，这个是怎么来的。你去看源码的时候就会发现每一个基类都会有RCLCPP_SMART_PTR_DEFINITIONS(T)这个宏定义，找到最末端就会发现SharedPtr定义在这里，然后还是public成员变量。</p><p>这里就留了一个<strong>疑问</strong>？所有的基类都继承自<code>std::enable_shared_from_this</code>，说明就提供了一个方法<code>shared_from_this()</code>方法返回一个这个对象的指针。那为什么还要重新创建一个SharedPtr对象。</p><h4 id="using关键字"><a href="#using关键字" class="headerlink" title="using关键字"></a>using关键字</h4><p>在c++11中using的三种用法：<br><a href="https://blog.csdn.net/shift_wwx/article/details/78742459" target="_blank" rel="noopener">https://blog.csdn.net/shift_wwx/article/details/78742459</a></p><ol><li>命名空间的使用</li><li><p>在子类中引用基类的成员</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T5Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T5Base() :value(<span class="number">55</span>) &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~T5Base() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"T5Base test1..."</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T5Derived</span> :</span> <span class="keyword">private</span> T5Base &#123; <span class="comment">//私有继承，成员变量在子类中全部转为private.。那么在public中如何访问基类成员。</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//using T5Base::test1; </span></span><br><span class="line">    <span class="comment">//using T5Base::value;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"value is "</span> &lt;&lt; value &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「私房菜」的原创文章，遵循 CC <span class="number">4.0</span> BY-SA 版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https:<span class="comment">//blog.csdn.net/shift_wwx/article/details/78742459</span></span><br></pre></td></tr></table></figure></li><li><p>别名指定，类似于typedef。相比于typedef，using很容易区分一个别名（尤其是函数指针）。</p></li></ol><h4 id="删除拷贝构造函数"><a href="#删除拷贝构造函数" class="headerlink" title="删除拷贝构造函数"></a>删除拷贝构造函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define RCLCPP_DISABLE_COPY(...)</span><br><span class="line">__VA_ARGS__(const __VA_ARGS__ &amp;) = delete; \</span><br><span class="line">  __VA_ARGS__ &amp; operator=(const __VA_ARGS__ &amp;) = delete;</span><br></pre></td></tr></table></figure><p>C++11则使用delete关键字显式指示编译器不生成函数的默认版本。<br><a href="https://blog.csdn.net/u012333003/article/details/25299939" target="_blank" rel="noopener">https://blog.csdn.net/u012333003/article/details/25299939</a></p><h4 id="attribute"><a href="#attribute" class="headerlink" title="__attribute__"></a>__attribute__</h4><p>_<em>attribute_</em>可以设置函数属性（FunctionAttribute）、变量属性（Variable Attribute）和类型属性（Type Attribute）. 函数属性可以帮助开发者把一些特性添加到函数声明中，从而可以使编译器在错误检查方面的功能更强大。也很容易同非GNU应用程序做到兼容之功效。</p><p>出现在RCLCPP<em>PUBLIC等定义中(visibility<em>control.hpp) <a href="https://gcc.gnu.org/wiki/Visibility" target="_blank" rel="noopener">https://gcc.gnu.org/wiki/Visibility</a><br>语法格式为`__attribute</em></em> ((attribute-list))`</p><p>在C语言中，可以使用static关键字限制符号（函数或变量）只对当前的文件可见，即，static对符号的限制在单个文件级别。而共享库（或动态库）可能包含一个或多个文件，如何将符号限制在库文件（模块）的级别，大多数链接器提供了将一个模块的所有符号进行隐藏或导出的方法，但这样对符号的控制会缺乏灵活性，因此，还有一些额外的工作需要我们来处理。(在GCC 4.0下)</p><p><a href="https://blog.csdn.net/zdragon2002/article/details/6061962" target="_blank" rel="noopener">https://blog.csdn.net/zdragon2002/article/details/6061962</a><br><a href="https://blog.csdn.net/delphiwcdj/article/details/45225889" target="_blank" rel="noopener">https://blog.csdn.net/delphiwcdj/article/details/45225889</a></p><p>在编译一个大型的动态链接库的时候，选择不同的链接方式<code>-fvisibility=default</code> 可以决定动态链接库向外暴露哪些接口。<br>而使用宏定义来实现visibility可以方便代码在不同平台上迁移。</p><p>所以在(visibility_control.hpp)中进行如下定义:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined _WIN32 || defined __CYGWIN__ <span class="comment">//针对win平台</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">ifdef</span> __GNUC__</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> RCLCPP_EXPORT __attribute__ ((dllexport))</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> RCLCPP_IMPORT __attribute__ ((dllimport))</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> RCLCPP_EXPORT __declspec(dllexport)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> RCLCPP_IMPORT __declspec(dllimport)</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">ifdef</span> RCLCPP_BUILDING_LIBRARY</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> RCLCPP_PUBLIC RCLCPP_EXPORT</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> RCLCPP_PUBLIC RCLCPP_IMPORT</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> RCLCPP_PUBLIC_TYPE RCLCPP_PUBLIC</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> RCLCPP_LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">//针对Linux平台</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> RCLCPP_EXPORT __attribute__ ((visibility(<span class="meta-string">"default"</span>))) <span class="comment">//设置全部可见，链接库接口暴露</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> RCLCPP_IMPORT</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">if</span> __GNUC__ &gt;= 4 <span class="comment">//编译器GCC是4.0版本以上</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> RCLCPP_PUBLIC __attribute__ ((visibility(<span class="meta-string">"default"</span>)))</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> RCLCPP_LOCAL  __attribute__ ((visibility(<span class="meta-string">"hidden"</span>))) <span class="comment">//连接库接口隐藏</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">else</span> <span class="comment">//GCC4.0版本一下不支持visibility control，那就只能全部暴露出去了（因为代码里应该也没有相关的static声明）</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> RCLCPP_PUBLIC </span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> RCLCPP_LOCAL</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> RCLCPP_PUBLIC_TYPE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p><h4 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h4><p>在C++中，explicit关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换，只能以显示的方式进行类型转换。<br>也就是说如果一个构造函数被声明了explicit，那么不能隐式的转换成<strong>拷贝构造函数</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">   <span class="keyword">public</span>: </span><br><span class="line">        Circle(<span class="keyword">double</span> r) : R(r) &#123;&#125; </span><br><span class="line">        Circle(<span class="keyword">int</span> x, <span class="keyword">int</span> y = <span class="number">0</span>) : X(x), Y(y) &#123;&#125; </span><br><span class="line">        Circle(<span class="keyword">const</span> Circle&amp; c) : R(c.R), X(c.X), Y(c.Y) &#123;&#125; </span><br><span class="line">   <span class="keyword">private</span>: </span><br><span class="line">        <span class="keyword">double</span> R; </span><br><span class="line">        <span class="keyword">int</span>    X; </span><br><span class="line">        <span class="keyword">int</span>    Y; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[]) </span><br><span class="line">&#123; </span><br><span class="line"><span class="comment">//发生隐式类型转换 </span></span><br><span class="line"><span class="comment">//编译器会将它变成如下代码 </span></span><br><span class="line"><span class="comment">//tmp = Circle(1.23) </span></span><br><span class="line"><span class="comment">//Circle A(tmp); </span></span><br><span class="line"><span class="comment">//tmp.~Circle(); </span></span><br><span class="line">  Circle A = <span class="number">1.23</span>;</span><br><span class="line"><span class="comment">//如果构造函数变成：</span></span><br><span class="line"><span class="comment">// explicit Circle(double r) : R(r) &#123;&#125;</span></span><br><span class="line"><span class="comment">// 那个上边这一句就会报错，不能隐式转化拷贝构造函数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意是int型的，调用的是Circle(int x, int y = 0) </span></span><br><span class="line"><span class="comment">//它虽然有2个参数，但后一个有默认值，任然能发生隐式转换 </span></span><br><span class="line">   Circle B = <span class="number">123</span>; </span><br><span class="line"><span class="comment">//这个算隐式调用了拷贝构造函数 </span></span><br><span class="line">   Circle C = A; </span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建pubsub实例"><a href="#创建pubsub实例" class="headerlink" title="创建pubsub实例"></a>创建pubsub实例</h3><h4 id="创建pkg"><a href="#创建pkg" class="headerlink" title="创建pkg"></a>创建pkg</h4><ol><li>创建workspace <code>~/ros2_ws/src</code></li><li><p>在<code>~/ros2_ws/src</code>下创建pkg</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ros2 pkg create --build-type ament_cmake cpp_pubsub</span><br><span class="line"># 基本方法是 ros2 pkg create --build-type [cmake, ament_cmake] pkg-name</span><br><span class="line"># --help 访问帮助文档</span><br></pre></td></tr></table></figure></li><li><p>在<code>~/ros2_ws/src/cpp_pubsub</code>下会创建pkg树</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-include</span><br><span class="line">-src</span><br><span class="line">-CMakeLists.txt</span><br><span class="line">-package.xml</span><br></pre></td></tr></table></figure></li><li><p>在<code>cpp_pubsub/src</code>下创建文件</p></li></ol><h4 id="简单的publisher-node"><a href="#简单的publisher-node" class="headerlink" title="简单的publisher node"></a>简单的publisher node</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//published_member_function.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"rclcpp/rclcpp.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"std_msgs/msg/string.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::chrono_literals;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This example creates a subclass of Node and uses std::bind() to register a</span></span><br><span class="line"><span class="comment">* member function as a callback from the timer. */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinimalPublisher</span> :</span> <span class="keyword">public</span> rclcpp::Node</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    MinimalPublisher()</span><br><span class="line">    : Node(<span class="string">"minimal_publisher"</span>), count_(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      publisher_ = <span class="keyword">this</span>-&gt;create_publisher&lt;std_msgs::msg::String&gt;(<span class="string">"topic"</span>, <span class="number">10</span>);</span><br><span class="line">      timer_ = <span class="keyword">this</span>-&gt;create_wall_timer(</span><br><span class="line">      <span class="number">500</span>ms, <span class="built_in">std</span>::bind(&amp;MinimalPublisher::timer_callback, <span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">timer_callback</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">auto</span> message = std_msgs::msg::String();</span><br><span class="line">      message.data = <span class="string">"Hello, world! "</span> + <span class="built_in">std</span>::to_string(count_++);</span><br><span class="line">      RCLCPP_INFO(<span class="keyword">this</span>-&gt;get_logger(), <span class="string">"Publishing: '%s'"</span>, message.data.c_str());</span><br><span class="line">      publisher_-&gt;publish(message);</span><br><span class="line">    &#125;</span><br><span class="line">    rclcpp::TimerBase::SharedPtr timer_;</span><br><span class="line">    rclcpp::Publisher&lt;std_msgs::msg::String&gt;::SharedPtr publisher_;</span><br><span class="line">    <span class="keyword">size_t</span> count_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">rclcpp::init(argc, argv);</span><br><span class="line">rclcpp::spin(<span class="built_in">std</span>::make_shared&lt;MinimalPublisher&gt;());</span><br><span class="line">rclcpp::shutdown();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>c++11中<code>std::bind()</code>这个方法定义在<functional>中，用来实现函数转发器，广泛用于泛型编程。看一下源码定义：</functional></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt; class F, class... Args &gt;</span><br><span class="line">/*unspecified*/ bind( F&amp;&amp; f, Args&amp;&amp;... args );</span><br><span class="line">- f是可调用对象callable，（函数对象、指向函数指针、到函数引用、指向成员函数指针或指向数据成员指针）</span><br><span class="line">- args是要绑定的参数列表。</span><br></pre></td></tr></table></figure></li><li><p>注意在主函数中已经没有显示的创建node（ros1中是显示的创建node handle），而是生成一个MinimalPublisher的对象进入spin。</p></li><li>std::make_shared<t>(Args&amp; …args)。调用class T的构造函数，并返回一个std::shared_ptr，同时use_count+1。</t></li></ol><h4 id="CMakeLists-txt"><a href="#CMakeLists-txt" class="headerlink" title="CMakeLists.txt"></a>CMakeLists.txt</h4><p>CMakeLists中要添加dependencies和相关的编译可执行文件<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION <span class="number">3.5</span>)</span><br><span class="line">project(cpp_pubsub)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Default to C++14</span></span><br><span class="line"><span class="keyword">if</span>(NOT CMAKE_CXX_STANDARD)</span><br><span class="line">  set(CMAKE_CXX_STANDARD <span class="number">14</span>)</span><br><span class="line">endif()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES <span class="string">"Clang"</span>)</span><br><span class="line">  add_compile_options(-Wall -Wextra -Wpedantic)</span><br><span class="line">endif()</span><br><span class="line"></span><br><span class="line">find_package(ament_cmake REQUIRED)</span><br><span class="line">find_package(rclcpp REQUIRED)</span><br><span class="line">find_package(std_msgs REQUIRED)</span><br><span class="line"></span><br><span class="line">add_executable(talker src/publisher_member_function.cpp)</span><br><span class="line">ament_target_dependencies(talker rclcpp std_msgs)</span><br><span class="line"></span><br><span class="line">install(TARGETS</span><br><span class="line">  talker</span><br><span class="line">  DESTINATION lib/$&#123;PROJECT_NAME&#125;)</span><br><span class="line"></span><br><span class="line">ament_package()</span><br></pre></td></tr></table></figure></p><h4 id="package-xml"><a href="#package-xml" class="headerlink" title="package.xml"></a>package.xml</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;exec_depend&gt;rclcpp&lt;/exec_depend&gt;</span><br><span class="line">&lt;exec_depend&gt;std_msgs&lt;/exec_depend&gt;</span><br></pre></td></tr></table></figure><h4 id="编译publisher-node"><a href="#编译publisher-node" class="headerlink" title="编译publisher node"></a>编译publisher node</h4><ol><li>在<code>ros2_ws/</code>下编译</li><li><code>colcon build</code> 编译<code>ros2_ws/src</code>下的所有pkg</li><li><code>colcon build --packages-select &lt;pkg—name&gt;</code> 编译单独的pkg</li><li>目前（2020.3）还没有提供类似于<code>catkin clean</code>这样的清理编译空间的命令，想要清理的话只能手动删除install, log, build文件</li><li>编译得到的可执行文件在<code>/build/cpp_pubsub/talker</code>，可以直接执行可执行文件，不用使用ros2 run</li><li>如果要使用ros2，和ros1一样要执行环境变量操作<code>source ros2_ws/install/setup.bash</code>。 查看ros2寻址的所有pkg <code>ros2 pkg list</code></li><li>运行<code>ros2 run cpp_pubsub talker</code></li></ol><h4 id="同样的subscription-node"><a href="#同样的subscription-node" class="headerlink" title="同样的subscription node"></a>同样的subscription node</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//subscribe_member_function.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"rclcpp/rclcpp.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"std_msgs/msg/string.hpp"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::placeholders::_1;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinimalSubscriber</span> :</span> <span class="keyword">public</span> rclcpp::Node</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    MinimalSubscriber()</span><br><span class="line">    : Node(<span class="string">"minimal_subscriber"</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      subscription_ = <span class="keyword">this</span>-&gt;create_subscription&lt;std_msgs::msg::String&gt;(</span><br><span class="line">      <span class="string">"topic"</span>, <span class="number">10</span>, <span class="built_in">std</span>::bind(&amp;MinimalSubscriber::topic_callback, <span class="keyword">this</span>, _1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">topic_callback</span><span class="params">(<span class="keyword">const</span> std_msgs::msg::String::SharedPtr msg)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      RCLCPP_INFO(<span class="keyword">this</span>-&gt;get_logger(), <span class="string">"I heard: '%s'"</span>, msg-&gt;data.c_str());</span><br><span class="line">    &#125;</span><br><span class="line">    rclcpp::Subscription&lt;std_msgs::msg::String&gt;::SharedPtr subscription_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  rclcpp::init(argc, argv);</span><br><span class="line">  rclcpp::spin(<span class="built_in">std</span>::make_shared&lt;MinimalSubscriber&gt;());</span><br><span class="line">  rclcpp::shutdown();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是不管是publisher还是subscription的构造过程中，QoS不能省了。顶层的QoS可以理解为data stream buffer，在ros1中也有相关的定义，但是因为ros2的底层是DDS，所以QoS必须定义。</p><p><code>std::placeholder::_1</code>一个占位符，为什么要使用这个？<br><code>std::bind()</code>绑定类内成员函数：</p><ol><li>绑定的成员函数<strong>不能有重载</strong>，bind函数只能通过函数名来识别函数</li><li>绑定类内成员函数，首先要传递对象指针this，然后通过占位符_1来添加传递的参数，这里也就是msg。</li><li>bind本身是一种延迟计算的思想。<br>那么这里就涉及到这个callback到底什么时候在调用呢。</li><li>std::bind()返回的是一个函数未指定类型的函数对象，具体返回什么类型决定于可调用函数f。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++常用数据类型以及STL容器总结</title>
      <link href="/2020/01/31/C-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BB%A5%E5%8F%8ASTL%E5%AE%B9%E5%99%A8%E6%80%BB%E7%BB%93/"/>
      <url>/2020/01/31/C-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BB%A5%E5%8F%8ASTL%E5%AE%B9%E5%99%A8%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="C-STL标准资源库"><a href="#C-STL标准资源库" class="headerlink" title="C++ STL标准资源库"></a>C++ STL标准资源库</h3><p>STL包括三个核心组件：</p><ol><li>容器：管理某一个类型的集合</li><li>算法：作用于容器</li><li>迭代器：遍历容器的对象</li></ol><h3 id="C-基本数据类型"><a href="#C-基本数据类型" class="headerlink" title="C++基本数据类型"></a>C++基本数据类型</h3><h4 id="内置数据类型"><a href="#内置数据类型" class="headerlink" title="内置数据类型"></a>内置数据类型</h4><div class="table-container"><table><thead><tr><th>类型</th><th>占用位（字节）</th></tr></thead><tbody><tr><td>char</td><td>1</td></tr><tr><td>int</td><td>4</td></tr><tr><td>short</td><td>2</td></tr><tr><td>long</td><td>8 (16位机器是4)</td></tr><tr><td>long long</td><td>8</td></tr><tr><td>float</td><td>4</td></tr><tr><td>double</td><td>8</td></tr><tr><td>long double</td><td>16</td></tr></tbody></table></div><h4 id="typedef声明"><a href="#typedef声明" class="headerlink" title="typedef声明"></a>typedef声明</h4><p>格式<code>typedef type newname</code><br>例如：</p><ol><li><code>typedef int feet</code> 表示feet是int的别名</li><li>定义struct的时候<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct TWO_NUMS&#123;</span><br><span class="line">    int a;</span><br><span class="line">    int b;</span><br><span class="line">&#125;;</span><br><span class="line">//上述定义在之后进行实例创建的时候比如要如下引用</span><br><span class="line">struct TWO_NUMS two_nums;</span><br><span class="line">//但使用如下定义</span><br><span class="line">struct TWO_NUMS&#123;</span><br><span class="line">    int a;</span><br><span class="line">    int b;</span><br><span class="line">&#125; TwoNums;</span><br><span class="line">TwoNums two_nums; //就可以如此引用</span><br></pre></td></tr></table></figure></li></ol><h4 id="枚举类enum"><a href="#枚举类enum" class="headerlink" title="枚举类enum"></a>枚举类enum</h4><p><code>enum color {red, blue, green} c;</code><br>则red = 0, blue = 1, green = 2<br><code>enum color {red, blue = 5, green} c;</code><br>red = 0, blue = 5, green = 6</p><h3 id="C-存储类"><a href="#C-存储类" class="headerlink" title="C++ 存储类"></a>C++ 存储类</h3><ul><li><strong>auto:</strong> 声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符。(C++11)</li><li><strong>static:</strong> 指示<strong>编译器</strong><u>在程序的生命周期内保持局部变量的存在</u>，而不需要在每次它进入和离开作用域时进行创建和销毁。<strong>static只在作用域内可见。在编译二进制文件中，static修饰的部分保存在静态内存段</strong> 1.修饰局部变量可以保持离开作用域时数据保持不销毁。2.修饰全局变量或全局函数 3.修饰类变量，各个对象共享一个static副本</li><li><strong>extern:</strong> 提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。extern 是用来在另一个文件中声明一个全局变量或函数。</li><li><strong>thread_local:</strong> 变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。</li></ul><h3 id="C-函数"><a href="#C-函数" class="headerlink" title="C++ 函数"></a>C++ 函数</h3><ul><li>传值调用：复制，并传入副本。对传入参数本身没有影响</li><li>指针调用：复制，传入指针（也就是传入地址）。在操作的过程中对地址解引用进行修改。也就是实际上是在内存上进行更改。会影响到传入参数的实际内容</li><li>引用调用：将参数的引用复制传给函数。会影响到传入参数的实际内容</li></ul><h4 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h4><p>C++11对匿名函数的支持，广泛用于排序cmp等操作<br><code>[capture](parameters)-&gt;return-type{body}</code><br>例如：<br><code>[](int x, int y){ return x &lt; y ; }</code><br><code>[](int x, int y) -&gt; int { int z = x + y; return z + x; }</code><br><code>[]</code>表示没有定义变量，使用未定义变量会报错<br><code>[x, &amp;y]</code>表示x传值调用，y为引用调用<br><code>[&amp;]</code>所有传入参数为引用调用<br><code>[=]</code>所有传入参数为传值调用</p><h3 id="C-数组"><a href="#C-数组" class="headerlink" title="C++ 数组"></a>C++ 数组</h3><p>存储一个固定大小的相同类型元素的顺序集合。<strong>在内存上连续分布</strong>。可以实现O(1)操作访问。声明时必须确定arraySize。<br><code>type arrayName [ arraySize ];</code></p><h4 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h4><p><code>type name[size1][size2]...[sizeN];</code></p><h4 id="指向数组的指针"><a href="#指向数组的指针" class="headerlink" title="指向数组的指针"></a>指向数组的指针</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">double balance [10]; //balance本身是指向一个大小为10的double数组的头指针。</span><br><span class="line">double *p;</span><br><span class="line">p = balance;</span><br><span class="line">*(p + 4);//是访问balance[4]的合法方式</span><br></pre></td></tr></table></figure><h4 id="向函数传递数组"><a href="#向函数传递数组" class="headerlink" title="向函数传递数组"></a>向函数传递数组</h4><ol><li>传递数组头指针，对数组的操作会影响实际值。安全的保证不修改要使用const</li><li>传递数组形参。<code>int param[]</code>就是可以的，C++不会对形参的边界进行边界检查，但是如果不传param_size就有可能造成segament fault访问越界。也可以<code>int param[10]</code>。</li></ol><h4 id="函数返回数组"><a href="#函数返回数组" class="headerlink" title="函数返回数组"></a>函数返回数组</h4><p><strong>C++不允许返回一个完整的数组</strong>。只能返回一个数组头指针<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int * getNums()&#123;</span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int *p;</span><br><span class="line">    p = getNums();</span><br><span class="line">    //这里就要注意我并不知道p的限度在哪里。而C++对内存越界操作并不直接检查，会产生隐形bug</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="C-字符串-c-str"><a href="#C-字符串-c-str" class="headerlink" title="C++字符串 c_str"></a>C++字符串 c_str</h3><p><code>char str[6] = {&#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;, &#39;\0&#39;};</code> 字符串是以null为终止的一维字符数组<br><code>char str[] = &quot;hello&quot;;</code></p><p>c_str操作函数：</p><ul><li>strcpy(s1, s2); 复制s2到s1，注意复制有可能越界</li><li>strcat(s1, s2); 连接s2到s1上</li><li>strlen(s1)</li><li>strcmp(s1, s2); 相同返回0，s1&gt;s2返回positive，s1&lt;s2返回negative</li><li>strchr(s1, ch); 返回ch在s1中第一次出现的位置</li><li>strstr(s1, s2); 返回s2在s1中第一次出现的位置（普通实现O(n^2), KMP实现O(n)）</li></ul><h3 id="C-指针"><a href="#C-指针" class="headerlink" title="C++指针"></a>C++指针</h3><p>指针是一个变量，占用4个字节。他的值表示的是一个内存地址。<br>可以对指针进行的操作++， —， +， -。来移动指针内容在内存上表示的变量。但是注意指针本身所占用的4字节地址并不会变。</p><h3 id="C-引用"><a href="#C-引用" class="headerlink" title="C++引用"></a>C++引用</h3><ul><li>不存在空引用，引用必须连接到一个合法的内存地址</li><li>一旦引用被初始化，就不能被指向另一个对象。</li><li>引用必须在创建时初始化。</li></ul><h3 id="顺序STL容器"><a href="#顺序STL容器" class="headerlink" title="顺序STL容器"></a>顺序STL容器</h3><h5 id="array"><a href="#array" class="headerlink" title="array"></a>array</h5><p>具有固定大小，不支持添加或删除元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;array&gt;</span><br><span class="line">template&lt;</span><br><span class="line">    class T,</span><br><span class="line">    std::size_t N</span><br><span class="line">&gt; struct array;</span><br></pre></td></tr></table></figure></p><p>内存分配策略：</p><ol><li>局部变量在栈上分配（对比vector，vector底层实现是动态数组，局部变量在堆上分配）</li><li>使用new分配的话在堆上分配</li><li>全局变量或静态变量，在静态存储区分配</li></ol><p>成员函数：</p><ol><li>成员访问：<ul><li>at <code>A.at(int)</code></li><li>operator[] <code>A[int]</code></li><li>front <code>A.front()</code></li><li>back <code>A.back()</code></li><li>data <code>A.data()</code> 返回指向第一个元素的指针</li></ul></li><li>迭代器：<ul><li>begin()</li><li>end()</li></ul></li><li>容量：<ul><li>empty()</li><li>size()</li><li>max_size() 返回可容纳的最大元素数</li></ul></li><li>操作：<ul><li>fill()</li><li>swap(array &amp; other) 将容器内容与other内容进行交换</li></ul></li></ol><p>优势：</p><ul><li>比数组安全，提供了越界检查</li><li>array::swap线性时间内容交换</li></ul><h5 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h5><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <vector></vector></h1><p>底层数据结构是动态数组，管理连续内存空间。与array唯一的区别是对空间的运用上。对于超过现有vector大小的插入，vector容量2倍扩展。vector如果是空的话，也占用1个元素大小。</p><p>成员函数：保留array所有的function。增加的function：</p><pre><code>* push_back(class T)* pop_back()* iterator insert(const_iterator position, const value_type&amp; val) 注意会改变vector所有元素的标号，传入参数为iterator* erase(const_iterator position) 同样会改变vector所有元素的标号* clear()* swap()</code></pre><p>insert和erase会出现迭代器失效的问题</p><h4 id="string"><a href="#string" class="headerlink" title="string"></a>string</h4><h1 id="include-1"><a href="#include-1" class="headerlink" title="include "></a>include <string></string></h1><p>只存储字符元素的vector.</p><p>成员函数：与vector相同。与vector不同的：</p><ul><li>operator+= 表示在string后添加</li><li>c_str() 返回char* 类型</li><li>size_t copy(char* buf, size_t len, size_t pos = 0) const;</li><li>string substr(size_t pos = 0, size_t len = npos) const;</li><li>size_t find(const string&amp; str, size_t pos = 0) const; 查找从pos后开始，str第一次出现的位置。还有rfind查找最后一次出现的位置</li></ul><p>非成员函数支持：</p><ul><li>operator+ 连接两个string</li><li>operator&gt;&gt; 从inputstream提取一个string</li><li>operator&lt;&lt; 向outputstream输出string的内容</li><li>getline(istream&amp; is, string&amp; str, char delim); 或getline(isstream&amp; is, string&amp; str);</li><li><blockquote><p>&lt; =组合的逻辑运算符。不相等的话从头来比较char的asii码大小。</p></blockquote></li></ul><h4 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h4><h1 id="include-2"><a href="#include-2" class="headerlink" title="include "></a>include <deque></deque></h1><p>vector是单向开口的连续存储空间，deque是双向开口的连续存储空间。可以在头和尾方便的进行元素的插入和删除工作。O(1)访问元素。底层实现是数组和链表，将一段一段连续空间连起来。<br>原理是用一段连续空间存储指针，每一个指针指向缓冲区，缓冲区是内容主体。</p><p>成员函数：保留vector所有。vector不同的:</p><ul><li>push_back()</li><li>push_front()</li><li>pop_back()</li><li>pop_front()</li><li>swap()</li></ul><h4 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h4><h1 id="include-3"><a href="#include-3" class="headerlink" title="include "></a>include <stack></stack></h1><p>在deque上实现。<strong>没有迭代器</strong> 只提供栈顶操作</p><p>成员函数：</p><ul><li>top()</li><li>push()</li><li>pop()</li><li>size()</li><li>empty()</li></ul><h4 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h4><h1 id="include-4"><a href="#include-4" class="headerlink" title="include "></a>include <queue></queue></h1><p>在deque上实现。<strong>没有迭代器</strong></p><p>成员函数：</p><ul><li>empty()</li><li>size()</li><li>front()</li><li>back()</li><li>push_back()</li><li>pop_front()</li></ul><h4 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h4><p>实现一个堆（一种平衡二叉树，每一个根节点都大于所有子节点叫大顶堆，每一个根节点都小于所有子节点叫小顶堆）O(1)时间查找最大最小元素</p><p>成员函数与stack相同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class T, class Container = vector&lt;T&gt;, class Compare = less&lt;typename Container::value_type&gt; &gt; class priority_queue;</span><br><span class="line"></span><br><span class="line">//默认大顶堆</span><br><span class="line">//创建小顶堆</span><br><span class="line">priority_queue&lt;int, vector&lt;int&gt;, std::greater&lt;int&gt;&gt; small_heap;</span><br><span class="line">//greater表示实现l &gt; r</span><br><span class="line">//less表示实现l &lt; r</span><br></pre></td></tr></table></figure><h4 id="forward-list"><a href="#forward-list" class="headerlink" title="forward_list"></a>forward_list</h4><p>单向链表。O(1)时间实现元素的增加和删除</p><p>成员函数：</p><ol><li>容量：<ul><li>empty()<br>STL中唯一不提供size()的容器</li></ul></li><li>成员访问：<ul><li>front()返回头指针元素</li></ul></li><li>操作：<ul><li>push_front()</li><li>pop_front()</li><li>insert_after()</li><li>erase_after()</li><li>swap()</li><li>merge(forward_list &amp;fwdlist, Compare comp); 默认升序排列合并</li><li>sort( Compare comp) 默认升序排列</li><li>reverse()</li><li>remove(const value_type &amp;val) 删除特定元素。还有remove_if</li><li>unique() 删除重复元素</li></ul></li></ol><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p>双向循环链表。支持任意位置的O(1)插入删除操作，但是不支持快速随机访问（与vector的区别）</p><p>成员函数：</p><ol><li>成员访问：<ul><li>front()</li><li>back()</li></ul></li><li>操作：<ul><li>push_front</li><li>pop_front</li><li>push_back</li><li>pop_back</li><li>emplace(const_iterator position, Args&amp;&amp;… args); 在posistion出construct一个元素并插入</li></ul></li></ol><h3 id="关联STL容器（set和map）"><a href="#关联STL容器（set和map）" class="headerlink" title="关联STL容器（set和map）"></a>关联STL容器（set和map）</h3><p>底层都是红黑二叉树来实现的</p><h5 id="set"><a href="#set" class="headerlink" title="set"></a>set</h5><ul><li>set 元素的键值就是实值，实值就是键值。</li><li>set 不允许两个元素有相同的键值。</li><li>不可以通过 set 的迭代器改变其元素值，即 set iterator 是一种 constant iterators。</li><li>当对 set 进行插入删除操作后，原有的迭代器依然有效，被删除元素的迭代器除外。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template &lt; class Key,                                     // map::key_type</span><br><span class="line">           class T,                                       // map::mapped_type</span><br><span class="line">           class Compare = less&lt;Key&gt;,                     // map::key_compare</span><br><span class="line">           class Alloc = allocator&lt;pair&lt;const Key,T&gt; &gt;    // map::allocator_type</span><br><span class="line">           &gt; class map;</span><br></pre></td></tr></table></figure><p>set是升序排列的。</p><p>主要成员函数：</p><ol><li>迭代器：<ul><li>begin()</li><li>end()</li></ul></li><li>容量<ul><li>empty()</li><li>size()</li></ul></li><li>操作：<ul><li>insert(const value_type &amp;val)</li><li>erase(const value_type &amp;val) 或 erase(const_iterator position)</li><li>swap()</li><li>clear()</li></ul></li><li>find(const value_type &amp;val) 返回迭代器.没找到返回end()</li><li>count(const value_type &amp;val) 返回val的值。但是set本身不允许有duplicate</li></ol><p>Set衍生：</p><ul><li>unordered_set<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template &lt; class Key,                        // unordered_set::key_type/value_type</span><br><span class="line">           class Hash = hash&lt;Key&gt;,           // unordered_set::hasher</span><br><span class="line">           class Pred = equal_to&lt;Key&gt;,       // unordered_set::key_equal</span><br><span class="line">           class Alloc = allocator&lt;Key&gt;      // unordered_set::allocator_type</span><br><span class="line">           &gt; class unordered_set;</span><br></pre></td></tr></table></figure></li></ul><p>根据hash表加速迭代器访问速度。（每一个元素的内存地址为hash_function(Key)）</p><ul><li>multiset可以保存duplicate<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt; class T,                        // multiset::key_type/value_type</span><br><span class="line">           class Compare = less&lt;T&gt;,        // multiset::key_compare/value_compare</span><br><span class="line">           class Alloc = allocator&lt;T&gt; &gt;    // multiset::allocator_type</span><br><span class="line">           &gt; class multiset;</span><br></pre></td></tr></table></figure></li></ul><h5 id="map-key-value-pair"><a href="#map-key-value-pair" class="headerlink" title="map key-value pair"></a>map key-value pair</h5><ul><li>map 的所有元素都是 pair，同时拥有实值value和键值key。pair 的第一元素为键值，第二元素为实值。</li><li>map 不允许两个元素拥有相同的键值。</li><li>不可以通过 map 的迭代器改变其元素的键值，可以修改元素的实值。</li><li>当对 map 元素进行增加或删除操作后，原有的迭代器依然有效，被删除的元素的迭代器除外。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template &lt; class Key,                                     // map::key_type</span><br><span class="line">           class T,                                       // map::mapped_type</span><br><span class="line">           class Compare = less&lt;Key&gt;,                     // map::key_compare</span><br><span class="line">           class Alloc = allocator&lt;pair&lt;const Key,T&gt; &gt;    // map::allocator_type</span><br><span class="line">           &gt; class map;</span><br></pre></td></tr></table></figure><p>从这个模板类可以看出，map是排序的，默认为升序排列。在声明map的时候可以声明Compare。</p><p>成员函数：</p><ol><li>成员访问：<ul><li>at()</li><li>operator[]， 返回mapped_value, 如果没有键值被匹配上，则添加一个key。<br>其余的与set相同。</li></ul></li></ol><p>map的衍生</p><ul><li>unordered_map<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template &lt; class Key,                                    // unordered_map::key_type</span><br><span class="line">           class T,                                      // unordered_map::mapped_type</span><br><span class="line">           class Hash = hash&lt;Key&gt;,                       // unordered_map::hasher</span><br><span class="line">           class Pred = equal_to&lt;Key&gt;,                   // unordered_map::key_equal</span><br><span class="line">           class Alloc = allocator&lt; pair&lt;const Key,T&gt; &gt;  // unordered_map::allocator_type</span><br><span class="line">           &gt; class unordered_map;</span><br></pre></td></tr></table></figure></li></ul><p>同样是hash表</p><ul><li>multimap，可以保存duplicate key的map</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux最小系统</title>
      <link href="/2020/01/14/Linux%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F/"/>
      <url>/2020/01/14/Linux%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>讯为iTOP-4412嵌入式学习。Linux最小系统制作与烧写</p><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ul><li><p>ubuntu 12.04 (GCC版本降为4.4)</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">apt-get install gcc-4.4 g++-4.4 g++-4.4-multilib gcc-4.4-multilib</span><br><span class="line">update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-4.4 100</span><br><span class="line">update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-4.6 50</span><br><span class="line">update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-4.4 100</span><br><span class="line">update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-4.6 50</span><br><span class="line">update-alternatives --install /usr/bin/cpp cpp-bin /usr/bin/cpp-4.4 100</span><br><span class="line">update-alternatives --install /usr/bin/cpp cpp-bin /usr/bin/cpp-4.6 50</span><br><span class="line">gcc -v</span><br><span class="line"></span><br><span class="line">#恢复原来的gcc版本</span><br><span class="line">update-alternatives --remove cpp-bin /usr/bin/cpp-4.4</span><br><span class="line">update-alternatives --remove g++ /usr/bin/c++-4.4</span><br><span class="line">update-alternatives --remove gcc /usr/bin/gcc-4.4</span><br></pre></td></tr></table></figure></li><li><p>win 7 (烧写)</p></li><li>busybox 1.22.1 (开源，下载地址：<a href="https://busybox.net/" target="_blank" rel="noopener">https://busybox.net/</a>)</li><li>arm交叉编译器 arm-2009q3 (将提供的arm编译器arm-2009q3解压到/usr/local/arm，并在~/.bashrc中添加环境变量 export PATH=$PATH:/usr/local/arm/arm-2009q3/bin)</li></ul><h3 id="制作Linux最小系统"><a href="#制作Linux最小系统" class="headerlink" title="制作Linux最小系统"></a>制作Linux最小系统</h3><ol><li>下载busybox 1.22.1 至ubuntu，并解压。<br>进入解压路径busybox-1.22.1，进行编译设置<code>make menuconfig</code> (图形界面设置)</li></ol><ul><li>Busybox Setting —&gt; Build Option —&gt; cross compiler prefix —&gt; 填写 “arm-none-linux-gnueabi-”</li><li>Busybox Setting —&gt; Installation Options —&gt; (./__install)Busybox installation prefix —&gt; 更改为“../system” 将系统内核文件生成在上层目录的system中<br>保存设置</li></ul><p>【tips】make menuconfig 命令依赖ncurses库的支持。如果没有安装该库会报错“scripts/kconfig/lxdialog/dialog.h:31:20: fatal error: curses.h: No such file or directory”<br>安装相应的库：<br><code>sudo apt-get install libncurses5-dev libncursesw5-dev</code></p><ol><li><code>make</code> 编译安装busybox.</li><li><code>make install</code> 将编译生成的二进制文件装入../system中</li><li>这时候system路径中是如下的： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|--system</span><br><span class="line">    |--bin</span><br><span class="line">    |--linuxrc</span><br><span class="line">    |--sbin</span><br><span class="line">    |--usr</span><br></pre></td></tr></table></figure></li></ol><h3 id="完善Linux最小系统"><a href="#完善Linux最小系统" class="headerlink" title="完善Linux最小系统"></a>完善Linux最小系统</h3><p>制作文件系统还需要 /dev /mnt /lib /etc /proc /sys /tmp /var 等文件路径<br><code>mkdir /dev /mnt /lib /etc /proc /sys /tmp /var</code></p><h4 id="配置文件-etc"><a href="#配置文件-etc" class="headerlink" title="配置文件/etc"></a>配置文件/etc</h4><ol><li><p>建立/etc/eth0-setting文件, 并将权限改为755</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IP=192.168.1.230</span><br><span class="line">Mask=255.255.255.0</span><br><span class="line">Gateway=192.168.1.1</span><br><span class="line">DNS=192.168.1.1</span><br><span class="line">MAC=08:90:90:90:90:90</span><br></pre></td></tr></table></figure></li><li><p>建立/etc/init.d/ifconfig-eth0文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line">echo -n Try to bring eth0 interface up......&gt;/dev/ttySAC2</span><br><span class="line"></span><br><span class="line">if [-f /etc/eth0-setting]; then</span><br><span class="line">    source /etc/eth0-setting</span><br><span class="line">    if grep -q &quot;^/dev/root / nfs &quot; /etc/mtab ; then</span><br><span class="line">        echo -n NFS root ...&gt; /dev/ttySAC2</span><br><span class="line">    else</span><br><span class="line">        ifconfig eth0 down</span><br><span class="line">        ifconfig eth0 hw ether $MAC</span><br><span class="line">        ifconfig eth0 $IP netmask $Mask up</span><br><span class="line">        route add default gw $Gateway</span><br><span class="line">    fi</span><br><span class="line">    echo nameserver $DNS &gt; /etc/resolv.conf</span><br><span class="line">else</span><br><span class="line">    if grep -q &quot;^/dev/root / nfs &quot; /etc/mtab ; then</span><br><span class="line">        echo -n NFS root ... &gt; /dev/ttySAC2</span><br><span class="line">    else</span><br><span class="line">        /sbin/ifconfig eth0 192.168.253.12 netmask 255.255.255.0 up</span><br><span class="line">    fi</span><br><span class="line">fi </span><br><span class="line">echo Done &gt; /dev/ttySAC2</span><br></pre></td></tr></table></figure></li><li><p>建立/etc/init.d/rcS文件，更改755权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#! /bin/sh</span><br><span class="line">PATH=/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/bin:</span><br><span class="line">runlevel=S</span><br><span class="line">prevlevel=N</span><br><span class="line">umask 022</span><br><span class="line">export PATH runlevel prevlevel</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line">#       Trap CTRL-C &amp;c only in this shell so we can interrupt subprocesses.</span><br><span class="line">#</span><br><span class="line">trap &quot;:&quot; INT QUIT TSTP</span><br><span class="line">/bin/hostname iTOP-4412</span><br><span class="line"></span><br><span class="line">#/bin/mount -n -t proc none /proc</span><br><span class="line">#/bin/mount -n -t sysfs none /sys</span><br><span class="line">#/bin/mount -n -t usbfs none /proc/bus/usb</span><br><span class="line">#/bin/mount -t ramfs none /dev</span><br><span class="line">[ -e /proc/1 ]    || /bin/mount -n -t proc  none /proc</span><br><span class="line">[ -e /sys/class ] || /bin/mount -n -t sysfs none /sys</span><br><span class="line">[ -e /dev/tty ]   || /bin/mount    -t ramfs none /dev</span><br><span class="line"></span><br><span class="line">echo /sbin/mdev &gt; /proc/sys/kernel/hotplug</span><br><span class="line">/sbin/mdev -s</span><br><span class="line">#/bin/hotplug</span><br><span class="line"># mounting file system specified in /etc/fstab</span><br><span class="line">mkdir -p /dev/pts</span><br><span class="line">mkdir -p /dev/shm</span><br><span class="line">/bin/mount -n -t devpts none /dev/pts -o mode=0622</span><br><span class="line">/bin/mount -n -t tmpfs tmpfs /dev/shm</span><br><span class="line">#/bin/mount -n -t ramfs none /tmp</span><br><span class="line">#/bin/mount -n -t ramfs none /var</span><br><span class="line">mkdir -p /var/empty</span><br><span class="line">mkdir -p /var/log</span><br><span class="line">mkdir -p /var/log/boa</span><br><span class="line">mkdir -p /var/lock</span><br><span class="line">mkdir -p /var/run</span><br><span class="line">mkdir -p /var/tmp</span><br><span class="line"></span><br><span class="line">ln -sf /dev/ttyS2 /dev/tty2</span><br><span class="line">ln -sf /dev/ttyS2 /dev/tty3</span><br><span class="line">ln -sf /dev/ttyS2 /dev/tty4</span><br><span class="line"></span><br><span class="line">syslogd</span><br><span class="line">/etc/rc.d/init.d/netd start</span><br><span class="line">echo &quot;                        &quot; &gt; /dev/tty1</span><br><span class="line">echo &quot;Starting networking...&quot; &gt; /dev/tty1</span><br><span class="line">#sleep 1</span><br><span class="line">#/etc/rc.d/init.d/httpd start</span><br><span class="line">#echo &quot;                        &quot; &gt; /dev/tty1</span><br><span class="line">#echo &quot;Starting web server...&quot; &gt; /dev/tty1</span><br><span class="line">#sleep 1</span><br><span class="line">#/etc/rc.d/init.d/leds start</span><br><span class="line">#echo &quot;                        &quot; &gt; /dev/tty1</span><br><span class="line">#echo &quot;Starting leds service...&quot; &gt; /dev/tty1</span><br><span class="line">#echo &quot;                        &quot;</span><br><span class="line">#sleep 1</span><br><span class="line"></span><br><span class="line">#echo &quot;*************************************&quot; &gt; /dev/ttySAC2</span><br><span class="line">#echo &quot;     http://www.topeet.com.cn        &quot; &gt; /dev/ttySAC2</span><br><span class="line">#echo &quot;*************************************&quot; &gt; /dev/ttySAC2</span><br><span class="line">#echo &quot;*************************************&quot; </span><br><span class="line">#echo &quot;     http://www.topeet.com.cn        &quot; </span><br><span class="line">#echo &quot;*************************************&quot; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mkdir /mnt/disk</span><br><span class="line"></span><br><span class="line">sleep 1</span><br><span class="line">/sbin/ifconfig lo 127.0.0.1</span><br><span class="line">/etc/init.d/ifconfig-eth0</span><br></pre></td></tr></table></figure></li><li><p>建立/etc/passwd文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root::0:0:root:/:/bin/sh</span><br><span class="line">bin:*:1:1:bin:/bin:</span><br><span class="line">daemon:*:2:2:daemon:/sbin:</span><br><span class="line">nobody:*:99:99:Nobody:/:</span><br></pre></td></tr></table></figure></li><li><p>建立/etc/profile文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># Ash profile</span><br><span class="line"># vim: syntax=sh</span><br><span class="line"></span><br><span class="line"># No core files by default</span><br><span class="line">ulimit -S -c 0 &gt; /dev/null 2&gt;&amp;1</span><br><span class="line"></span><br><span class="line">USER=&quot;`id -un`&quot;</span><br><span class="line">LOGNAME=$USER</span><br><span class="line">PS1=&apos;[$USER@HOSTNAME]# &apos;</span><br><span class="line">PATH=$PATH</span><br><span class="line"></span><br><span class="line">HOSTNAME=`/bin/hostname`</span><br><span class="line"></span><br><span class="line">export USER LOGNAME PS1 PATH</span><br></pre></td></tr></table></figure></li><li><p>建立/etc/rc.d/init.d/netd， 修改755权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line">base=inetd</span><br><span class="line"></span><br><span class="line"># See how we were called.</span><br><span class="line">case &quot;$1&quot; in</span><br><span class="line">    start)</span><br><span class="line">                /usr/sbin/$base</span><br><span class="line">        ;;</span><br><span class="line">    stop)</span><br><span class="line">        pid=`/bin/pidof $base`</span><br><span class="line">        if [ -n &quot;$pid&quot; ]; then</span><br><span class="line">            kill -9 $pid</span><br><span class="line">        fi</span><br><span class="line">        ;;</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure></li></ol><h4 id="库文件-lib"><a href="#库文件-lib" class="headerlink" title="库文件/lib"></a>库文件/lib</h4><p>交叉编译环境与内核编译环境相同，编译器是arm-2009q3. Busybox编译生成的二进制文件以动态链接库的形式运行，所以要拷贝编译器里边的库文件到lib目录下<br><code>cp /usr/local/arm/arm-2009q3/arm-none-linux-gnueadi/libc/lib/* [lib dir]</code></p><h4 id="日志目录-var"><a href="#日志目录-var" class="headerlink" title="日志目录 /var"></a>日志目录 /var</h4><p>在该目录下建立 ./lib ./lock ./log ./run ./tmp等五个目录</p><h4 id="到这里就制作好了文件系统"><a href="#到这里就制作好了文件系统" class="headerlink" title="到这里就制作好了文件系统"></a>到这里就制作好了文件系统</h4><h3 id="安装打包软件和编译"><a href="#安装打包软件和编译" class="headerlink" title="安装打包软件和编译"></a>安装打包软件和编译</h3><p>打包工具make_ext4fs用来将文件系统制作成二进制文件。提供的linux_tools.tgz, 解压到<code>/</code>目录下</p><p>在最小linux系统/system路径下，使用命令<code>make_ext4fs -s -l 314572800 -a root -L linux system.img system</code> 生成system.img文件系统镜像。</p><h3 id="烧写最小系统"><a href="#烧写最小系统" class="headerlink" title="烧写最小系统"></a>烧写最小系统</h3><p>在win7下，通过Hyper Terminal 串口与版子进行连接，注意串口UART不支持热插拔<br>在Hyper Terminal下，命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fdisk -c 0</span><br><span class="line">fatformat mmc 0:1</span><br><span class="line">ext3format mmc 0:2</span><br><span class="line">ext3format mmc 0:3</span><br><span class="line">ext3format mmc 0:4</span><br><span class="line">fastboot</span><br></pre></td></tr></table></figure></p><p>将板子的OTG与win7连接起来，查看电脑是否能识别android phone，如果没有的话要安装驱动（位于文件02_编译器与烧写工具/tools/usb_otg_driver中，关注自己win7的版本）</p><p>在cmd.exe中运行（注意在cmd中，更改路径为 cd /d platform_tools）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fastboot.exe flash kernel file/zImage</span><br><span class="line">fastboot.exe flash system file/system.img</span><br><span class="line">fastboot.exe flash ramdisk file/ramdisk-uboot.img</span><br><span class="line">fastboot -w</span><br><span class="line">fastboot reboot</span><br></pre></td></tr></table></figure></p><h3 id="交叉编译一个helloworld文件，并做进system-tmp中"><a href="#交叉编译一个helloworld文件，并做进system-tmp中" class="headerlink" title="交叉编译一个helloworld文件，并做进system/tmp中"></a>交叉编译一个helloworld文件，并做进system/tmp中</h3><p>代码交叉编译helloworld.c</p><ol><li>保证环境变量将arm-2009a3/bin加进PATH</li><li><code>arm-none-linux-gnueabi-gcc helloworld.c -o helloworld -static</code> -static静态链接将运用到的库静态链接进入可执行文件，因为现在的linux最小系统/usr中并没有包括glibc的动态链接库。注意这个helloworld文件在ubuntu下是不能执行的，因为是按照arm指令集进行编译的，而不是x86系统下的gcc编译的。</li><li>将编译好的helloworld可执行文件cp到linux最小系统的/tmp路径下，将最小系统进行烧写。</li><li>在Hyper Terminal下运行helloworld。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac下配置VSCode</title>
      <link href="/2020/01/10/Mac%E4%B8%8B%E9%85%8D%E7%BD%AEVSCode/"/>
      <url>/2020/01/10/Mac%E4%B8%8B%E9%85%8D%E7%BD%AEVSCode/</url>
      
        <content type="html"><![CDATA[<p>最近配置了Mac和Linux下的VSCode来进行C++开发<br>可参考：<a href="https://zhuanlan.zhihu.com/p/48233069" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/48233069</a><br>但是有一些环境配置有出入，所以再记录一下。</p><p>整个的VSCode项目有三个项目文件要进行配置。</p><ul><li>c_cpp_properties.json: 用来配置环境变量和编译器</li><li>tasks.json: 用来设定编译的操作，如设置命令行操作 clang -g file.c -o file</li><li>launch.json: 用来设定debug运行时的设置</li></ul><p>要进行更改的主要是环境变量，要找到PC中库文件和头文件的装载地址。</p><h3 id="相同的步骤"><a href="#相同的步骤" class="headerlink" title="相同的步骤"></a>相同的步骤</h3><ol><li>下载VS Code编译器</li><li>在Extensions中下载C/C++插件</li></ol><h3 id="Mac下"><a href="#Mac下" class="headerlink" title="Mac下"></a>Mac下</h3><p>Mac下的C/C++编译器由XCode托管，包括相关的C库。所以配置C库和头文件首先要下载XCode</p><ol><li>在App Store中下载XCode</li><li>安装成功后安装command line tool。运行命令<code>xcode-select --install</code></li><li><strong>安装成功后查看clang地址</strong> （与参考链接中不同的地方）：<br> 运行命令 <code>gcc --version</code><br> <img src="/images/Mac下配置VSCode/gcc_version.png" alt="gcc version"><br> 这里看到有一个 —with-gxx-include-dir. 这个包含了必要的C库和一些其他的链接库。所以最终的c_cpp_properties.json如下： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    &#123;</span><br><span class="line">    &quot;configurations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;Mac&quot;,</span><br><span class="line">            &quot;includePath&quot;: [</span><br><span class="line">                &quot;$&#123;workspaceFolder&#125;/**&quot;,</span><br><span class="line">                &quot;/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/&quot;,</span><br><span class="line">                &quot;/Library/Developer/CommandLineTools/usr/include/c++/v1&quot;,</span><br><span class="line">                &quot;/Library/Developer/CommandLineTools/usr/lib/clang/11.0.0/include&quot;,</span><br><span class="line">                &quot;/Library/Developer/CommandLineTools/usr/include&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;defines&quot;: [],</span><br><span class="line">            &quot;macFrameworkPath&quot;: [</span><br><span class="line">                &quot;/System/Library/Frameworks&quot;,</span><br><span class="line">                &quot;/Library/Frameworks&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;compilerPath&quot;: &quot;/usr/bin/clang&quot;,</span><br><span class="line">            &quot;cStandard&quot;: &quot;c11&quot;,</span><br><span class="line">            &quot;cppStandard&quot;: &quot;c++17&quot;,</span><br><span class="line">            &quot;intelliSenseMode&quot;: &quot;clang-x64&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;version&quot;: 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="Linux下"><a href="#Linux下" class="headerlink" title="Linux下"></a>Linux下</h3><p>环境变量都在<code>/usr/local/include</code>里，所以直接包含这一个就可以了</p><h3 id="tasks"><a href="#tasks" class="headerlink" title="tasks"></a>tasks</h3><p>每一个tasks其实就执行了一个gcc编译命令，注意c程序用gcc/clang编译，而c++程序要用g++/clang++编译。每一行编译命令就对应了下边的一个结构。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;type&quot;: &quot;shell&quot;,</span><br><span class="line">  &quot;label&quot;: &quot;POJ_1000_cpp&quot;,</span><br><span class="line">  &quot;command&quot;: &quot;g++&quot;,</span><br><span class="line">  &quot;args&quot;: [</span><br><span class="line">      &quot;-g&quot;,</span><br><span class="line">      &quot;$&#123;workspaceFolder&#125;/1000_cpp.cpp&quot;,</span><br><span class="line">      &quot;-o&quot;,</span><br><span class="line">      &quot;$&#123;workspaceFolder&#125;/1000_cpp&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;options&quot;: &#123;</span><br><span class="line">      &quot;cwd&quot;: &quot;/usr/bin&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;problemMatcher&quot;: [</span><br><span class="line">      &quot;$gcc&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;group&quot;: &quot;build&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>或者如果你要执行一个Makefile命令，那么就在当前目录下创建Makefile，然后command使用make。如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;type&quot;: &quot;shell&quot;,</span><br><span class="line">  &quot;label&quot;: &quot;make command&quot;,</span><br><span class="line">  &quot;command&quot;: &quot;make&quot;,</span><br><span class="line">  &quot;group&quot;: &quot;build&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>参考编写Makefile：(注意，经常生成makefile是在${workspaceFolder}/.vscode/下生成的，而不是在代码路径下。在生成makefile的时候要注意路径)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">target=hello</span><br><span class="line">obj=hello.o</span><br><span class="line">CC=gcc -g</span><br><span class="line"></span><br><span class="line">$(target):$(obj)</span><br><span class="line">    $(CC) $(obj) -o $(target)</span><br><span class="line"></span><br><span class="line">$(obj):</span><br><span class="line">    $(CC) -c hello.c -o $(obj)</span><br><span class="line">    </span><br><span class="line">clean:</span><br><span class="line">    rm -rf $(target) $(obj)</span><br></pre></td></tr></table></figure></p><h3 id="launch"><a href="#launch" class="headerlink" title="launch"></a>launch</h3><p>典型的launch文件来配置调试参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;POJ_1000_launch&quot;,</span><br><span class="line">  &quot;type&quot;: &quot;cppdbg&quot;, //必填项，调试类型</span><br><span class="line">  &quot;request&quot;: &quot;launch&quot;, //必填项，有两种类型，分别是launch和attach。launch就是vscode会打开这个文件进行执行，attach是这个文件已经打开了</span><br><span class="line">  &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/1000&quot;, //是要进行调试的可执行文件</span><br><span class="line">  &quot;args&quot;: [],</span><br><span class="line">  &quot;stopAtEntry&quot;: false,</span><br><span class="line">  &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;,</span><br><span class="line">  &quot;environment&quot;: [],</span><br><span class="line">  &quot;externalConsole&quot;: true, //跳出terminal进行命令行输入</span><br><span class="line">  &quot;MIMode&quot;: &quot;lldb&quot;,</span><br><span class="line">  &quot;preLaunchTask&quot;: &quot;POJ_1000&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VSCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac升级catelina，bash升级成了zsh</title>
      <link href="/2020/01/08/mac%E5%8D%87%E7%BA%A7catelina%EF%BC%8Cbash%E5%8D%87%E7%BA%A7%E6%88%90%E4%BA%86zsh/"/>
      <url>/2020/01/08/mac%E5%8D%87%E7%BA%A7catelina%EF%BC%8Cbash%E5%8D%87%E7%BA%A7%E6%88%90%E4%BA%86zsh/</url>
      
        <content type="html"><![CDATA[<h3 id="在命令行中切换bash和zsh"><a href="#在命令行中切换bash和zsh" class="headerlink" title="在命令行中切换bash和zsh"></a>在命令行中切换bash和zsh</h3><p><code>chsh -s /bin/bash</code><br><code>chsh -s /bin/zsh</code></p><h3 id="原来在bash中的环境变量在zsh中丢失了"><a href="#原来在bash中的环境变量在zsh中丢失了" class="headerlink" title="原来在bash中的环境变量在zsh中丢失了"></a>原来在bash中的环境变量在zsh中丢失了</h3><p>首先以为在~/.zshrc中加入source ~/.bash_profile就可以解决，但是发现用户名出现了乱码</p><p>于是将~/.bash_profile中的$PATH添加进zshrc环境变量中</p>]]></content>
      
      
      
        <tags>
            
            <tag> zsh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 1305. All Elements in Two Binary Search Trees</title>
      <link href="/2020/01/08/Leetcode-1305-All-Elements-in-Two-Binary-Search-Trees/"/>
      <url>/2020/01/08/Leetcode-1305-All-Elements-in-Two-Binary-Search-Trees/</url>
      
        <content type="html"><![CDATA[<p>问题描述:<br>Given two binary search trees root1 and root2.</p><p>Return a list containing all the integers from both trees sorted in ascending order.</p><p>Example:<br>Input: root1 = [2,1,4], root2 = [1,0,3]<br>Output: [0,1,1,2,3,4]</p><p>思路1：首先想到的当然是一个先序遍历得到两个ascending数组，然后再合并两个ascending数组。<br>时间复杂度O(nlogk),空间复杂度为O(n+k)。</p><p>为了降低空间复杂度和申请的内存空间。先序遍历二叉树的结果就是将每一个最左子树的右子树展开，相连。<br>于是有了如下方案：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    </span><br><span class="line">    void pushLeft(stack&lt;TreeNode*&gt; &amp;s, TreeNode* node)&#123;</span><br><span class="line">        while(node)&#123;</span><br><span class="line">            s.push(node);</span><br><span class="line">            node = node-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;int&gt; getAllElements(TreeNode* root1, TreeNode* root2) &#123;</span><br><span class="line">        vector&lt;int&gt; ret;</span><br><span class="line">        </span><br><span class="line">        stack&lt;TreeNode*&gt; s1, s2;</span><br><span class="line">        pushLeft(s1, root1);</span><br><span class="line">        pushLeft(s2, root2);</span><br><span class="line">        </span><br><span class="line">        while(s1.size() || s2.size())&#123;</span><br><span class="line">            stack&lt;TreeNode*&gt; &amp;s = !s1.size()?s2: !s2.size()? s1: s1.top()-&gt;val&lt;s2.top()-&gt;val? s1:s2; //reference must be initialized</span><br><span class="line">            // stack&lt;TreeNode*&gt; &amp;s = s1;</span><br><span class="line">            // if(!s1.size())&#123;</span><br><span class="line">            //     s = s2;</span><br><span class="line">            // &#125; else if(!s2.size())&#123;</span><br><span class="line">            //     s = s1;</span><br><span class="line">            // &#125; else&#123;</span><br><span class="line">            //     TreeNode* node1 = s1.top();</span><br><span class="line">            //     TreeNode* node2 = s2.top();</span><br><span class="line">            //     if(node1-&gt;val &lt; node2-&gt;val) s = s1;</span><br><span class="line">            //     else s = s2;</span><br><span class="line">            // &#125;</span><br><span class="line">            </span><br><span class="line">            TreeNode* node = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            ret.push_back(node-&gt;val);</span><br><span class="line">            pushLeft(s, node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>这里思路比较容易想明白，但是这里需要用到一个引用。<br>引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。</p><p><strong>引用在声明的时候就必须初始化</strong>。</p><p>但是不知道为什么Java就可以 <a href="https://leetcode.com/problems/all-elements-in-two-binary-search-trees/discuss/465183/One-pass-O(n)-time-using-stack-(easy-to-understand)" target="_blank" rel="noopener">https://leetcode.com/problems/all-elements-in-two-binary-search-trees/discuss/465183/One-pass-O(n)-time-using-stack-(easy-to-understand)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux驱动开发详解（4.0）-- Timer相关</title>
      <link href="/2020/01/07/Linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E8%AF%A6%E8%A7%A3%EF%BC%884-0%EF%BC%89-Timer%E7%9B%B8%E5%85%B3/"/>
      <url>/2020/01/07/Linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E8%AF%A6%E8%A7%A3%EF%BC%884-0%EF%BC%89-Timer%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<p>学习宋宝华Linux驱动开发详解（基于kernel 4.0）ch10 中断 timer中实践代码笔记。</p><p>编程环境：<br>ubuntu 16.04<br>Kernel 4.15.0-generic</p><h3 id="内核定时器"><a href="#内核定时器" class="headerlink" title="内核定时器"></a>内核定时器</h3><p>软件意义上的定时器最终由硬件定时器实现。Top Half：内核在时钟中断发生后检测各定时器是否到期。Bottom Half：到期后的定时器处理函数将作为软中断在底半部执行。</p><h4 id="数据结构：timer-list"><a href="#数据结构：timer-list" class="headerlink" title="数据结构：timer_list"></a>数据结构：timer_list</h4><p>书中版本采用的kernel 4.0<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//from kernel v4.4</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * All fields that change during normal runtime grouped to the</span></span><br><span class="line"><span class="comment"> * same cacheline</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span><span class="title">entry</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>expires;</span><br><span class="line"><span class="keyword">void</span>(*function)(<span class="keyword">unsigned</span> <span class="keyword">long</span>); <span class="comment">//这里中断处理函数的参数是unsigned long</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>data;</span><br><span class="line">u32flags;</span><br><span class="line"><span class="keyword">int</span>slack;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_TIMER_STATS</span></span><br><span class="line"><span class="keyword">int</span>start_pid;</span><br><span class="line"><span class="keyword">void</span>*start_site;</span><br><span class="line"><span class="keyword">char</span>start_comm[<span class="number">16</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span><span class="title">lockdep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>而内核环境4.15对timer.h进行了更改<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//from kernel v4.15</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * All fields that change during normal runtime grouped to the</span></span><br><span class="line"><span class="comment"> * same cacheline</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span><span class="title">entry</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>expires;</span><br><span class="line"><span class="keyword">void</span>(*function)(struct timer_list *); <span class="comment">//这里传入的是timer_list实例</span></span><br><span class="line">u32flags;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span><span class="title">lockdep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h4 id="timer-list初始化"><a href="#timer-list初始化" class="headerlink" title="timer_list初始化"></a>timer_list初始化</h4><p>初始化timer_list的时候最终执行的都是<code>_init_timer</code>这个函数，但是这个函数在两个版本中的定义也发生了修改。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//from v4.4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __init_timer(_timer, _flags)\</span></span><br><span class="line"><span class="keyword">do</span> &#123;\</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> __<span class="title">key</span>;</span>\</span><br><span class="line">init_timer_key((_timer), (_flags), #_timer, &amp;__key);\</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//from v4.15</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __init_timer(_timer, _fn, _flags)\</span></span><br><span class="line"><span class="keyword">do</span> &#123;\</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> __<span class="title">key</span>;</span>\</span><br><span class="line">init_timer_key((_timer), (_fn), (_flags), #_timer, &amp;__key);\</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure><ul><li>在宋宝华版本的second.c中在<code>second_open</code>中使用了<code>init_timer(struct timer_list *timer_list)</code>这个函数进行初始化（v4.4），但这个函数在v4.15被删除了。</li><li>同样，在timer_list结构体中，handler function传入的参数也进行了改变。</li></ul><p>在内核编译的过程中要注意。编译报错tips：</p><ul><li>Implicit declaration of function: 通常出现在：1.没有把函数所在的c文件生成.o文件； 2.在函数所属的c文件中定义了，但是没有在.h文件中声明</li><li>assignment from incompatible pointer type: 通常出现在函数传入的参数指针类型不一致的情况。</li></ul><h3 id="内核模块命令行参数传递"><a href="#内核模块命令行参数传递" class="headerlink" title="内核模块命令行参数传递"></a>内核模块命令行参数传递</h3><p>在user mode中，我们可以通过main(int argc, char *argv[])来进行命令行参数传递，在运行可执行文件的时候跟上命令行参数来配置相关变量。<br>在kernel mode中，通过module_param来进行设置命令行参数module_param(name, type, perm)。</p><p>在原版宋宝华second.c文件中，second_major设置为了248。但查看系统内置驱动<code>cat /proc/devices</code>可以看到248被watchdog所占用，所以在安装insmod的时候出现了报错<code>Device or resource busy</code>.</p><p>这时候我们要通过命令行参数来修改second_major的主设备号到260，或为0使得系统为second分配一个没有使用过的设备号。</p><ul><li>查看模块信息，<code>modinfo second.ko</code>。看到param: second_major:int</li><li>安装模块 <code>insmod second.ko second_major=0</code> (使系统为second分配一个没有使用过的设备号)</li><li>查看安装好的模块 <code>cat /proc/devices</code> 可以看到设备号被分到了244</li></ul><h3 id="安装设备（文件）在-dev"><a href="#安装设备（文件）在-dev" class="headerlink" title="安装设备（文件）在/dev"></a>安装设备（文件）在/dev</h3><p>使用mknod命令在/dev中进行实体设备（文件）安装。一个设备只有在定义了正确的主设备号才能被链接到正确的设备驱动中。<br><code>mknod [name] [type: c-char b-block] [major] [minor]</code></p><h4 id="使用shell脚本从-proc-devices中获取驱动的主设备号"><a href="#使用shell脚本从-proc-devices中获取驱动的主设备号" class="headerlink" title="使用shell脚本从/proc/devices中获取驱动的主设备号"></a>使用shell脚本从/proc/devices中获取驱动的主设备号</h4><p><code>awk &#39;{if($2==&quot;your-driver&quot;) {print $1}}&#39; /proc/devices</code><br>awk是一个强大的文本编辑命令。<br>所以命令为：<br><code>mknod /dev/second c $(awk &#39;{if($2==&quot;second&quot;) print $1} /proc/devices&#39;) 0</code></p><h3 id="测试second设备"><a href="#测试second设备" class="headerlink" title="测试second设备"></a>测试second设备</h3><p>运行second_test可执行文件，可以看到实际上user就是去读取了设备文件中的counter。而counter是在每一次内核时钟中断到来的时候由second_timer_handler进行处理。</p><p>定时器的到期时间往往是在当前jiffies的数目上加上一个时延，如果是HZ，表示1s。</p><p>查看kernel msg <code>cat /proc/kmsg</code> 不会打印之前已经打印过的log<br><code>dmesg</code> 会将从开机到现在所有的log都打印出来</p>]]></content>
      
      
      <categories>
          
          <category> Linux 驱动 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 宋宝华 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 竞态及机制</title>
      <link href="/2019/12/20/Linux-%E7%AB%9E%E6%80%81%E5%8F%8A%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/12/20/Linux-%E7%AB%9E%E6%80%81%E5%8F%8A%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="并发与竞态"><a href="#并发与竞态" class="headerlink" title="并发与竞态"></a>并发与竞态</h2><h3 id="什么是并发和竞态"><a href="#什么是并发和竞态" class="headerlink" title="什么是并发和竞态"></a>什么是并发和竞态</h3><h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><p>多个执行单元（进程与线程）同时进行，并行被操作。由于虚拟设备机制，每一个执行单元都认为自己独占了CPU和硬件资源。</p><ul><li>单核时执行单元交叉执行，伪并行</li><li>多核时SMP的真并行<h4 id="竞态"><a href="#竞态" class="headerlink" title="竞态"></a>竞态</h4>并发的执行单元对<strong>共享资源</strong>（硬件资源，软件中的全局变量，静态变量等）的访问会产生竞态 concurrency。</li></ul><h3 id="竞态发生的条件"><a href="#竞态发生的条件" class="headerlink" title="竞态发生的条件"></a>竞态发生的条件</h3><ul><li>对称多处理器SMP的多个CPU。SMP是紧耦合、共享存储的系统模型。特点是其多个CPU能够使用共同的系统总线，可以访问共同的外设和存储器。</li><li>单核CPU，抢占的进程。从Linux2.6开始支持内核抢占调度，一个进程 <em>在内核执行</em> 的过程中可能被另一个高优先级进程大端。</li><li>中断（硬中断，软中断，tasklet，底半部）与进程之间：中断可以打断正在执行的进程，处理中断的程序和被打断的进程间也可能发生竞态。</li></ul><h3 id="竞态解决的方法"><a href="#竞态解决的方法" class="headerlink" title="竞态解决的方法"></a>竞态解决的方法</h3><p><strong>对共享资源的互斥访问</strong>。访问共享资源的代码段成为临界区，进入临界区时要进行互斥保护。<br>Linux下常见的互斥保护为：</p><ul><li>中断屏蔽（禁止中断抢占）</li><li>原子操作（只能对整数操作）</li><li>自旋锁</li><li>信号量</li></ul><h2 id="竞态解决方法"><a href="#竞态解决方法" class="headerlink" title="竞态解决方法"></a>竞态解决方法</h2><h3 id="中断屏蔽"><a href="#中断屏蔽" class="headerlink" title="中断屏蔽"></a>中断屏蔽</h3><ul><li>单CPU中，在进入临界区之前将进程状态设置为中断屏蔽状态，进入临界区之后将不会被抢占。</li><li><strong>注意</strong>：linux的异步IO，进程调度（时间片轮转）等都是通过中断来实现的。使用中断屏蔽会产生中断信号丢失，中断不响应等问题。所以临界区必须尽快完成，代码量要少。</li></ul><h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><p>提供一套API使得在原子操作在执行的过程中不会被其他进程终端操作。主要分为<strong>整形原子操作</strong>和<strong>位原子操作</strong>。依赖CPU底层原子操作实现。</p><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>自旋锁是一个可以执行原子操作的内存变量。进程在进入临界区之前要先尝试获得自旋锁。</p><ul><li>如果进程获得自旋锁，则进程进入临界区执行。</li><li>自旋锁被占用，进程将在一个小循环内不断检查自旋锁状态。<br><strong>注意事项：</strong></li><li>自旋锁是忙等待，占用CPU时间。只有在占用锁消耗小于进程切换消耗的时候才适用。</li><li>自旋锁可能会导致死锁。（递归调用的时候，获得锁之后继续尝试获得锁）</li><li>自旋锁期间不能调用任何引起进程调度的函数。</li></ul><p><strong>具体操作：</strong> #include <linux spinlock.h></linux></p><ul><li>定义自旋锁<br><code>spinlock_t lock;</code></li><li>初始化自旋锁<br><code>spin_lock_init(lock);</code></li><li>获得自旋锁<br><code>spin_lock(lock);</code><br><code>spin_trylock(lock); //如果获取不到返回false，不在原地打转</code></li><li>释放自旋锁<br><code>spin_unlock(lock);</code></li><li>为了保证不被中断打断，衍生<br><code>spin_lock_irq() = spin_lock() + local_irq_disable()</code><br><code>spin_unlock_irq() = spin_unlock() + local_irq_enable()</code><br><code>spin_lock_irqsave() = spin_lock() + local_irq_save()</code><br><code>spin_unlock_irqrestore() = spin_unlock() + local_irq_restore()</code><br><code>spin_lock_bh() = spin_lock() + local_bh_disable()</code><br><code>spin_unlock_bh() = spin_unlock() + local_bh_disable()</code></li></ul><p>基于自旋锁衍生成：</p><h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><ul><li>允许读并发</li><li>不允许写并发<h4 id="顺序锁"><a href="#顺序锁" class="headerlink" title="顺序锁"></a>顺序锁</h4></li><li>读写锁的优化</li><li>读进程在写进程对共享资源操作时仍然可以读取，但不保证读取是正确的<h4 id="RCU-read-copy-update"><a href="#RCU-read-copy-update" class="headerlink" title="RCU read-copy-update"></a>RCU read-copy-update</h4>多个读，多个写。<br>写的时候先复制，再在复制内容上写，在该共享资源被最后一个进程释放后对共享资源进行更新。</li></ul><h3 id="信号量semaphore"><a href="#信号量semaphore" class="headerlink" title="信号量semaphore"></a>信号量semaphore</h3><p>信号量也是一个可以执行原子操作的内存变量，进程在进入临界区之前试图获取信号量。经典的PV操作。信号量为正时，可以获得。信号量为非正时，不可获得</p><ul><li>进程获取信号量，进入临界区执行。</li><li>进程获取失败，进程将自己挂起，让出CPU。等待其他进程唤醒。</li></ul><p><strong>基本操作</strong>：</p><ul><li>定义信号量：<br><code>struct semaphore sema;</code></li><li>初始化信号量：<br><code>void sema_init(struct semaphore *sem, int val);</code></li><li>获取信号量：<br><code>void down(struct semaphore *sem);//获得信号量sem，其会导致睡眠，并不能被信号打断</code><br><code>int down_interruptible(struct semaphore *sem);//进入睡眠可以被信号打断</code><br><code>int down_trylock(struct semaphore *sem);//不会睡眠</code></li><li>释放信号量：<br><code>void up(struct semaphore *sem);//释放信号量，唤醒等待进程</code></li></ul><p>基于信号量衍生：</p><h4 id="Completion"><a href="#Completion" class="headerlink" title="Completion"></a>Completion</h4><p>用于linux中的同步</p><h4 id="读写信号量"><a href="#读写信号量" class="headerlink" title="读写信号量"></a>读写信号量</h4><h4 id="互斥量mutex"><a href="#互斥量mutex" class="headerlink" title="互斥量mutex"></a>互斥量mutex</h4>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题 翻转一个字符串的单词顺序</title>
      <link href="/2019/12/18/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%BF%BB%E8%BD%AC%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F/"/>
      <url>/2019/12/18/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%BF%BB%E8%BD%AC%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>面试题简述：<br>输入：给定一个字符串，用空格分隔各个单词。e.g. “This is a student”<br>输出：将单词顺序翻转。 “student a is This”</p><p>思路：</p><ol><li>第一次面微软的时候，是做了一个栈，读到空格压栈，然后再pop出来加上空格。这个要注意的是最后一个单词的处理，因为最后一个单词没有空格。虽然只是一次遍历，但是要开辟栈空间来存储所有的单词，如果这个字符串很长的话就会占用过多的内存。</li><li>面Apple CoreOS的时候出了同样的题，最开始给出了上述的方法，上述方法的栈是通过c++来实现的，但是内核编程中是要通过纯C，并且连C库都不能使用。这个时候给出的一个方法是，建立一个单词指针数组，来保存每个单词的头指针。并且在原来的字符串上进行修改。</li><li>但是这仍然要开辟更多的内存空间来保存，后来被要求尝试完全不开辟新的内存空间的方法。</li><li>那么就是如下最正确的方法：两个指针做字符串全翻转。翻转之后，空格的位置是固定的，只需要再把单词自身翻转过来就可以了。同样要注意最后一个单词不是空格指针。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void reverse(char * str, int length)&#123;</span><br><span class="line"></span><br><span class="line">    char * end = str + length -1;</span><br><span class="line">    char * start = str;</span><br><span class="line">    // char tmp;</span><br><span class="line"></span><br><span class="line">    while(start &lt; end)&#123;</span><br><span class="line">        // tmp = *start;</span><br><span class="line">        // *start = *end;</span><br><span class="line">        // *end = tmp;</span><br><span class="line"></span><br><span class="line">        *start ^= *end;</span><br><span class="line">        *end ^= *start;</span><br><span class="line">        *start ^= *end;</span><br><span class="line"></span><br><span class="line">        start++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">    char str[] = &quot;This is, a student.&quot;;</span><br><span class="line">    reverse(str, sizeof(str)-1);</span><br><span class="line"></span><br><span class="line">    printf(&quot;%s\n&quot;, str);</span><br><span class="line"></span><br><span class="line">    char* front = str;</span><br><span class="line">    char* back = front;</span><br><span class="line">    </span><br><span class="line">    while(*back != &apos;\0&apos;)&#123; //not reaching the end of the str</span><br><span class="line">        if((*back &lt; &apos;a&apos; || *back &gt; &apos;z&apos;) &amp;&amp; (*back &lt; &apos;A&apos; || *back &gt; &apos;Z&apos;))&#123;</span><br><span class="line">            reverse(front, back-front);</span><br><span class="line">            printf(&quot;%s\n&quot;, str);</span><br><span class="line">            front = back+1;</span><br><span class="line">            back = front;</span><br><span class="line">        &#125; else&#123;</span><br><span class="line">            back++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(front, back-front);</span><br><span class="line">    printf(&quot;%s\n&quot;, str);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019Dec新加坡行程</title>
      <link href="/2019/12/02/2019Dec%E6%96%B0%E5%8A%A0%E5%9D%A1%E8%A1%8C%E7%A8%8B/"/>
      <url>/2019/12/02/2019Dec%E6%96%B0%E5%8A%A0%E5%9D%A1%E8%A1%8C%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="2019-Dec-新加坡行程计划"><a href="#2019-Dec-新加坡行程计划" class="headerlink" title="2019 Dec 新加坡行程计划"></a>2019 Dec 新加坡行程计划</h2><h3 id="Dec-21"><a href="#Dec-21" class="headerlink" title="Dec 21"></a>Dec 21</h3><p><strong>早餐：</strong> 亚坤机场店 【地点1】</p><p>逛NUS【地点2】</p><p><strong>午餐：</strong> Island Penang Kitchen（咖喱鱼头，炒粿条，chandol）【地点3】</p><p>Andaz 酒店 check-in 【地点4】</p><p><strong>晚餐：</strong> Katong Old Bibik’s Peranakan Kitchen (娘惹菜)<a href="https://oldbibik.com/" target="_blank" rel="noopener">https://oldbibik.com/</a> 【地点5】 和 328 Katong Laksa 【地点6】</p><p>林俊杰演唱会 （7 PM开始）【地点7】</p><p>可选夜宵Geylang（榴莲，街边小吃）【地点8】</p><iframe src="https://www.google.com/maps/d/embed?mid=1Ty5UPCwo6eoMpyuiIC5EPoNVb8r54ZBy" width="640" height="480"></iframe><h3 id="Dec-22-Downtown-Core"><a href="#Dec-22-Downtown-Core" class="headerlink" title="Dec 22 Downtown Core"></a>Dec 22 Downtown Core</h3><p>Dec 22：需要早起，需要走路</p><p><strong>早餐：</strong> 酒店早餐 或 Haji Lane 早餐</p><p>滨海湾公园 【地点2】，金沙酒店，鱼尾狮公园【地点3】</p><p><strong>午餐：</strong> 廖凡油鸡饭，松发肉骨茶， China town food street【地点4，5】</p><p>Fort Canning Park Tunnel 【地点6】<br>Orchard Road 乌节路 【地点7】</p><p><strong>晚餐：</strong> 老巴刹 Satay 【地点8】</p><p>滨海湾夜景，esplande 【回到地点3】</p><iframe src="https://www.google.com/maps/d/embed?mid=1NYmZ5Bntcz0K3ctPykpd7qnPErLy8BYQ" width="640" height="480"></iframe><h3 id="Dec-23-Sentosa"><a href="#Dec-23-Sentosa" class="headerlink" title="Dec 23 Sentosa"></a>Dec 23 Sentosa</h3><p><strong>早餐：</strong> 酒店早餐或其他什么不知道的早餐</p><p>圣淘沙，USS，圣淘沙海滩（反正我也没去过，希望不迷路）</p><p><strong>午餐：</strong> VivoCity Food Republic（大食代）</p><p>返回NUS洗衣服<br>Jurong East IMM购物</p><p>晚餐：Jurong East食阁<br>从NUS回酒店</p><iframe src="https://www.google.com/maps/d/embed?mid=1k8r6I_hpciD6_6R9UooLhFCz_oFTUgoo" width="640" height="480"></iframe><h3 id="Dec-24-Jewel-Changi"><a href="#Dec-24-Jewel-Changi" class="headerlink" title="Dec 24 Jewel Changi"></a>Dec 24 Jewel Changi</h3><p>Bugis附近转一下，然后check out 去Jewel到机场。</p>]]></content>
      
      
      <categories>
          
          <category> Travel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Travel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Simple Scull驱动</title>
      <link href="/2019/12/01/Linux-simple-Scull%E9%A9%B1%E5%8A%A8/"/>
      <url>/2019/12/01/Linux-simple-Scull%E9%A9%B1%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<p>参考《Linux设备驱动程序第3版》</p><h2 id="Scull字符型驱动程序的设备描述"><a href="#Scull字符型驱动程序的设备描述" class="headerlink" title="Scull字符型驱动程序的设备描述"></a>Scull字符型驱动程序的设备描述</h2><p>字符设备驱动程序是分配一段内存，然后提供对这个设备的管理方式，我们通过它提供的操作来操纵字符驱动设备。本质上是一个我们分配的模拟内存来模拟驱动设备。</p><h3 id="设备编号"><a href="#设备编号" class="headerlink" title="设备编号"></a>设备编号</h3><p>字符型驱动设备可以通过命令<code>ls -l</code>查看文件类型为c的设备。</p><ul><li>major主设备编号标识设备对应的驱动程序</li><li>minor次设备号由内核使用，用于正确确定设备文件所指的设备。</li><li>在内核中，dev_t(定义在<linux types.h>中)用来保存设备编号，包括major和minor。</linux></li><li>在建立一个字符设备之前，驱动程序首先要获取一个或多个设备编号。函数为<code>register_chrdev_region</code>在<linux fs.h中声明>。清除函数为<code>unregister_chrdev_region</code>。这种方式属于<strong>静态分配</strong>一个当前没有使用的设备号为主设备号。</linux></li><li>动态分配<code>alloc_chrdev_region</code>。</li><li>一旦分配了设备号，就可以从/proc/devices中得到。</li><li><p>安装scull设备，使用内核命令insmod(/sbin/insmod)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">module=&quot;scull&quot;</span><br><span class="line">device=&quot;scull&quot;</span><br><span class="line">mode=&quot;664&quot;</span><br><span class="line"></span><br><span class="line">#install scull，invoke insmod with all arguments we got</span><br><span class="line">#use a pathname, as insmod doesn&apos;t look in . by default</span><br><span class="line">/sbin/insmod ./$module.ko $* || exit 1</span><br><span class="line"></span><br><span class="line">#retrieve the major number</span><br><span class="line">major=$( awk &quot;\$2==\&quot;$module&quot; &#123;print \$1&#125;&quot; /proc/devices)</span><br><span class="line">#which is same as</span><br><span class="line">major=$( awk &quot;\$2==\&quot;scull\&quot; &#123;print \$1&#125;&quot; \proc\devices)</span><br><span class="line"></span><br><span class="line">#remove stale nodes</span><br><span class="line">rm -f /dev/$&#123;device&#125;[0-3]</span><br><span class="line"></span><br><span class="line">echo $&#123;device&#125;0 $&#123;major&#125;0</span><br><span class="line"></span><br><span class="line">#make nodes，创建了四个设备</span><br><span class="line">mknod /dev/$&#123;device&#125;0 c $major 0</span><br><span class="line">mknod /dev/$&#123;device&#125;1 c $major 1</span><br><span class="line">mknod /dev/$&#123;device&#125;2 c $major 2</span><br><span class="line">mknod /dev/$&#123;device&#125;3 c $major 3</span><br><span class="line"></span><br><span class="line">ln -sf $&#123;device&#125;0 /dev/$&#123;device&#125;</span><br><span class="line"></span><br><span class="line"># grep -q表示quiet不显示任何结果，正则表达式匹配^表示匹配字</span><br><span class="line">符串起始位置</span><br><span class="line"># wheel组包含特殊权限，可以执行root权限但并不需要知道root管理员密码。</span><br><span class="line">if grep -q &apos;^staff:&apos; /etc/group; then</span><br><span class="line">    group=&apos;staff&apos;</span><br><span class="line">else</span><br><span class="line">    group=&apos;wheel&apos;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">chgrp $group /dev/$&#123;device&#125;[0-3]</span><br><span class="line">chmod $mode /dev/$&#123;device&#125;[0-3] #配置权限664</span><br></pre></td></tr></table></figure></li><li><p>卸载设备</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">module=&quot;scull&quot;</span><br><span class="line">device=&quot;scull&quot;</span><br><span class="line"></span><br><span class="line">#remove module from the kernel</span><br><span class="line">/sbin/rmmod $module $* || exit 1</span><br><span class="line"></span><br><span class="line">#remove the device file</span><br><span class="line">rm -f /dev/$&#123;device&#125; /dev/$&#123;device&#125;[0-3]</span><br></pre></td></tr></table></figure></li></ul><p><img src="/images/Linux-simple-Scull驱动/安装好的dev.png" alt="安装好的dev"><br>可以看出在/dev下，scull这个模块包含四个设备，保存在一个文件夹中，并且文件夹指向scull0设备。</p><ul><li>除了使用load和unload脚本之外，还可以编写一个init脚本，并保存在发行版使用的init脚本目录中（scull.init）。接收约定的参数（start、stop、restart）也可以完成scull_load和scull_unload双重任务。</li><li><strong>分配设备号的最佳方式</strong>。默认采用动态方式，同时保留加载或编译是指定的主设备编号。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dev_t</span> dev = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> result;</span><br><span class="line"><span class="keyword">if</span>(scull_major)&#123; <span class="comment">//存在驱动程序</span></span><br><span class="line">    dev = MKDEV(scull_major, scull_minor);</span><br><span class="line">    result = register_chrdev_region(dev, scull_nr_devs, <span class="string">"scull"</span>); <span class="comment">//在dev设备上注册设备</span></span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    result = alloc_chrdev_region(&amp;dev, scull_minor, scull_nr_devs, <span class="string">"scull"</span>); <span class="comment">//分配major驱动程序编号</span></span><br><span class="line">    scull_major = MAJOR(dev); <span class="comment">//获取设备驱动</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(result &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    printk(KERN_WARNING <span class="string">"scull: can't get major %d\n"</span>, scull_major);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="驱动程序需要的数据结构"><a href="#驱动程序需要的数据结构" class="headerlink" title="驱动程序需要的数据结构"></a>驱动程序需要的数据结构</h3><p>大部分基本的驱动程序操作涉及到三个重要的内核数据结构，分别是file_operations、file和inode。</p><h4 id="file-operations-文件操作"><a href="#file-operations-文件操作" class="headerlink" title="file_operations 文件操作"></a>file_operations 文件操作</h4><ul><li>file_operations是建立驱动程序操作与设备编号之间的连接。该结构定义在<linux fs.h>，其中包含一组函数指针。</linux></li><li>每个打开的文件（file）和一组函数关联。这些操作主要用来实现系统调用。我们可以认为文件是一个”对象“，而操作他的函数是”方法“。</li><li>在查看file_operations方法清单时，我们会注意到许多参数包含__user字符串，表明指针是一个用户空间地址，不能被直接饮用。</li></ul><p>基本的file_operations数据结构：</p><ul><li>struct module *owner ：指向”拥有“该结构的木偶快的指针。内核使用这个字段来避免在模块的操作正在被使用时卸载该模块。该成员都会被初始化为<code>THIS_MODULE</code>, which is defined in <linux module.h></linux></li><li>loff_t (**llseek) (struct file *, loff_t, int); 该方法用来修改文件当前读写位置，并将新的位置（正的）作为返回值返回。loff_t是一个长偏移量。如果这个函数指针是NULL，那么对seek的调用将以某种不可预期的方式修改file结构中的位置计数器。</li><li>ssize_t (*read) (struct file <em>, char __user </em>, size_t, loff_t *); 从设备中读取数据，该函数指针为NULL时，将导致read系统调用出错并返回-EINVAL（invalid argument）。函数返回成功读取的字节数。对应的异步读取函数为aio_read。</li><li>ssize_t (*write) (struct file <em>, const char __user </em>, size_t, loff_t); 向设备发送数据。对应的异步写入操作 (aio_write)</li><li>int (*open) (struct inode <em>, struct file </em>); 这是对设备文件执行的第一个操作，但并不是一定要声明，如果入口为NULL，设备的打开操作会永远成功，但系统不会通知驱动程序。</li><li>int (*lock) (struct file <em>, int, struct file_lock </em>); lock方法用于实现文件锁定，锁定是常规文件不可缺少的特性，但设备驱动程序基本不会实现这个方法。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct file_operations scull_fops=&#123;</span><br><span class="line">    .owener =   THIS_MODULE,</span><br><span class="line">    .llseek =   scull_llseek,</span><br><span class="line">    .read =     scull_read,</span><br><span class="line">    .write =    scull_write,</span><br><span class="line">    .ioctl =    scull_ioctl,</span><br><span class="line">    .open =     scull_open,</span><br><span class="line">    .release =  scull_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="file文件结构"><a href="#file文件结构" class="headerlink" title="file文件结构"></a>file文件结构</h4><ul><li>file结构与用户空间程序中的FILE没有任何联系，（FILE是在C库中定义的，所以不会出现在内核中）struct file是一个内核结构，不会出现在用户结构中。</li><li>struct file表示一个打开的文件（不仅仅限定于设备驱动程序，系统中每个打开的文件在内核空间中都有一个对应的file结构）。由内核在open操作时创建，并传递给该文件上进行操作的所有函数，直到最后close函数。</li><li>mode_t f_mode: 文件模式，通过FMODE_READ和FMODE_WRITE来标识文件是否可读或可写。内核在调用驱动程序的read和write之前已经检查了访问权限，没有访问权限的情况下内核将拒绝对该文件进行读写操作。</li><li>loff_t f_pos: 当前read/write位置 （long offsite）。如果驱动程序需要知道文件中的当前位置，可以读取这个值。</li><li>unsigned int f_flags: 文件标志，检查用户请求的是否是非阻塞式操作。</li><li>struct file_operations *f_op 文件相关操作。</li><li>void *pricate_data: open调用前将这个指针置为NULL。驱动可以将这个字段用于任何目的，是跨系统调用时保存状态信息非常有用的资源。</li><li>struct dentry *f_dentry: 文件对应的目录项结构。</li></ul><h4 id="inode结构"><a href="#inode结构" class="headerlink" title="inode结构"></a>inode结构</h4><ul><li>内核用inode结构在内部表示文件，和file结构不同，file表示打开的文件描述符。对单个文件，可能会有许多个表示打开的file结构，但他们都指向单个inode结构。</li><li>inode结构中包含了大量的有关文件信息。常规只有以下两个字段对驱动有用：</li><li>dev_t i_rdev 表示设备文件的inode结构，包含了真正的设备编号</li><li>struct cdev *i_cdev 表示私服设备的内核的内部结构。</li></ul><h3 id="Scull设备的注册"><a href="#Scull设备的注册" class="headerlink" title="Scull设备的注册"></a>Scull设备的注册</h3><p>内核内部使用struct cdev来表示字符设备。在内核调用设备之前，必须分配并注册一个或多个cdev。（定义在<linux cdev.h>）</linux></p><p>分配和初始化cdev的方法：</p><ul><li><p>在运行时获取一个独立的cdev结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">struct cdev *my_cdev = cdev_alloc();</span><br><span class="line">my_cdev-&gt;ops = *my_fops;</span><br></pre></td></tr></table></figure></li><li><p>也可以初始化的时候进行分配</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void cdev_init(struct cdev *cdev, struct file_operations *fops);</span><br></pre></td></tr></table></figure></li></ul><h3 id="定义Scull设备-并初始化Scull设备"><a href="#定义Scull设备-并初始化Scull设备" class="headerlink" title="定义Scull设备, 并初始化Scull设备"></a>定义Scull设备, 并初始化Scull设备</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct scull_dev&#123;</span><br><span class="line">    struct scull_qset *data;</span><br><span class="line">    int quantum;</span><br><span class="line">    int qset;</span><br><span class="line">    unsigned long size;</span><br><span class="line">    unsigned int access_key;</span><br><span class="line">    struct semaphore sem;</span><br><span class="line">    struct cdev cdev; //定义这是一个字符设备结构</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Scull设备初始化<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> scull_major =   SCULL_MAJOR; <span class="comment">//defined in scull.h</span></span><br><span class="line"><span class="keyword">int</span> scull_minor =   <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> scull_nr_devs = SCULL_NR_DEVS;<span class="comment">/* number of bare scull devices */</span></span><br><span class="line"><span class="keyword">int</span> scull_quantum = SCULL_QUANTUM;</span><br><span class="line"><span class="keyword">int</span> scull_qset =    SCULL_QSET;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">scull_dev</span> *<span class="title">scull_devices</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">scull_init_module</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123; <span class="comment">//内核函数，无参数的标准形式都要加上void</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> result, i;</span><br><span class="line">    <span class="keyword">dev_t</span> dev;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1. 定义驱动程序major</span></span><br><span class="line">    <span class="keyword">if</span>(scull_major)&#123;</span><br><span class="line">        dev = MKDEV(scull_major, scull_minor); <span class="comment">//创建dev</span></span><br><span class="line">        result = register_chrdev_region(dev, scull_nr_devs, <span class="string">"scull"</span>); <span class="comment">//注册   </span></span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        result  = alloc_chrdev_region(&amp;dev, scull_minor, scull_nr_devs, <span class="string">"scull"</span>);</span><br><span class="line">        scull_major = MAJOR(dev);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(result&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        printk(KERN_WARNING <span class="string">"scull: can't get major %d\n"</span>, scull_major);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. 建立并分配设备文件（动态分配）</span></span><br><span class="line">    scull_devices = kmalloc(scull_nr_devs * <span class="keyword">sizeof</span>(struct scull_dev), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span>(!scull_devices)&#123;</span><br><span class="line">        result = -ENOMEM; <span class="comment">//内存不足错误</span></span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(scull_devices, <span class="number">0</span>, scull_nr_devs * <span class="keyword">sizeof</span>(struct scull_dev));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3. 初始化每个设备</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;scull_nr_devs; i++)&#123;</span><br><span class="line">        scull_device[i].quantum = scull_quantum;</span><br><span class="line">        scull_device[i].qset = scull_qset;</span><br><span class="line">        <span class="comment">//linux 4.0内核更新, 初始化互斥量</span></span><br><span class="line">        sema_init(&amp;scull_device[i], <span class="number">1</span>);</span><br><span class="line">        scull_setup_cdev(&amp;scull_device[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    dev = MKDEV(scull_major, scull_minor+scull_nr_devs);</span><br><span class="line">    dev += scull_p_init(dev);</span><br><span class="line">    dev += scull_access_init(dev);</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SCULL_DEBUG</span></span><br><span class="line">    scull_create_proc();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">fail:</span><br><span class="line">    scull_cleanup_module();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>定义scull函数接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct file_operations scull_fops = &#123; </span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .llseek = scull_llseek,</span><br><span class="line">    .read   = scull_read,</span><br><span class="line">    .write  = scull_write,</span><br><span class="line">   // .ioctl  = scull_ioctl, 最新内核删掉了这个接口</span><br><span class="line">    .open   = scull_open,</span><br><span class="line">    .release= scull_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="Scull设备操作接口"><a href="#Scull设备操作接口" class="headerlink" title="Scull设备操作接口"></a>Scull设备操作接口</h2><h3 id="open和release"><a href="#open和release" class="headerlink" title="open和release"></a>open和release</h3><h4 id="open方法"><a href="#open方法" class="headerlink" title="open方法"></a>open方法</h4><p>open方法应该完成：</p><ul><li>检查设备特定的错误（如设备未就绪或类似的硬件问题）</li><li>如果设备首次打开，则初始化</li><li>如果有必要，更新f_op指针</li><li>分配并填写置于filp-&gt;private_data里的数据结构</li></ul><p>int (<em>open) (struct inode </em>inode, struct file *filp);<br>经过简化的scull_open代码，没有进行设备初始化工作。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">scull_open</span><span class="params">(struct inode *inode, struct file *filp)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">scull_dev</span> *<span class="title">dev</span>;</span></span><br><span class="line">    dev = container_of(inode-&gt;i_cdev, struct scull_dev, cdev);</span><br><span class="line">    filp-&gt;private_data = dev;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//trim to 0 the length of the device if open was write-only</span></span><br><span class="line">    <span class="keyword">if</span>((filp-&gt;f_flags &amp; O_ACCMODE) == O_WRONLY)&#123;</span><br><span class="line">        scull_trim(dev);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="release方法"><a href="#release方法" class="headerlink" title="release方法"></a>release方法</h4><p>与open方法相反。release完成以下任务：</p><ul><li>释放由open分配的，保存在filp-&gt;private_data中的所有内容</li><li>在最后一个关闭操作时关闭设备。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int scull_release(struct inode *inode, struct file *filp)&#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并不是每个close系统调用都会引起release方法的调用。只有那些真正释放设备数据结构的close调用才会调用这个方法。内核对每个file结构维护其被使用多少次的计数器。无论是fork还是dup，都不会创建新的数据结构（数据结构只能由open创建），它只是增加已有结构的记数。只有在file结构的计数归0的时候，close系统调用才会执行release方法。</p><h3 id="Scull内存使用"><a href="#Scull内存使用" class="headerlink" title="Scull内存使用"></a>Scull内存使用</h3><p>scull驱动程序引入了内存管理的两个核心函数kmalloc和kfree，定义在<linux slab.h>。</linux></p><p>void *kmalloc(size_t size, int flags);</p><ul><li>试图分配 size个自己的大小，返回值为内存指针。flags为描述内存的分配方法。目前始终使用GFP_KERNEL。<br>void kfree(void *ptr);</li></ul><p>在scull中，每个设备都使用一个指针链表，每个指针都只想一个scull_qset结构。如下图：<br>我们把每一个内存区成为一个量子（4000字节），指针数组成为量子集(1000个地址)。</p><p><img src="/images/Linux-simple-Scull驱动/scull内存分配.png" alt="scull内存分配"></p><p>这样scull写入一个字节就会消耗8000或者12000个字节的内存。（每个量子占4000字节，一个量子集占1000*4或1000*8个字节）那么为量子和量子集选择合适的数值就可以配置如何使用该设备。</p><ul><li>在编译时可以修改scull.h中的宏SCULL_QUANTUM和SCULL_QSET。</li><li>在加载模块时，可以设置scull_quantum和scull_qset的整数值。</li><li>或者在运行时，使用ioctl修改当前值或默认值（可能不使用与linux 4.0）</li></ul><h3 id="read和write"><a href="#read和write" class="headerlink" title="read和write"></a>read和write</h3><p>ssize_t read(struct file <em>filp, char __user </em>buff, size_t count, loff_t <em>offp);<br>ssize_t write(struct file </em>filp, const char __user <em>buff, size_t count, loff_t </em>offp);</p><p>count是请求传输的数据长度，buff是指向<strong>用户空间</strong>的缓冲间，最后offp是一个指向长偏移量对象的指针，指明用户在文件中进行存取操作的位置。</p><p>显然，驱动程序必须访问<strong>用户空间</strong>的缓冲区以便完成自己的工作。这个过程由内核专用函数提供 <linux uaccess.h> (在linux4.0版)</linux></p><p>unsigned long copy_to_user(void <strong>user *to, const void* from, unsigned long count);<br>unsigned long copy_from_user(void* to, const void </strong>user *from, unsigned long count);</p><p>这两个函数很像memcpy，但内核访问用户空间时，被寻址的用户空间页面可能并不在内存中，这时候该驱动进程就会转为睡眠状态直到页面加载进内存。带来的结果是访问用户空间的任何函数都必须是可重入的，并且能和其他驱动程序函数并发执行，而且必须处于能够合法休眠的状态。</p><p>read代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> scull_read(struct file *filp, <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *f_ops)&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">scull_dev</span> *<span class="title">dev</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">scull_qset</span> *<span class="title">dptr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> quantum = dev-&gt;quantum, qset = dev-&gt;qset;</span><br><span class="line">    <span class="keyword">int</span> itemsize = quantum * qset;</span><br><span class="line">    <span class="keyword">int</span> item, s_pos, q_pos, rest;</span><br><span class="line">    <span class="keyword">ssize_t</span> retval = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(down_interruptible(&amp;dev-&gt;sem))</span><br><span class="line">        <span class="keyword">return</span> -ERESTARTSYS;</span><br><span class="line">    <span class="keyword">if</span>(*f_pos &gt;= dev-&gt;size)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    <span class="keyword">if</span>(*f_pos + count &gt; dev-&gt;size)</span><br><span class="line">        count = dev-&gt;size - *f_pos;</span><br><span class="line">    <span class="comment">//在量子集中寻找链表项，qset索引以及偏移量</span></span><br><span class="line">    item = (<span class="keyword">long</span>) *f_pos / itemsize; <span class="comment">//在哪一个qset</span></span><br><span class="line">    rest = (<span class="keyword">long</span>) *f_pos % itemsize; <span class="comment">//在当前qset的多少个字节偏移处</span></span><br><span class="line">    s_pos = rest / quantum; q_pos = rest%quantum; <span class="comment">//s_pos找到是哪一个quantum，q_pos找到是当前quantum的哪一个偏移</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//沿该链表前行，直到正确的位置</span></span><br><span class="line">    dptr = scull_follow(dev, item);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(dptr == <span class="literal">NULL</span> || !dptr-&gt;data || !dptr-&gt;data[s_pos])</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(count &gt; quantum - q_pos)</span><br><span class="line">        count = quantum - q_pos;</span><br><span class="line">    <span class="keyword">if</span>(copy_to_user(buf, dptr-&gt;data[s_pos], count))&#123; <span class="comment">//拷贝成功返回0</span></span><br><span class="line">        retval = -EFAULT;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    *f_pos += count;</span><br><span class="line">    retval = count;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">    </span><br><span class="line">out:</span><br><span class="line">    up(&amp;dev-&gt;sem);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>write代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> scull_write(struct file *filp, <span class="keyword">const</span> <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *f_ops)&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">scull_dev</span> *<span class="title">dev</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">scull_qset</span> *<span class="title">dptr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> quantum = dev-&gt;quantum, qset = dev-&gt;qset;</span><br><span class="line">    <span class="keyword">int</span> itemsize = quantum * qset;</span><br><span class="line">    <span class="keyword">int</span> item, s_pos, q_pos, rest;</span><br><span class="line">    <span class="keyword">ssize_t</span> retval = -ENOMEM;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(down_interruptible(&amp;dev-&gt;sem)) <span class="comment">//就是获得信号量</span></span><br><span class="line">        <span class="keyword">return</span> -ERESTARTSYS; <span class="comment">//表示信号函数处理完毕后重新执行信号函数前的某个系统调用, linux上层系统受到这个返回值之后会重新执行这个信号函数的系统调用</span></span><br><span class="line">    </span><br><span class="line">    item = *f_ops / itemsize;</span><br><span class="line">    rest = *f_ops % itemsize;</span><br><span class="line">    s_pos = rest / quantum;</span><br><span class="line">    q_pos = rest % quantum;</span><br><span class="line">    </span><br><span class="line">    dptr = scull_follow(dev, item); <span class="comment">//找到qset</span></span><br><span class="line">    <span class="keyword">if</span>(dptr == <span class="literal">NULL</span>) <span class="keyword">goto</span> out;</span><br><span class="line">    <span class="keyword">if</span>(!dptr-&gt;data)&#123; <span class="comment">//找到的qset为空</span></span><br><span class="line">        dptr-&gt;data = kmalloc(qset * <span class="keyword">sizeof</span>(<span class="keyword">char</span> *), GFP_KERNEL); <span class="comment">//分配qset的数组地址，注意这个data是保存指针的</span></span><br><span class="line">        <span class="keyword">if</span>(!dptr-&gt;data) <span class="keyword">goto</span> out; <span class="comment">//分配失败</span></span><br><span class="line">        <span class="built_in">memset</span>(dptr-&gt;data, <span class="number">0</span>, qset * <span class="keyword">sizeof</span>(<span class="keyword">char</span> *));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!dptr-&gt;data[s_pos])&#123; <span class="comment">//qset当前不是空, quantum是一个新的</span></span><br><span class="line">        dptr-&gt;data[s_pos] = kmalloc(quntum, GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span>(!dptr-&gt;data[s_pos]) <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(count &gt; quantum - q_pos) count = quantum - q_pos;</span><br><span class="line">    <span class="keyword">if</span>(copy_from_user(dptr-&gt;data[s_pos]+q_pos, buf, count))&#123;</span><br><span class="line">        retval = -EFAULT;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    *f_pos += count;</span><br><span class="line">    retval = count;</span><br><span class="line">    <span class="comment">//更新文件大小</span></span><br><span class="line">    <span class="keyword">if</span>(dev-&gt;size &lt; *f_pos) dev-&gt;size = *f_pos;</span><br><span class="line">    </span><br><span class="line">out:</span><br><span class="line">    up(&amp;dev-&gt;sem);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux驱动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git详解</title>
      <link href="/2019/11/29/git%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/11/29/git%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>参考<a href="https://zhuanlan.zhihu.com/p/41344866" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/41344866</a></p><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>在开发的过程中有主干线和分支线，相互之间的代码开发不受影响。<br>一个实际的例子。</p><ul><li>假设某软件的1.0版本完成了，马上投入了1.1版本的开发中</li><li>过了一段时间，1.1版本开发了一部分（基于1.0），但是有用户反馈1.0版本有bug，那么就需要修复1.0版本中的bug，同时重新发布1.0版本</li><li>如果在现行1.1版本上修改，那么更新的版本就会带有1.1的特性</li><li><strong>使用分支</strong>，只需要在1.0发布时的版本建立一个分支，我们在主干线上开发1.1版本，1.0发现bug，在分支上进行修改并发布出去。<strong>并且把修改时候没有bug的代码合并到主干线上</strong>，这样就发布没有bug的1.0，又使得正在开发的1.1版本避免了1.0的bug。</li></ul><p><code>git branch</code>可以查看可以查看分支。在gitbash中显示的<code>master</code>就是我现在所在的分支，这块就是主干线。<br>如果要添加分支，则在<code>git branch</code>之后加上新的分支名就可以添加新的分支。<br><code>git brach -D [分支名]</code> 则是删除了分支。注意删除分支的时候要先退回的master分支。</p><p><code>checkout</code>命令加上分支名，就可以进入指定的分支。分支和主干线是互不影响的，使用merge命令可以进行合并操作。</p><p>例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master <span class="comment">//进入主干线</span></span><br><span class="line">git merge version1<span class="number">.0</span> <span class="comment">//把1.0分支上修改并提交的代码合并到master分支上面</span></span><br></pre></td></tr></table></figure></p><h3 id="与远程版本协作"><a href="#与远程版本协作" class="headerlink" title="与远程版本协作"></a>与远程版本协作</h3><p>git的最大用途就是可以进行团队合作开发，每个人电脑上都有一份代码，团队的某个成员完成自己的一部分任务的时候，就将代码提交到服务器，其他人只需要将服务器上的代码同步到本地，就能保证大家的代码相同，再进行开发就可以了。</p><p><code>git clone</code>：将远程仓库的代码下载到本地，自己进行一些修改和提交（commit）之后，可以使用push命令</p><p><code>git push origin master</code>： origin指远程版本库的Git地址，master执行的是哪一个分支</p><p><code>git fetch origin master</code>：远程版本库上的修改同步到本地用fetch命令。执行之后就把远程版本库的代码同步到本地了，但是不会合并，而是存放在origin/master分支上面，可以用diff查看修改了什么地方<code>git diff origin/master</code>。之后可以用merge命令进行合并。</p><p><code>git pull origin master</code> 则是把fetch和merge两步融合为了一个命令。</p><h3 id="远程仓库与本地仓库实验"><a href="#远程仓库与本地仓库实验" class="headerlink" title="远程仓库与本地仓库实验"></a>远程仓库与本地仓库实验</h3><ul><li>在github中创建新的repository获得Git地址 <code>Git_remote</code></li><li><p>在本地创建git仓库</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir local_dir <span class="comment">//创建路径</span></span><br><span class="line">cd local_dir</span><br><span class="line">git init <span class="comment">//初始化git本地仓库</span></span><br></pre></td></tr></table></figure></li><li><p>将两个仓库进行连接<br>  <code>git remote add Git_remote</code></p></li><li><p>本地创建文件，并提交</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">touch v1code.txt</span><br><span class="line">git add . <span class="comment">//将文件夹中的所有文件加入</span></span><br><span class="line">git commit -m <span class="string">"commit v1code.txt"</span> <span class="comment">//向当前分支提交代码</span></span><br><span class="line">git branch <span class="comment">//查看当前分支(本地)</span></span><br><span class="line">git branch -a <span class="comment">//查看所有分支（远程）</span></span><br></pre></td></tr></table></figure></li><li><p>将本地仓库的代码提交到远程</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push origin master <span class="comment">//将代码推送到远程master</span></span><br><span class="line">git branch -a</span><br></pre></td></tr></table></figure><p>  此时可以发现如下：<br>  <img src="/images/git详解/第一次提交.png" alt="第一次提交"><br>  显示当前远程仓库只有一个分支master。当前处于本地master分支</p></li><li><p>创建分支</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch version1<span class="number">.0</span></span><br><span class="line">git checkout version1<span class="number">.0</span> <span class="comment">//进入version1.0分支</span></span><br></pre></td></tr></table></figure><p>  注意此时version1.0分支包含与master分支相同的文件<br>  将version1.0分支推到远程分支</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push origin version1<span class="number">.0</span></span><br><span class="line">git branch -a</span><br></pre></td></tr></table></figure><p>  <img src="/images/git详解/第二次提交.png" alt="第二次提交"><br>  此时注意我们是把version1.0的版本推送到了origin/version1.0中</p></li><li>在version1.0中进行相应的更改，添加文件test1.txt<br>  查看不同分支<br>  <img src="/images/git详解/version1.0更改.png" alt="第三次提交"><br>  将version1.0推到origin/version1.0中<br>  <img src="/images/git详解/查看远程分支.png" alt="查看远程分支"><br>  此时可以发现github repository上出现了两个分支，可以切换到不同分支进行查看</li><li><p>在本地重新创建一个仓库，clone远程仓库，模拟多人操作。</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法1 clone</span></span><br><span class="line">mkdir git_branch_learn_commiter2</span><br><span class="line">git clone Git_remote ./git_branch_learn_commiter2</span><br><span class="line"><span class="comment">//此时发现只clone了origin/master分支，对应下图</span></span><br><span class="line"><span class="comment">//想要将version1.0拉下来</span></span><br><span class="line">git branch origin/version1<span class="number">.0</span> <span class="comment">//切换到origin/version1.0分支</span></span><br><span class="line">git branch version1<span class="number">.0</span> <span class="comment">//在本地仓库中创建branch，完全复制了version1.0的东西</span></span><br><span class="line"><span class="comment">//注意当你git checkout一个远程仓库的时候，会跳出提示，提醒你处于”detached HEAD“状态，这个时候你可以在这个分支中实验，但并不会被提交更改</span></span><br></pre></td></tr></table></figure><p>  <img src="/images/git详解/commiter2第一次clone.png" alt="commiter2第一次clone"></p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法2 创建本地仓库并连接</span></span><br><span class="line">git remote add Git_remote <span class="comment">//出现报错, 查看报错信息</span></span><br><span class="line">git remote add -f &lt;name&gt; Git_remote <span class="comment">//尝试将&lt;name&gt;设为name之后发现如下图</span></span><br><span class="line"><span class="comment">//所以这个是设置了远程仓库，那么就依照远程仓库进行本地仓库分支更新</span></span><br><span class="line">git checkout name/master</span><br><span class="line">git branch master</span><br><span class="line">git checkout name/version1<span class="number">.0</span></span><br><span class="line">git branch version1<span class="number">.0</span></span><br><span class="line"><span class="comment">//这里同样出现了”detached HEAD“状态</span></span><br><span class="line"><span class="comment">//这时候查看会发现没有出现origin分支</span></span><br></pre></td></tr></table></figure><p>  <img src="/images/git详解/commiter1远程连接.png" alt="commiter1远程连接"></p></li><li><p>commiter1在version1.0上开发之后，与master合并(在version1.0上添加initial_from_c1.txt文件)</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git checkout version1<span class="number">.0</span> <span class="comment">//切换到version1.0分支</span></span><br><span class="line">git merge master version1<span class="number">.0</span> <span class="comment">//这时候发现master出现了initial_from_c1.txt文件，但是没有test1.txt文件。同时提示already updated，说明并没有进行合并操作</span></span><br><span class="line">git checkout master <span class="comment">//切换到master</span></span><br><span class="line">git merge master version1<span class="number">.0</span> <span class="comment">//发现进行了text1.txt的合并</span></span><br><span class="line"><span class="comment">//所以这个时候我们添加的initial_from_c1.txt只是存在于dir中，并没有添加进分支。在此时我们push 远程master</span></span><br><span class="line">git push origin master <span class="comment">//此时我们本地master，push到远程master</span></span><br><span class="line">    </span><br><span class="line">git checkout version1<span class="number">.0</span></span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">"commiter 1 write something"</span></span><br><span class="line">git push origin version1<span class="number">.0</span> <span class="comment">//version1.0更改并推向远程分支</span></span><br></pre></td></tr></table></figure></li><li><p>commiter2进行自己的开发</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此时commiter2的origin与github仓库上的并不同步，可以查看发现在master分支中只有v1code.txt</span></span><br><span class="line"><span class="comment">//我们对当前远程仓库进行一下更新</span></span><br><span class="line">git fetch origin </span><br><span class="line"><span class="comment">//会看到提示说”Your branch is behind origin/master by 1 commit“.就是说本地仓库master和origin/master的当前版本不一致，这个没问题这个就是我们想要的</span></span><br><span class="line">git pull <span class="comment">//将origin/master拉到本地仓库中，其实就是merge origin/master master</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//我们在version1.0分支下添加test_2.txt，并提交</span></span><br><span class="line">git checkout version1<span class="number">.0</span></span><br><span class="line">touch test_2.txt</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">"commiter2 add test_2.txt"</span></span><br><span class="line"><span class="comment">//我们创建version1.2, 并推导远端</span></span><br><span class="line">git branch version1<span class="number">.2</span> <span class="comment">//内容与version1.0完全一样</span></span><br><span class="line">git push origin version1<span class="number">.2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//merge origin/version1.0和version1.0</span></span><br><span class="line"><span class="comment">//这时候你就发现git pull搞不清楚你想要merge哪个分支,提示你git pull &lt;remote&gt; &lt;branch&gt;</span></span><br><span class="line">git pull origin version1<span class="number">.0</span> <span class="comment">//merge的时候会发现要填写一个为什么需要的文档</span></span><br><span class="line"><span class="comment">//现在看version1.0</span></span><br><span class="line"><span class="comment">// -initial_from_c1.txt -test1.txt -test_2.txt -v1code.txt</span></span><br><span class="line"><span class="comment">//而version1.2</span></span><br><span class="line"><span class="comment">// -test1.txt -test_2.txt -v1code.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将1.2和1.0合并</span></span><br><span class="line">git merge version1<span class="number">.0</span> version1<span class="number">.2</span></span><br></pre></td></tr></table></figure></li><li><p>原始创建者将所有的版本汇聚成一个master主分支</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git fetch //将远程分支进行更新</span><br><span class="line">git checkout version1.0</span><br><span class="line">git pull origin version1.2</span><br><span class="line">git checkout master</span><br><span class="line">git merge version1.0 master</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拉格朗日函数转化有约束的求极值问题</title>
      <link href="/2019/11/28/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E5%87%BD%E6%95%B0%E8%BD%AC%E5%8C%96%E6%9C%89%E7%BA%A6%E6%9D%9F%E7%9A%84%E6%B1%82%E6%9E%81%E5%80%BC%E9%97%AE%E9%A2%98/"/>
      <url>/2019/11/28/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E5%87%BD%E6%95%B0%E8%BD%AC%E5%8C%96%E6%9C%89%E7%BA%A6%E6%9D%9F%E7%9A%84%E6%B1%82%E6%9E%81%E5%80%BC%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>参考<a href="https://blog.csdn.net/asd136912/article/details/79149881" target="_blank" rel="noopener">https://blog.csdn.net/asd136912/article/details/79149881</a></p><p>拉格朗日函数常用在支持向量机和最大熵模型中，将有约束的求极值问题转化为无约束求极值问题。可以利用拉格朗日函数的对偶性转化问题。</p><h3 id="原始问题"><a href="#原始问题" class="headerlink" title="原始问题"></a>原始问题</h3><p>最原始的求最小值问题：</p><script type="math/tex; mode=display">\mathop{\min}_{x\in \bf{R}^n} f(x)</script><p>这是求<script type="math/tex">f(x)</script>在最小值时取得的x的值，其中<script type="math/tex">f(x)</script>在<script type="math/tex">R^n</script>上连续可微。这时候我们对<script type="math/tex">f(x)</script>求一阶导，并令导数为0就可以求得极值。</p><p>下面加入约束条件：</p><script type="math/tex; mode=display">\mathop{\min}_{x\in \bf{R}^n} f(x) \\\begin{align}s.t.\ & c_i(x) \leq 0, &i = 1,2,...,k \\    & h_j(x) = 0, &j = 1,2,...,l\end{align}</script><p>其中<script type="math/tex">f(x)</script>, <script type="math/tex">c_i(x)</script>, <script type="math/tex">h_j(x)</script>在<script type="math/tex">R^n</script>上连续可微，我们就称该问题是有约束的最优化问题。</p><h3 id="拉格朗日函数"><a href="#拉格朗日函数" class="headerlink" title="拉格朗日函数"></a>拉格朗日函数</h3><p>为了求解原始问题，引入拉格朗日函数：</p><script type="math/tex; mode=display">L(x, \alpha, \beta) = f(x) + \sum_{i=1}^{k} \alpha_ic_i(x) + \sum_{j=1}^{l} \beta_j h_j(x)</script><p>其中<script type="math/tex">x \in \bf{R}^n</script>, <script type="math/tex">\alpha_i</script>和<script type="math/tex">\beta_j</script>是拉格朗日乘子，且<script type="math/tex">\alpha_i \geq 0</script>。 拉格朗日函数是将原始问题中所有的限定条件加上新引入的变量构成一个新的函数，将限定条件转换为了未知变量。</p><p>我们考虑x的函数：</p><script type="math/tex; mode=display">\theta _P(x) = \mathop{\max}_{\alpha, \beta; \alpha_i \geq 0} L(x, \alpha, \beta)</script><p>下标P代表原始问题。<br>命题证明：如果x满足原始问题中的约束，那么<script type="math/tex">\theta(x)=f(x)</script>；如果x不满足原始问题中的约束，那么<script type="math/tex">\theta(x)=+\infty</script>。即</p><script type="math/tex; mode=display">\theta_P(x) = \begin{cases}f(x), &x满足原始问题约束 \\+\infty, &其他 \\\end{cases}</script><p>证明如下：<br>假设某个x不满足原始问题的约束条件，即存在某个i使得<script type="math/tex">c_i(x)>0</script> 或某个j使得<script type="math/tex">h_j(x)\neq 0</script>,就有：</p><script type="math/tex; mode=display">\theta_P(x) = \mathop{\max}_{\alpha,\beta;\alpha_i\geq0} \left [f(x)+\sum_{i=1}^{k} \alpha_i c_i(x) + \sum_{j=1}^{l} \beta_j h_j(x) \right] = +\infty</script><p>因为某个i使得<script type="math/tex">c_i(x)>0</script>，则可以令<script type="math/tex">\alpha_i \rightarrow +\infty</script>;<br>如果某个j使得<script type="math/tex">h_j(x)\neq 0</script>，就可以令<script type="math/tex">\beta_j</script>与<script type="math/tex">h_j(x)</script>同号且趋近无穷大。</p><p>接下来如果考虑极小化问题，那么就会发现</p><script type="math/tex; mode=display">\mathop{\min}_x \theta_P(x) = \mathop{\min}_x \mathop{\max}_{\alpha,\beta;\alpha_i\geq0} L(x, \alpha, \beta)</script><p>是与原始优化问题等价的，他们具有相同的解。于是把上述公式称为广义拉格朗日函数的<strong>极小极大问题</strong>问题。</p><p><strong>从原始问题开始，通过拉格朗日函数重新定义一个无约束问题，这个无约束问题等价于原来的约束优化问题，从而将约束问题无月书画。也就是将d个变量和k个约束条件的最优化问题编程d+k个变量的优化问题。</strong></p><h3 id="求解对偶问题"><a href="#求解对偶问题" class="headerlink" title="求解对偶问题"></a>求解对偶问题</h3><p>我们定义：</p><script type="math/tex; mode=display">\theta_D(\alpha, \beta) = \mathop{\min}_x L(x, \alpha, \beta)</script><p>并极大化<script type="math/tex">\theta_D(x)</script>,</p><script type="math/tex; mode=display">\theta_D(\alpha, \beta) =  \mathop{\max}_{\alpha,\beta;\alpha_i\geq0} \mathop{\min}_x L(x, \alpha, \beta)</script><p>这定义为拉格朗日函数的极大极小问题。</p><h3 id="原始问题与对偶问题的关系"><a href="#原始问题与对偶问题的关系" class="headerlink" title="原始问题与对偶问题的关系"></a>原始问题与对偶问题的关系</h3><p>如果原始问题和对偶问题都有最优值，那么</p><script type="math/tex; mode=display">d^* = \mathop{\max}_{\alpha,\beta;\alpha_i\geq0} \mathop{\min}_x L(x, \alpha, \beta) \leq \mathop{\min}_x \mathop{\max}_{\alpha,\beta;\alpha_i\geq0} L(x, \alpha, \beta) = p^*</script><p>证明：<br>对任意<script type="math/tex">x,\alpha, \beta</script> 有</p><script type="math/tex; mode=display">\mathop{\min}_x L(x, \alpha, \beta) \leq L(x,\alpha, \beta) \leq \mathop{\max}_{\alpha, \beta;\alpha_i\geq0} L(x, \alpha, \beta)</script><p>由于原始问题和对偶问题都有最优值，所以</p><script type="math/tex; mode=display">\mathop{\min}_x L(x, \alpha, \beta) \leq \mathop{\max}_{\alpha, \beta;\alpha_i\geq0} L(x, \alpha, \beta)</script><p>即<script type="math/tex">d^* \leq p^*</script></p><p>也就是说原始问题的最优值不小于对偶问题的最优值。但我们要通过对偶问题来求解原始问题的最优值就必须使得原始问题的最优值与对偶问题最优值相等。那什么条件下才有<script type="math/tex">d^* = p^*</script>?</p><p>from<a href="http://matafight.github.io/2015/05/13/KKT%E6%9D%A1%E4%BB%B6%E4%B8%8E%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E5%AF%B9%E5%81%B6%E6%80%A7/" target="_blank" rel="noopener">http://matafight.github.io/2015/05/13/KKT%E6%9D%A1%E4%BB%B6%E4%B8%8E%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E5%AF%B9%E5%81%B6%E6%80%A7/</a></p><ul><li><script type="math/tex">d^* \leq p^*</script>是week duality，对所有的优化问题都成立，其中<script type="math/tex">d^* - p^*</script> 称为duality gap。需要注意的是无论原始问题是什么形式，其对偶问题都是一个凸优化问题（它的极值是唯一的如果存在的话）。这样对于一些难解的原始问题，我们就可以求解其对偶问题得到原始问题的一个下届估计。</li><li><script type="math/tex">d^*=p^*</script>就是一个strong duality。当strong duality成立时，就可以通过对偶问题dual problem求解原始问题prime problem：<ul><li><strong>必要条件</strong>，任何满足strong duality的问题都满足KKT条件</li><li>当原问题是凸优化问题，且满足slater条件，KKT条件就是充要条件。Slater条件：存在一点，使得不等式关系<script type="math/tex">c_i(x)<0</script>严格满足，且等式关系<script type="math/tex">h_i(x)=0</script>严格满足。这时可以证明原问题是凸的。</li></ul></li></ul><h3 id="KKT条件"><a href="#KKT条件" class="headerlink" title="KKT条件"></a>KKT条件</h3><p><strong>对于一般的优化条件，不管其是不是凸的，其对偶问题一定是凸优化问题，此时对偶问题是原始问题的一个下届，当满足强对偶的时候，一定满足KKT条件。</strong><br><strong>当原始问题是凸的，且满足Slater条件，KKT条件是强对偶的充要条件。</strong></p><p>对原始问题和对偶问题，假设函数<script type="math/tex">f(x)</script>和<script type="math/tex">c_i(x)</script>是凸函数，<script type="math/tex">h_j(x)</script>是仿射函数，并且不等式约束<script type="math/tex">c_i(x)</script>是严格可行的，那么原始问题的解<script type="math/tex">x^*,\alpha^*,\beta^*</script>就是对偶问题的解冲要条件是满足KKT条件：</p><script type="math/tex; mode=display">\nabla_x L(x^*, \alpha^*, \beta^*) = 0 \\\nabla_\alpha L(x^*, \alpha^*, \beta^*) = 0 \\\nabla_\beta L(x^*, \alpha^*, \beta^*) = 0 \\\alpha_i^*c_i(x^*) = 0, i=1,2,3...k\\c_i(x^*) \leq 0 i = 1,2,3,...k\\\alpha_i^* \geq 0 i = 1,2,3...k\\h_i(x^*) = 0, j=1,2,3...l\\</script><p>关于KKT条件的理解:前边三个条件是对于各个变量的偏导数为0，后边四个条件是原始问题的约束条件以及拉格朗日乘子需要满足的约束。</p><p>关于KKT条件<a href="https://zhuanlan.zhihu.com/p/38163970" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/38163970</a> 在非线性优化方面的解释。<br>等式约束<a href="https://blog.csdn.net/touristman5/article/details/57418552" target="_blank" rel="noopener">https://blog.csdn.net/touristman5/article/details/57418552</a></p><p><strong>KKT条件给出了判断x是否为最优解的条件。</strong><br>对于一般优化问题</p><script type="math/tex; mode=display">\mathop{\min}_x f(x) \\s.t. g_i(x) \leq 0 (i = 1,2,...,m) \\h_k(x) = 0 (k = 1,2,3...l) \\</script><p>$x^*$是最优解的必要条件是：</p><script type="math/tex; mode=display">\begin{cases}\nabla_{x_i} f(x_i) = 0, (i = 1,2,3,...,n) \\h_k(x) = 0 \\\lambda_j g_j(x) = 0\\\lambda_j \geq 0\end{cases}</script>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 SVM相关 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>I2C总线总结</title>
      <link href="/2019/11/27/I2C%E6%80%BB%E7%BA%BF%E6%80%BB%E7%BB%93/"/>
      <url>/2019/11/27/I2C%E6%80%BB%E7%BA%BF%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<ul><li>I2C是由双向串行时钟线SCL和双向串行数据线SDA两条数据线组成。</li><li>I2C总线在传输数据是速率可达100kbps，最高可达400kbps。</li><li>I2C总线上允许接入的设备数量主要决定于总线上的电容量，一般设定为400pF以下。</li><li>总线上传输数据一般由主机发送启动信号和时钟信号，开始传输。一般向主机发出一个地址（7bit），一个读写位（1bit）和一个ACK（1bit）。</li><li>在I2C上，从机都会装有被控器，被控器每接收一个byte都要在数据线上给主控机发送一个ACK表示完成一个控制功能。在多重主控中存在仲裁过程。仲裁指多个主控器试图同时控制总线，I2C总线只允许其中一个主控器继续占用总线，并保证在整个过程中总线上的数据不会丢失或出错。</li><li>I2C总线上的时钟信号是主控器产生，每个主控器在占用总线传送数据期间都有自己的时钟。SDA数据传输在SCL处于高电平是有效。各主控器向总线上输出不同的时钟频率时，只有通过仲裁过程，才能使总线上有一个统一的时钟信号。</li><li>I2C总线控制中，时钟线将由时钟低电平周期最长的主控器保持为低电平状态，而其他时钟低电平周期较短的主控器将进入时钟高电平等待状态。时钟线高电平周期由时钟信号高电平周期最短的主控器决定。</li><li>ACK是在传输8位后，接收机在第9个SCL内将SDA拉低。以下三种情况没有ACK信号：（1）当从机不能响应从机地址时，这时，主机发出一个P信号终止传输或者重新发出一个S信号开始新的传输。（2）如果从机接收器在传输过程中不能接收更多的数据时，它不会发出ACK信号。（3）主机接收器在接收到最后一个字节后，也不会发出ACK信号。于是，从机发送器释放SDA线，以允许主机发出P信号结束传输。</li></ul><p>I2C时序：</p><p><img src="/images/I2C总线总结/I2C时序.png" alt="I2C时序"></p><p>需要注意的是：<br>1，SCL一直由Master控制，SDA依照数据传送的方向，读数据时由Slave控制SDA，写数据时由Master控制SDA。当8位数据传送完毕之后，应答位或者否应答位的SDA控制权与数据位传送时相反。<br>2，开始位“Start”和停止位“Stop”，只能由Master来发出。<br>3，地址的8位传送完毕后，成功配置地址的Slave设备必须发送“ACK”。否则否则一定时间之后Master视为超时，将放弃数据传送，发送“Stop”。<br>4，当写数据的时候，Master每发送完8个数据位，Slave设备如果还有空间接受下一个字节应该回答“ACK”，Slave设备如果没有空间接受更多的字节应该回答“NACK”，Master当收到“NACK”或者一定时间之后没收到任何数据将视为超时，此时Master放弃数据传送，发送“Stop”。<br>5，当读数据的时候，Slave设备每发送完8个数据位，如果Master希望继续读下一个字节，Master应该回答“ACK”以提示Slave准备下一个数据，如果Master不希望读取更多字节，Master应该回答“NACK”以提示Slave设备准备接收Stop信号。<br>6，当Master速度过快Slave端来不及处理时，Slave设备可以拉低SCL不放（SCL=0将发生“线与”）以阻止Master发送更多的数据。此时Master将视情况减慢或结束数据传送。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总线接口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 驱动-第一个Helloworld</title>
      <link href="/2019/11/20/Linux-%E9%A9%B1%E5%8A%A8-%E7%AC%AC%E4%B8%80%E4%B8%AAhelloworld/"/>
      <url>/2019/11/20/Linux-%E9%A9%B1%E5%8A%A8-%E7%AC%AC%E4%B8%80%E4%B8%AAhelloworld/</url>
      
        <content type="html"><![CDATA[<p>参考书籍《Linux设备驱动程序》</p><h3 id="检查Linux内核"><a href="#检查Linux内核" class="headerlink" title="检查Linux内核"></a>检查Linux内核</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检查Linux内核版本</span></span><br><span class="line">uname -r</span><br><span class="line"><span class="comment">//检查lsb(linux standard base)显示和lsb特定版本的相关信息，会显示ubuntu</span></span><br><span class="line">lsb_release -a</span><br><span class="line"><span class="comment">//查看相关Linux version</span></span><br><span class="line">cat /proc/version</span><br></pre></td></tr></table></figure><h3 id="创建第一个helloworld内核模块"><a href="#创建第一个helloworld内核模块" class="headerlink" title="创建第一个helloworld内核模块"></a>创建第一个helloworld内核模块</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line">MODULE_LICENSE(<span class="string">"Dual BSD/GPL"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hello_init</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    printk(KERN_ALERT <span class="string">"Hello, World\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello_exit</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123; <span class="comment">//注意无参数内核函数参数列表要放void，否则会出现warning并报错</span></span><br><span class="line">    printk(KERN_ALERT <span class="string">"Goodbye, cruel world\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br></pre></td></tr></table></figure><p>内核的特殊宏：<br>MODULE_LICENSE，告诉内核，该模块的使用采用自由许可证，如果没有该声明，内核在生成module的时候会产生warning。</p><h3 id="安装Linux内核库"><a href="#安装Linux内核库" class="headerlink" title="安装Linux内核库"></a>安装Linux内核库</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//install linux header in ubuntu</span></span><br><span class="line">sudo apt-get install linux-headers-$(uname -r)</span><br><span class="line"><span class="comment">//install linux kernal source in ubuntu</span></span><br><span class="line">sudo apt-get install linux-source</span><br></pre></td></tr></table></figure><h3 id="使用Makefile进行编译"><a href="#使用Makefile进行编译" class="headerlink" title="使用Makefile进行编译"></a>使用Makefile进行编译</h3><p>使用make命令，会在当前路径下查找<code>Makefile</code>文件名的编译文件。<br>注意命名，一定要是Makefile不能使makefile。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#Makefile</span><br><span class="line">obj-m += helloworld.o</span><br><span class="line">KDIR=/usr/src/linux-headers-$(shell uname -r)</span><br><span class="line">all:</span><br><span class="line">    $(MAKE) -C $(KDIR) SUBDIRS=$(pwd) modules</span><br><span class="line">clean:</span><br><span class="line">    rm -rf *.o *.ko *.mod.* *.sysvers *.order</span><br></pre></td></tr></table></figure></p><h3 id="利用make进行编译"><a href="#利用make进行编译" class="headerlink" title="利用make进行编译"></a>利用make进行编译</h3><p><img src="/images/Linux-驱动-第一个helloworld/make result.png" alt="make result"></p><h3 id="安装module"><a href="#安装module" class="headerlink" title="安装module"></a>安装module</h3><p><code>dmesg</code>显示开机信息。显示系统运行时硬件的检测或者断开连接信息。当计算机启动时，系统内核（操作系统的核心部分）将会被加载到内存中。在加载的过程中会显示很多的信息，在这些信息中我们可以看到内核检测硬件设备。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo insmod helloworld.ko</span><br><span class="line">dmesg</span><br><span class="line">sudo rmmod helloworld.ko</span><br><span class="line">dmesg</span><br></pre></td></tr></table></figure><p><img src="/images/Linux-驱动-第一个helloworld/insmod.png" alt="insmod"></p><h3 id="Linux内核模块相关命令"><a href="#Linux内核模块相关命令" class="headerlink" title="Linux内核模块相关命令"></a>Linux内核模块相关命令</h3><ul><li>lsmod 列出内核已加载模块。列出/proc/modules的内容</li><li>depmod 分析可加载模块的依赖性，生成modules.dep文件和映射文件</li><li>modprobe Linux内核添加删除模块</li><li>modinfo 显示内核模块信息</li><li>insmod 向内核中插入模块</li><li>rmmode 从内核中删除模块</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-虚拟内存</title>
      <link href="/2019/11/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
      <url>/2019/11/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h3 id="Linux-虚拟地址空间"><a href="#Linux-虚拟地址空间" class="headerlink" title="Linux 虚拟地址空间"></a>Linux 虚拟地址空间</h3><p>为了防止不同进程在物理内存中运行二队物理内存的争夺，采用了虚拟内存。</p><p>虚拟内存使得不同进程在运行的过程中，它看到的是自己独自占有了当前系统的4G内存。所有进程共享同一物理内存，每个进程只是把自己目前需要的虚拟内存空间映射并存储到物理内存上。在每个进程创建加载时，内核只是为进程“创建“了虚拟内存的布局，具体就是初始化进程控制表中内存相关的链表。实际上并不立即就把虚拟内存对应位置的程序数据和代码拷贝到物理内存中，只是建立好了虚拟内存和磁盘文件之间的映射。<strong>等到运行到对应的程序段或访问相应的数据段，才会通过缺页异常来拷贝数据</strong>。在进程运行过程中，要动态分配内存，比如malloc时，也只是分配了虚拟内存，即为这块虚拟内存对应的页表项做相应的设置，当进程真正访问到此数据时，才会引发缺页异常。</p><p>请求分页系统、请求分段系统和请求段页式系统都是针对虚拟内存的，通过请求实现内存与外存的信息置换。</p><p>虚拟内存的好处：</p><ol><li>扩大地址空间；</li><li>内存保护：每个进程运行在各自的虚拟内存地址空间，互相不干扰。虚拟内存还对特定的内存地址提供写保护，可以防止代码或数据被恶意篡改。</li><li>公平内存分配。采用了虚存之后，每个进程都相当于有相同大小的虚存空间。</li><li>当进程通信时，可采用虚存共享的方式实现。</li><li>当不同的进程使用相同的代码时，比如库文件中的代码，物理内存中可以只存储一份代码，不同的进程只需要把自己的虚拟内存映射过去就可以了，节省内存</li><li>虚拟内存很适合在多道程序设计系统中使用，许多程序的片段同时保存在内存中。当一个程序等待它的一部分读入内存时，可以把CPU交给另一个进程使用。可以提供系统并发度</li><li>当程序需要分配连续内存空间的时候，只需要在虚拟内存空间分配连续空间，而不需要实际物理内存的连续空间，可以利用碎片</li></ol><p>虚拟内存的代价：</p><ol><li>虚存的管理需要建立很多数据结构，这些数据结构要占用额外的内存</li><li>虚拟地址到物理地址的转换，增加了指令执行的时间</li><li>页面换入换出需要磁盘IO，比较耗时</li><li>如果一页中只有一部分数据，会浪费内存</li></ol><h3 id="Linux-页表寻址"><a href="#Linux-页表寻址" class="headerlink" title="Linux 页表寻址"></a>Linux 页表寻址</h3><ul><li>页式内存管理，内存分成固定长度的一个个页片。操作系统为每一个进程维护了一个从虚拟地址到物理地址的映射关系的数据结构，叫页表，页表的内容就是该进程的虚拟地址到物理地址的一个映射。页表中的每一项都记录了这个页的基地址。通过页表，由逻辑地址的高位部分先找到逻辑地址对应的页基地址，再由页基地址偏移一定长度就得到最后的物理地址，偏移的长度由逻辑地址的低位部分决定。一般情况下，这个过程都可以由硬件完成，所以效率还是比较高的。页式内存管理的优点就是比较灵活，内存管理以较小的页为单位，方便内存换入换出和扩充地址空间。</li></ul><h3 id="程序内存管理"><a href="#程序内存管理" class="headerlink" title="程序内存管理"></a>程序内存管理</h3><ol><li><p>一个程序本质上都是由text段，data段，BSS段三个段组成。一个可执行程序在存储时（没有调入内存）分为代码段，数据段和未初始化数据区。<br> 调入内存后：<br> <img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552470750551_BF3BB3BB445EFF96BEAE1410CE2CDA74" alt="程序的内存分布"></p></li><li><p>BSS段：未初始化数据区。通常用来存放程序中<strong>未初始化</strong>的<strong>全局变量</strong>和<strong>静态变量</strong>的一块内存区域。属于<em>静态分配</em>，程序结束后静态变量资源由系统自动释放。</p></li><li>数据段：存放程序中<strong>已经初始化</strong>的的<strong>全局变量</strong>。也属于<em>静态分配</em></li><li>代码段：存放程序执行代码的一块内存。这部分区域的大小在程序运行前就已经确定，并且在内存区域属于只读。在代码段中，也可能包含一些只读的常数变量</li><li>代码段和数据段在编译时已经分配了空间，<strong>而BSS段不占用可执行文件的大小</strong>，它是由链接器来获取内存的。BSS段的内容并不存放在磁盘上的程序文件中。其原因是内核在程序开始运行前将他们设置为0。</li><li>可执行程序在运行时又多处两个区域：栈区和堆区。</li></ol><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A *a = new A();</span><br><span class="line">a-&gt;i = 10;</span><br><span class="line">内存做了什么？</span><br></pre></td></tr></table></figure><p>（1）A <em>a ：a是一个局部指针，在栈区分配内存（4或8字节空间）设地址为0x000m。<br>（2）new A ：通过new在堆区申请类A大小的空间（0x000n为首地址）<br>（3）a = new A ：将指针a的内存区域填入堆区申请到的地址。即 </em>(0x000m) = 0x000n<br>（4）a-&gt;i ：先找到指针a的地址，通过a的地址和i在类A中的偏移得到a-&gt;i地址，对该地址进行赋值操作。</p><p>例子：<br><em>给一个类，里边有static，virtual，说明一下这个类的内存分布</em><br>(1) static修饰成员变量。对于静态成员变量，对每个类对象都是一样的（其值可以更新）。static变量在data段分配内存，属于本类的所有对象共享，不属于特定的类对象，在没有产生类对象前就可以使用。<br>注意：<strong>static非const变量只能在类内定义，在类外初始化！</strong>如果在类内初始化，会导致每个类都包含该静态成员，这是矛盾的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;  </span><br><span class="line">private:</span><br><span class="line">    static int count ; // 类内声明</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">int A::count = 0 ; // 类外初始化，不必再加static关键字</span><br></pre></td></tr></table></figure><p>能够在类内初始化的成员只有static const变量。<br>(2) <strong>const成员。只能在构造函数后的初始化列表中初始化！</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using std::cout;</span><br><span class="line">using std::endl;</span><br><span class="line">class base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    base(int x=8):a(x)&#123;&#125;;//const成员在构造函数初始化</span><br><span class="line">    const int a;</span><br><span class="line">    static int b;</span><br><span class="line">    const static int c=9;//const static成员在类内初始化</span><br><span class="line">&#125;;</span><br><span class="line">int base::b=9;//static成员在类外初始化，可以修改</span><br><span class="line">//const int base::c=10;//也可以像static在类外初始化</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    base obj;</span><br><span class="line">    cout&lt;&lt;obj.a&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;base::b&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;base::c&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(3) static修饰成员函数。静态成员函数不与任何对象相联系，因此不具有this指针。它无法访问属于类对象的非静态数据成员（因为没有this指针，只能访问所有类都一样的成员），也无法访问非静态成员函数，只能调用静态成员函数。<strong>static修饰的成员函数，在代码区分配内存</strong>。<br>(4) C++继承与虚函数。<br>C++多态分为静态多态和动态多态。静态多态是通过重载和函数模板来实现的，<strong>在编译的时候确定</strong>。动态多态通过虚函数和继承关系来实现，执行动态绑定，<strong>在运行时候确定</strong>，也叫动态联编。<br>    动态多态实现的条件：<br>    a.虚函数<br>    b.一个基类的指针或引用指向派生类的对象<br>    基类指针在调用虚成员函数的时候，会去查找该对象的虚函数表。在类继承的时候，虚函数表直接从基类继承过来，如果覆盖了其中某个虚函数，那么虚函数的指针就会被替换，因此可以根据指针准确找到调用的函数。</p><p>如果一个类是局部变量，则该类存储在栈区。<br>如果一个类是new、malloc动态申请的，存储在堆区。<br>如果一个类是virtual继承来的子类，则该类的虚函数表指针和该类其他成员一起存储。虚函数表指针指向<strong>只读数据段中的类虚函数表</strong>，虚函数表中存放着一个个函数指针，函数指针指向代码段中的具体函数。<em>如果类中成员是vitual属性，则会隐藏父类对应的属性</em>。<br><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552470920741_7D40CEF3951A10F626301148E06D89DA" alt="虚函数继承"></p><h4 id="静态变量什么时候初始化"><a href="#静态变量什么时候初始化" class="headerlink" title="静态变量什么时候初始化"></a>静态变量什么时候初始化</h4><p>static变量存储在静态数据段和bss段。<br>C语言是在代码执行之前进行初始化，属于编译器初始化。保存在可执行文件的数据段中。<br>C++引入了对象，对象的生成必须调用构造函数，因此C++规定全局或局部静态对象当且仅当对象首次用到时进行构造。</p><h3 id="union联合体的使用"><a href="#union联合体的使用" class="headerlink" title="union联合体的使用"></a>union联合体的使用</h3><p>参考<a href="https://blog.csdn.net/huqinweI987/article/details/23597091" target="_blank" rel="noopener">https://blog.csdn.net/huqinweI987/article/details/23597091</a></p><p>union的基本特性：定义union下边的成员变量共享一块内存，每一个成员在任一时刻有且只有一个成员使用此块内存。C语言只管分配一段空间，至于里边放什么内容并不会管。</p><p>union的内存分配是按照union成员变量占地最大的那个变量分的。</p><p>判断linux大小端：大端指低字节存储在高地址，小端指低字节存储在低地址。联合体变量总是从低地址存储。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">union var&#123;</span><br><span class="line">        char c[4];</span><br><span class="line">        int i;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">int main()&#123;</span><br><span class="line">        union var data;</span><br><span class="line">        data.c[0] = 0x04;//因为是char类型，数字不要太大，算算ascii的范围~</span><br><span class="line">        data.c[1] = 0x03;//写成16进制为了方便直接打印内存中的值对比</span><br><span class="line">        data.c[2] = 0x02;</span><br><span class="line">        data.c[3] = 0x11;</span><br><span class="line">//数组中下标低的，地址也低，按地址从低到高，内存内容依次为：04,03,02,11。总共四字节！</span><br><span class="line">//而把四个字节作为一个整体（不分类型，直接打印十六进制），应该从内存高地址到低地址看，0x11020304，低位04放在低地址上。</span><br><span class="line">        printf(&quot;%x\n&quot;,data.i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「秦伟H」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https://blog.csdn.net/huqinweI987/article/details/23597091</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pthread使用</title>
      <link href="/2019/11/07/pthread%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/11/07/pthread%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="POSIX线程"><a href="#POSIX线程" class="headerlink" title="POSIX线程"></a>POSIX线程</h3><p>简称Pthreads，是线程POSIX标准。该标准定义了创建和操作线程的一整套API。在类UNIX操作系统中，都使用Pthreads作为操作系统的线程。</p><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>Pthreads的API函数可以非正式的划分为三大类：</p><ul><li>线程管理（Thread Management）：直接用于线程创建，分离，连接等。包含了用于设置和查询线程属性（可连接，调度属性等）</li><li>互斥量（mutex）：用于线程同步，称为互斥量。Mutex函数提供了创建，销毁，锁定和解锁互斥量的功能，同时还包括了一些用于设定或修改互斥量属性的函数</li><li>条件变量（condition variables）：处理共享一个互斥量的线程间通信，<strong>基于程序员指定的条件</strong>。这类函数包含执行的条件变量的创建，销毁，等待和受信（signal）</li><li>命名约定：线程库中所有标识符否已pthread开头</li></ul><div class="table-container"><table><thead><tr><th>Routine Prefix</th><th>Functional Group</th></tr></thead><tbody><tr><td>pthread_</td><td>线程本身和各种相关函数</td></tr><tr><td>pthread<em>attr</em></td><td>线程属性对象</td></tr><tr><td>pthread<em>mutex</em></td><td>互斥量</td></tr><tr><td>pthread<em>mutexattr</em></td><td>互斥量属性对象</td></tr><tr><td>pthread<em>cond</em></td><td>条件变量</td></tr><tr><td>pthread<em>condattr</em></td><td>条件变量属性对象</td></tr><tr><td>pthread<em>key</em></td><td>线程数据键（Thread-specific data keys）</td></tr></tbody></table></div><h3 id="创建、终止线程"><a href="#创建、终止线程" class="headerlink" title="创建、终止线程"></a>创建、终止线程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">xc</span><span class="params">(<span class="keyword">void</span>* arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* c = (<span class="keyword">char</span>*) arg;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"参数%s \n"</span>, c);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"循环%d \n"</span>, i);</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">5</span>)&#123;</span><br><span class="line">            pthread_exit(<span class="number">1090000000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100000222</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid; <span class="comment">//分配线程号</span></span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, xc, <span class="string">"线程"</span>);</span><br><span class="line">    <span class="comment">// 参数列表：线程标识符，设置线程属性，线程运行函数的起始地址，线程运行函数的参数。</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> *status;</span><br><span class="line">    pthread_join(tid, &amp;status); <span class="comment">//用来等待一个线程的结束。</span></span><br><span class="line">    <span class="comment">//参数列表：被等待的线程标识符，用户定义的指针来存储线程的返回值。pthread_join是一个线程阻塞函数，调用他的函数将一直等待到tid线程结束为止。当函数返回时，tid线程的资源被收回。如果成功返回0，失败则返回错误号。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"返回%d\n"</span>, (<span class="keyword">int</span>)status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex; <span class="comment">//互斥锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thr_fun</span><span class="params">(<span class="keyword">void</span>* arg)</span></span>&#123;</span><br><span class="line">    <span class="comment">//对1进行操作，出现临界区</span></span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span>* no = (<span class="keyword">char</span>*) arg;</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s thread, i:%d\n"</span>, no, i);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//解锁</span></span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid1, tid2;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化互斥锁</span></span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    pthread_create(&amp;tid1, <span class="literal">NULL</span>, thr_fun, <span class="string">"NO1"</span>);</span><br><span class="line">    pthread_create(&amp;tid2, <span class="literal">NULL</span>, thr_fun, <span class="string">"NO2"</span>);</span><br><span class="line">    </span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//拆锁</span></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生产者消费者线程"><a href="#生产者消费者线程" class="headerlink" title="生产者消费者线程"></a>生产者消费者线程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者数量</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONSUMER_NUM 2</span></span><br><span class="line"><span class="comment">//生产者数量</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRODUCER_NUM 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_t</span> pids[CONSUMER_NUM + PRODUCER_NUM];</span><br><span class="line"></span><br><span class="line"><span class="comment">//互斥锁</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="comment">//同步锁</span></span><br><span class="line"><span class="keyword">pthread_cond_t</span> has_product;</span><br><span class="line"></span><br><span class="line"><span class="comment">//产品队列</span></span><br><span class="line"><span class="keyword">int</span> ready = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">producer</span><span class="params">(<span class="keyword">void</span>* arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> no = (<span class="keyword">int</span>) arg;</span><br><span class="line">    <span class="comment">//条件变量</span></span><br><span class="line">    <span class="keyword">while</span>&#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        </span><br><span class="line">        ready++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"producer %d, produce product \n"</span>, no);</span><br><span class="line">        <span class="comment">//通知消费者有产品可以消费，唤醒监听has_product的线程</span></span><br><span class="line">        <span class="comment">//会阻塞输出</span></span><br><span class="line">        pthread_cond_signal(&amp;has_product);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"producer %d, signal\n"</span>, no);</span><br><span class="line">        </span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">consumer</span><span class="params">(<span class="keyword">void</span>* arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = (<span class="keyword">int</span>) arg;</span><br><span class="line">    <span class="keyword">while</span>&#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(ready == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//没有产品，继续等待</span></span><br><span class="line">            <span class="comment">//1. 阻塞等待has_product被唤醒</span></span><br><span class="line">            <span class="comment">//2. 释放互斥锁，pthread_mutex_unlock</span></span><br><span class="line">            <span class="comment">//3. 被唤醒时，接触阻塞，重新申请获得互斥锁</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d consumer wait\n"</span>, num);</span><br><span class="line">            pthread_cond_wait(&amp;has_product, &amp;mutex);</span><br><span class="line">            <span class="comment">//pthread_cond_wait做的第一件事情就是对互斥对象解锁，阻塞当前线程等待cond发生</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//有产品，消费产品</span></span><br><span class="line">        ready--;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d consume product\n"</span>, num);</span><br><span class="line">        </span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化互斥锁和条件变量</span></span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_cond_init(&amp;has_product, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"init\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;PRODUCER_NUM; i++)&#123;</span><br><span class="line">        print(<span class="string">"%d\n"</span>);</span><br><span class="line">        pthread_create(&amp;pid[i], <span class="literal">NULL</span>, producer, (<span class="keyword">void</span>*)i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;CONSUMER_NUM; i++)&#123;</span><br><span class="line">        pthread_create(&amp;pids[PRODUCER_NUM+i], <span class="literal">NULL</span>, consumer, (<span class="keyword">void</span>*)i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//等待</span></span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;PRODUCER_NUM+CONSUMER_NUM; i++)&#123;</span><br><span class="line">        pthread_join(pids[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//拆毁互斥锁和条件变量</span></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    pthread_cond_destroy(&amp;has_product);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="pthread-join和pthread-detach"><a href="#pthread-join和pthread-detach" class="headerlink" title="pthread_join和pthread_detach"></a>pthread_join和pthread_detach</h3><p><a href="https://blog.csdn.net/weibo1230123/article/details/81410241" target="_blank" rel="noopener">https://blog.csdn.net/weibo1230123/article/details/81410241</a></p><ol><li>linux线程执行和windows不同，pthread有两种状态<strong>joinable状态</strong>和<strong>unjoinable状态</strong>，如果线程是joinable状态，当线程函数自己返回退出时或pthread_exit时都不会释放线程所占用堆栈和线程描述符（总计8K多）。只有当你调用了pthread_join之后这些资源才会被释放。若是unjoinable状态的线程，这些资源在线程函数退出时或pthread_exit时自动会被释放。</li><li>unjoinable属性可以在pthread_create时指定，或在线程创建后在线程中pthread_detach自己, 如：pthread_detach(pthread_self())，将状态改为unjoinable状态，确保资源的释放。或者将线程置为 joinable,然后适时调用pthread_join.</li><li>简单的说就是在线程函数头加上 pthread_detach(pthread_self())的话，线程状态改变，在函数尾部直接 pthread_exit线程就会自动退出。省去了给线程擦屁股的麻烦。</li></ol><h4 id="pthread-join"><a href="#pthread-join" class="headerlink" title="pthread_join"></a>pthread_join</h4><p><strong>将子线程合并进入主线程</strong>，主线程阻塞等待子线程结束，然后收回子线程资源。pthread_join()函数，以阻塞的方式等待thread指定的线程结束。当函数（pthread_create中指定的线程func）返回时，被等待线程的资源被收回。如果线程已经结束，那么该函数会立即返回。并且thread指定的线程必须是joinable的。</p><h4 id="pthread-detach"><a href="#pthread-detach" class="headerlink" title="pthread_detach"></a>pthread_detach</h4><p><strong>将子线程与主线程分离</strong>，子线程结束后，资源自动回收。<br>pthread_join()函数的替代函数，可回收创建时detachstate属性设置为PTHREAD_CREATE_JOINABLE的线程的存储空间。<strong>该函数不会阻塞父线程。</strong><br>通常是主线程使用pthread_create()创建子线程以后，一般可以调用pthread_detach(threadid)分离刚刚创建的子线程。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unix线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QT嵌入式开发Qthread</title>
      <link href="/2019/11/07/QT%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91Qthread/"/>
      <url>/2019/11/07/QT%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91Qthread/</url>
      
        <content type="html"><![CDATA[<h3 id="QThread的两种使用方法"><a href="#QThread的两种使用方法" class="headerlink" title="QThread的两种使用方法"></a>QThread的两种使用方法</h3><ol><li><p>不使用事件循环。官方manual介绍的一种方法<br>1） 子类化QThread<br>2） 重载run函数，run函数内有一个死循环<br>3） 设置一个标记位来控制死循环的退出<br>如果使用这个方法，那么QThread::quit()就没有效果，因为这个线程不需要事件循环。这个时候使用QT不推荐的terminate()</p></li><li><p>使用事件循环<br>1） 子类化QThread<br>2） 重载run使其调用QThread::exec()<br>3） 并为该类定义信号和槽，这样一来，由于slot函数并不会在新开的thread运行，很多人为了解决这个问题在构造函数中调用moveToThread(this)</p></li></ol><p>QThread应该被看做是操作系统线程的接口或控制点，而不应该包含需要在新线程中运行的代码。需要运行的代码应该放到一个QObject子类中，然后将该子类的对象moveToThread到新线程中。</p><h3 id="QThread分析"><a href="#QThread分析" class="headerlink" title="QThread分析"></a>QThread分析</h3><p>QThread代表一个线程，我们可以重新实现QThread::run()。要新建一个线程，我们应该先继承QThread并重新实现run()函数。</p><p>注意：</p><ol><li>必须在创建QThread对象之前创建QApplication(继承自QCoreApplication和QGuiApplication)</li><li>QCoreApplication::exec()必须只能从主线程调用，不能从QThread线程调用。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> :</span> <span class="keyword">public</span> QThread &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyThread(QObject * parent = <span class="literal">NULL</span>);</span><br><span class="line">    ~MyThread();</span><br><span class="line">    </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MyThread::run()&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> <span class="built_in">cout</span> = <span class="number">0</span>; count &lt; <span class="number">20</span>; count++)&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    qDebug(<span class="string">"finish!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以在这样调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyThread thread;</span><br><span class="line">thread.start();</span><br><span class="line">thread.wait(); //必须要加，主线程要等到MyThread线程结束才能结束</span><br></pre></td></tr></table></figure></p><p>当然我们开的线程可能要运行很久，会卡住主线程，可以使用QeventLoop进行轮转。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MyThread thread;</span><br><span class="line">thread.start();</span><br><span class="line">QeventLoop;</span><br><span class="line">connect(&amp;thread, SIGNAL(finished()), &amp;event, SLOT(quit()));</span><br><span class="line">thread.wait(1);</span><br><span class="line">eventLoop.exec();</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-进程与线程</title>
      <link href="/2019/11/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
      <url>/2019/11/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="并发concurrency与并行parallelism的概念"><a href="#并发concurrency与并行parallelism的概念" class="headerlink" title="并发concurrency与并行parallelism的概念"></a>并发concurrency与并行parallelism的概念</h3><p>并发（concurrency）：值宏观上看起来两个程序在同时运行，但微观上两个程序的指令是交叉运行的。cpu单周期只运行了一个指令。这种并发不能提高计算机性能，只能提高效率</p><p>并行（parallelism）：指严格物理意义上的同时运行，比如多核cpu，两个程序分别运行在两个核上，两者之间互不影响，单个周期内每个程序都运行了自己的指令。</p><h3 id="进程与线程的概念"><a href="#进程与线程的概念" class="headerlink" title="进程与线程的概念"></a>进程与线程的概念</h3><ul><li>进程是对运行时程序的封装，是系统进行<strong>资源调度和分配</strong>的基本单位，从而实现了操作系统的并发</li><li>线程是进程的子任务，是<strong>CPU调度和分派</strong>的基本单位，用于保证程序的实时性，实现进程内部的并发。线程是操作系统可识别的最小执行和调度单位。</li><li>每个线程都独自占用一个虚拟处理器（独自的寄存器组、指令计数器和处理器状态PSW）。每个线程完成不同的任务，但是共享同一地址空间（也就是同样的动态内存，映射文件，目标代码），打开的文件队列和其他内核资源。</li></ul><p>区别：</p><ol><li>一个线程只能属于一个进程，一个进程至少有一个线程。线程依赖于进程而存在。</li><li>进程在执行过程中有独立的内存单元，而多个线程共享进程的内存。资源分配给进程，同一进程的所有线程共享该进程的所有资源。统一进程的线程<strong>共享</strong>代码段，数据段和扩展段（堆存储）。但是每个线程拥有自己的栈段，用来存放所有局部变量和临时变量。</li><li>进程是资源分配的最小单位，线程是CPU调度的最小单位。</li><li><strong>系统开销</strong>：在创建或撤销进程时，系统都要分配或回收资源，因此操作系统所付出的开销将显著地大于在创建或撤销线程是的开销。在进行<strong>进程上下文切换</strong>时，涉及到整个当前进程CPU环境的保存以及新被调用运行的进程的CPU环境设置。而线程切换只须保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作。</li><li>通信：同一个进程多个线程具有相同的地址空间，使得他们之间实现同步和通信比较容易。进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信，<strong>需要进程同步和互斥手段的辅助</strong>，以保证数据的一致性。在有的系统中，线程的切换、同步和通信都无须操作系统内核的干预。</li><li>进程编程调试简单可靠性高，但是创建销毁开销大；线程开销小，切换速度快，但是编程调试相对复杂。</li><li>进程间不会相互影响；一个线程将导致整个进程挂掉</li><li>进程适用于多核、多机分布；线程适用于多核。</li></ol><p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552470678794_F9BF116BD97A95A5E655DF9E1672186F" alt="进程的五种状态"></p><h3 id="死锁发生的条件以及如何解决死锁"><a href="#死锁发生的条件以及如何解决死锁" class="headerlink" title="死锁发生的条件以及如何解决死锁"></a>死锁发生的条件以及如何解决死锁</h3><p>死锁是指两个或两个以上进程在执行过程中，因争夺资源而造成的相互等待的现象。死锁发生的四个必要条件为：</p><ol><li>互斥条件：进程所分配到的资源不允许其他进程访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源</li><li>请求和保持条件：进程获得一定资源后，又对其他资源发出请求，该资源可能被其他进程占用，此时请求阻塞但当前进程不会释放已经占有的资源</li><li>不可剥夺条件：进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用后自己释放</li><li>环路等待条件：进程发生死锁后，必然存在一个进程-资源之间的环形链</li></ol><p>解决死锁的方法只要破坏上述四个条件中的一个即可：</p><ol><li>资源一次性分配，（一次性分配进程所需要的所有资源）剥夺请求和保持条件（可能造成其他进程饥饿）</li><li>可剥夺资源：当进程新的资源未得到满足时，释放已经占有的资源，从而破坏不可剥夺的条件</li><li>资源有序分配：系统给没类资源赋予一个序号，每个进程按编号递增地请求资源，释放则相反，从而破坏环路等待条件。</li></ol><h3 id="进程间通信方式"><a href="#进程间通信方式" class="headerlink" title="进程间通信方式"></a>进程间通信方式</h3><ol><li><p>管道<br> 管道主要包括无名管道和命名管道。管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。<br> 普通管道PIPE：它是半双工（数据只能在一个方向上流动），具有固定的读端和写端。只能用于具有亲缘关系的进程间的通信（父子进程或兄弟进程）。可以看成一种特殊的文件，对于它的读写可以用普通的read，write函数。但它不是普通文件，不属于任何文件系统，只存在于内存中。<br> 命名管道FIFO：FIFO可以在无关的进程之间交换数据。FIFO有路径名与之相关联，以一种特殊设备文件形式存在于文件系统中。</p></li><li><p>系统IPC</p><p> 2.1 消息队列：<br> 消息的链接表，存放在内核中。一个消息队列由一个标识符来标记。（消息队列克服了信号semaphore传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等特点）具有写权限的进程可以按照一定规则向消息队列中添加新信息，对消息队列由读权限的进程可以从消息队列中读取信息。<br> 1）消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。<br> 2）消息队列独立于发送和接收进程。进程终止时，消息队列及其内容并不会被删除。<br> 3）消息队列可以实现消息的随机查询，消息不一定要以FIFO的次序读取，也可以按消息的类型读取。</p><p> 2.2 信号量semaphore<br> semaphore是一个计数器，可以用来控制多个进程对共享资源的访问。信号量用于实现进程间的互斥与同步，而不是用于存储进程间的通信数据。<br> 1）信号量用于进程间的同步，若要在进程间传递数据需要结合共享内存。<br> 2）信号量基于操作系统的PV操作，程序对信号量的操作都是原子操作。<br> 3）每次对信号量的PV操作不仅限于对信号量值加1或减1，可以加减任意正整数。<br> 4）支持信号量组。</p><p> 2.3 信号signal<br> 信号是一种比较复杂的通知方式，用于通知接收进程某个事件已经发生。</p><p> 2.4 共享内存 shared memory<br> 它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，（互斥锁和信号量）<br> 1）共享内存是最快的一种IPC，因为进程是直接对内存进行存取<br> 2）因为多个进程可以同时操作，所以需要进行同步<br> 3）信号量+共享内存通常结合使用，信号量用来同步对共享内存的访问</p></li><li><p>套件字socket<br>socket也是一种进程间通信机制，与其他通信机制不同的是他可以用于不同主机间的进程通信。</p></li></ol><h3 id="线程间通信方式"><a href="#线程间通信方式" class="headerlink" title="线程间通信方式"></a>线程间通信方式</h3><ol><li>临界区：是一段<strong>代码</strong>。通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问；</li><li>互斥量 Synchronized/Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。</li><li>信号量 Semaphore：为控制具有有限数量的用户资源而设计，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问该资源的最大线程数。</li><li>事件（信号）Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。</li></ol><h3 id="Linux的4中锁机制"><a href="#Linux的4中锁机制" class="headerlink" title="Linux的4中锁机制"></a>Linux的4中锁机制</h3><ol><li>互斥锁 mutex：用于保证<strong>任何时刻</strong>，都只能有一个线程访问该对象。当获取锁失败是，线程会进入等待，等待锁释放时被唤醒。</li><li>读写锁 rwlock：分为读锁和写锁。处于读操作时，可以允许多个线程同时获得读操作。但是同一时刻只能有一个线程可以获得写锁。注意，写锁会阻塞其他读写锁。当有一个线程获得写锁在写的时候，读锁也不能被其他线程获取；写锁优先于读锁。</li><li>自旋锁 spinlock：任何时刻只有一个线程访问对象。但是当获取锁失败的时候，不会进入睡眠，而是在原地自旋（忙等待），知道锁被释放。这样节省了线程从睡眠状态到被唤醒期间的消耗，在加锁短暂的环境下会极大提高效率。但是如果加锁时间过长，会非常浪费CPU资源</li><li>RCU：read-copy—update，在修改数据时，首先要读取数据，然后生成一个副本，对副本进行修改。修改完成后，再将老数据update成新的数据。使用RCU时，读者激活不需要同步开销，既不需要获得锁，也不实用原子指令，不会导致锁竞争，不需要考虑死锁问题。但对写者的同步开销比较大。在有大量读操作，少量写操作的情况下效率非常高。</li></ol><h3 id="有了进程，为什么还要有线程"><a href="#有了进程，为什么还要有线程" class="headerlink" title="有了进程，为什么还要有线程"></a>有了进程，为什么还要有线程</h3><p>进程可以使多个程序能够并发执行，以提高资源的利用率和系统的吞吐量，但是具有一些缺点：</p><ul><li>进程在同一时间只能干一件事</li><li>进程在执行的过程中如果阻塞，整个进程会被挂起，即使进程中有些工作不依赖于等待的资源，仍然不会执行</li></ul><p>因此操作系统引入了比进程粒度更小的线程，作为并发执行的基本单位，从而减少并发执行时所付出的时空开销，提高并发性。和进程相比，线程的优势为：</p><ul><li>从资源上讲，线程是一种”节俭“的多任务操作方式。在linux系统下，启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护代码段，堆栈段和数据段，较为昂贵。</li><li>从切换效率上讲，运行于一个进程中的多个线程，他们之间使用相同的地址空间，而且线程间彼此切换所需时间也远远小于进程间切换所需要的时间。</li><li>从通信机制上来将，线程间具有方便的通信机制。对不同进程来说，它们具有独立的数据空间，要进行数据传递只能通过进程间通信的方式进行，这种方式费时而且很不方便。同一进程下的线程共享数据空间，所以一个线程的数据可以直接为其他线程所用。</li><li>除此之外，多线程还使CPU系统更加有效。操作系统会保证当线程数不大于CPU数目时，不同的线程运行于不同的CPU。</li><li>改善程序结构。一个长并且复杂的进程可以考虑分为多个线程，成为几个独立或半独立运行的部分，这样的程序才会利于理解和修改。</li></ul><p><strong>关于之前项目中TI-RTOS</strong>：该实时操作系统中的task实际上是线程thread，不是process。能够方便进行数据通信。</p><h4 id="切换线程需要保存哪些上下文"><a href="#切换线程需要保存哪些上下文" class="headerlink" title="切换线程需要保存哪些上下文"></a>切换线程需要保存哪些上下文</h4><p>线程在切换的过程中，需要保存当前线程id，线程状态，堆栈，寄存器状态等信息。其中寄存器主要包括SP，PC，EAX等寄存器。</p><p>主要功能为：<br>SP：堆栈指针，指向当前栈的栈顶地址<br>PC：程序计数器，存储下一条将要执行的指令<br>EAX：累加寄存器，用于加法惩罚的缺省寄存器。</p><h4 id="汇编的寄存器"><a href="#汇编的寄存器" class="headerlink" title="汇编的寄存器"></a>汇编的寄存器</h4><p><strong>数据寄存器：</strong></p><ul><li>AX 数据累加寄存器 （算数运算的主要寄存器）</li><li>BX 基址寄存器 （寻址时用作基址）</li><li>CX 计算寄存器 （循环指令操作或串处理指令中隐含计数）</li><li>DX 数据寄存器 </li></ul><p><strong>指针与变址寄存器：</strong></p><ul><li>SP 堆栈指针寄存器</li><li>BP 基址指针寄存器</li><li>SI 源变址寄存器</li><li>DI 目标变址寄存器</li></ul><p><strong>段寄存器：</strong></p><ul><li>CS 代码段</li><li>DS 数据段</li><li>SS 栈段</li><li>ES 附加段 （辅助数据区，其实是堆区）</li></ul><p><strong>控制寄存器：</strong></p><ul><li>IP 指令指针寄存器</li><li>FR 控制标志位</li></ul><h3 id="创建进程fork和vfork的区别"><a href="#创建进程fork和vfork的区别" class="headerlink" title="创建进程fork和vfork的区别"></a>创建进程fork和vfork的区别</h3><h4 id="fork是创建一个和当前进程映像一样的进程。"><a href="#fork是创建一个和当前进程映像一样的进程。" class="headerlink" title="fork是创建一个和当前进程映像一样的进程。"></a>fork是创建一个和当前进程映像一样的进程。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> fork(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure><p>成功调用fork会创建一个新的进程，新进程与调用fork的进程几乎一模一样（除了pid不一样），这两个进程都会继续运行。在子进程中，成功fork会返回0。在父进程中fork返回子进程的pid。</p><p>最常见的fork是创建一个新进程，然后使用exec载入二进制映像，替换当前进程的映像。这种情况下，fork了新的进程，而这个子进程会执行一个新的二进制可执行文件的映像。”派生加执行“</p><p>现在的unix系统（linux）采用了写时复制的方法，内核将父进程的内部数据结构和进程页表项复制一份，但并不对地址空间的内容进行逐页复制。</p><h4 id="vfork"><a href="#vfork" class="headerlink" title="vfork"></a>vfork</h4><p>fork之后立刻执行exec会造成地址空间的浪费。</p><p>除了子进程必须要立刻执行一次对exec的系统调用，或者调用_exit退出，对vfork的成功调用所产生的结果和fork是一样的。vfork会挂起父进程直到子进程终止或者运行一个新的可执行文件的影响。通过这样的方式，vfork避免了地址空间按页复制。这个过程中，父进程和子进程共享相同的地址空间和页表项。实际上vfork只完成了复制内核数据结构这一件事。</p><h3 id="常用的线程模型"><a href="#常用的线程模型" class="headerlink" title="常用的线程模型"></a>常用的线程模型</h3><ol><li>Future模型<br> 该模型通常在使用的时候需要结合Callable接口配合使用。<br> Future是把结果放在将来获取，当前主线程并不急于获取处理结果。允许子线程先进行处理一段时间，处理结束之后就把结果保存下来，当主线程需要使用的时候再向子线程索取。<br> Callable是类似于Runnable的接口，其中call方法类似于run方法，所不同的是run方法不能抛出受检异常没有返回值，而call方法则可以抛出受检异常并可设置返回值。两者的方法体都是线程执行体。</li><li>fork&amp;join模型<br> 该模型包含递归思想和回溯思想。递归用来拆分任务，回溯用于合并结果。可以用来处理一些可以进行拆分的大任务。其主要是把一个大任务逐级拆分为多个子任务，然后分别在子线程中执行，当每个子线程执行结束后逐级回溯，返回结果进行汇总合并，最终得出想要的结果。</li><li>actor模型 （我用的过是TI-RTOS）<br> actor模型属于一种基于消息传递机制并行任务处理思想，它以消息的形式来进行线程间数据传输，避免了全局变量的使用，进而避免了数据同步错误的隐患。actor在接受到消息之后可以自己进行处理，也可以继续传递给其他actor进行处理。</li><li>生产者消费者模型<br> 核心是使用一个缓存来保存任务。开启一个或多个线程来圣战任务，然后再开启一个或多个来从缓存中取出任务进行处理。这样的好处是任务的生成和处理分隔开，生产者不需要处理任务，只负责生成任务然后保存到缓存。而消费者只需要从缓存中取出任务进行处理。</li><li>master-worker模型<br> 类似于任务分发策略，开启一个master线程接收任务，然后在master中根据任务的具体情况进行分发，交给其他worker子线程。然后由子线程处理任务。如果需要返回结果，worker处理结束之后把处理结果返回给master。</li></ol><h3 id="操作系统从用户态到内核态的转化原理"><a href="#操作系统从用户态到内核态的转化原理" class="headerlink" title="操作系统从用户态到内核态的转化原理"></a>操作系统从用户态到内核态的转化原理</h3><ol><li>用户态切换到内核态的三种方式<br> （1）系统调用，用户主动要求切换到内核态的唯一一种方式。<br> （2）外部中断，外围设备完成用户请求操作后发出的中断型号。<br> （3）异常，在CPU执行运行用户态程序的时候，发现了某件不可知的异常。比如缺页异常</li><li>切换方式<br> （1）从当前进程的描述符中提取其内核栈的ss0和esp0信息<br> （2）使用ss0和esp0指向的内核栈将当前进程的cs，eip，eflags，ss，esp信息保存起来。保存当前信息。<br> （3）将先前由中断向量检索得到的中断处理程序的cs，eip信息装入相应寄存器，开始执行中断处理程序。</li><li>为什么要分内核态和用户态<br> 为了安全性。在cpu的一些指令中，有的指令如果用错，将会导致整个系统崩溃。分了内核态和用户态后，当用户操作这些指令的时候，内核为其提供了API，可以通过系统调用陷入内核态，让内核去执行这些操作。</li></ol><h3 id="进程同步和异步"><a href="#进程同步和异步" class="headerlink" title="进程同步和异步"></a>进程同步和异步</h3><p>进程同步：<br>我们把异步环境下的一组并发进程因直接制约而互相发送消息、进行互相合作、互相等待，使得各进程按一定的速度执行的过程称为进程间的同步。</p><p>具有同步关系的一组并发进程称为合作进程，合作进程间互相发送的信号称为消息或事件。</p><p>异步调用：<br>一个可以无需等待被调用函数的返回值就让操作继续进行的方法，（多用“多线程”来实现）。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux相关</title>
      <link href="/2019/11/05/linux%E7%9B%B8%E5%85%B3/"/>
      <url>/2019/11/05/linux%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<p>参考<a href="https://github.com/xiaowenxia/embedded-notes/blob/master/linux.md#%E7%B3%BB%E7%BB%9F%E5%85%B3%E6%9C%BA%E5%91%BD%E4%BB%A4" target="_blank" rel="noopener">https://github.com/xiaowenxia/embedded-notes/blob/master/linux.md#%E7%B3%BB%E7%BB%9F%E5%85%B3%E6%9C%BA%E5%91%BD%E4%BB%A4</a></p><h3 id="Linux指令"><a href="#Linux指令" class="headerlink" title="Linux指令"></a>Linux指令</h3><h4 id="系统关机指令"><a href="#系统关机指令" class="headerlink" title="系统关机指令"></a>系统关机指令</h4><ul><li>shutdown: 安全地将系统关机</li><li>halt: 调用shutdown -h （halt means stop）</li><li>reboot: 工作过程差不多跟halt一样，不过是引发主机重启</li><li>poweroff: halt的软链接</li><li>init: 所有进程的祖先，它的进程号始终为1，init 0为关机，init 1为重启</li></ul><h4 id="查看文本"><a href="#查看文本" class="headerlink" title="查看文本"></a>查看文本</h4><ul><li>cat</li><li>tac (cat的反向指令，从最后一行倒叙显示全部内容)</li><li>sed</li><li>head</li><li>tail</li><li>more</li><li>less</li><li>nl (cat -n 显示时输出行号)</li></ul><h4 id="mount-挂载linux系统外的文件"><a href="#mount-挂载linux系统外的文件" class="headerlink" title="mount 挂载linux系统外的文件"></a>mount 挂载linux系统外的文件</h4><p>命令格式 <code>mount [-t vfstype] [-o options] device dir</code><br>如 <code>mount -t nfs 192.168.0.1:/tmp /mnt/nfs</code></p><h4 id="lsusb-显示系统中以及连接到系统的USB总线信息的工具"><a href="#lsusb-显示系统中以及连接到系统的USB总线信息的工具" class="headerlink" title="lsusb 显示系统中以及连接到系统的USB总线信息的工具"></a>lsusb 显示系统中以及连接到系统的USB总线信息的工具</h4><p>列出USB详细信息 <code>lsusb -v</code><br>列出有多少USB设备 <code>find /dev/bus</code><br>打印特定设备的详细信息 <code>lsusb -D /dev/bus/usb/008/002</code></p><h4 id="lsof-列出当前系统打开文件的工具"><a href="#lsof-列出当前系统打开文件的工具" class="headerlink" title="lsof 列出当前系统打开文件的工具"></a>lsof 列出当前系统打开文件的工具</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ sudo lsof</span><br><span class="line">COMMAND    PID      USER   FD      TYPE     DEVICE     SIZE       NODE      NAME</span><br><span class="line">init       1         root  cwd      DIR       3,3       1024       2         /</span><br><span class="line">init       1         root  rtd      DIR       3,3       1024       2         /</span><br><span class="line">init       1         root  txt      REG       3,3       38432      1763452  /sbin/init</span><br><span class="line">init       1         root  mem      REG       3,3       106114     1091620  /lib/libdl-2.6.so</span><br><span class="line">init       1         root  mem      REG       3,3       7560696    1091614  /lib/libc-2.6.so</span><br><span class="line">init       1         root  mem      REG       3,3       79460      1091669  /lib/libselinux.so.1</span><br><span class="line">init       1         root  mem      REG       3,3       223280     1091668  /lib/libsepol.so.1</span><br><span class="line">init       1         root  mem      REG       3,3       564136     1091607  /lib/ld-2.6.so</span><br></pre></td></tr></table></figure><h3 id="linux软件开发知识点"><a href="#linux软件开发知识点" class="headerlink" title="linux软件开发知识点"></a>linux软件开发知识点</h3><h4 id="linux进程间通讯方式："><a href="#linux进程间通讯方式：" class="headerlink" title="linux进程间通讯方式："></a>linux进程间通讯方式：</h4><ol><li>管道(pipe)及有名管道(named pipe)</li><li>信号(Signal)</li><li>报文(Message)队列（消息队列）</li><li>共享内存</li><li>信号量(semaphore)</li><li>套接口（Socket）</li></ol><h4 id="内存申请函数"><a href="#内存申请函数" class="headerlink" title="内存申请函数"></a>内存申请函数</h4><ol><li>alloc 向栈申请内存，不用释放内存</li><li>calloc</li><li>malloc 向堆申请内存，需要释放</li><li>realloc</li></ol><h4 id="linux内存分配"><a href="#linux内存分配" class="headerlink" title="linux内存分配"></a>linux内存分配</h4><div class="table-container"><table><thead><tr><th>内存区</th><th>存放数据</th><th>备注</th></tr></thead><tbody><tr><td>静态存储区</td><td>静态数据、全局数据、常量</td><td>在程序编译的时候就已经分配好</td></tr><tr><td>栈</td><td>局部变量、函数参数</td><td>栈内存分配运算内置于处理器的指令集中（push），效率很高，但是分配的内存容量有限</td></tr><tr><td>堆区</td><td>malloc申请的内存</td><td>动态内存分配，需要手动释放，会出现内存泄露风险</td></tr><tr><td>代码区</td><td>代码</td><td>存放函数体的二进制代码</td></tr><tr><td>文字常量区</td><td>常量字符串</td><td>程序结束后由系统释放</td></tr></tbody></table></div><h4 id="gcc编译过程"><a href="#gcc编译过程" class="headerlink" title="gcc编译过程"></a>gcc编译过程</h4><ol><li>预编译 生成*.i</li><li>编译 生成*.s</li><li>汇编 生成*.o</li><li>链接 可执行文件</li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式笔记-C</title>
      <link href="/2019/11/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AC%94%E8%AE%B0-C/"/>
      <url>/2019/11/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AC%94%E8%AE%B0-C/</url>
      
        <content type="html"><![CDATA[<p>嵌入式C语言查漏补缺，参考<a href="https://github.com/xiaowenxia/embedded-notes" target="_blank" rel="noopener">https://github.com/xiaowenxia/embedded-notes</a></p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><div class="table-container"><table><thead><tr><th>数据类型</th><th>16位</th><th>32位</th><th>64位</th></tr></thead><tbody><tr><td>char</td><td>1</td><td>1</td><td>1</td></tr><tr><td>pointer</td><td>2</td><td>4</td><td>8</td></tr><tr><td>short</td><td>2</td><td>2</td><td>2</td></tr><tr><td>int</td><td>4</td><td>4</td><td>4</td></tr><tr><td>float</td><td>4</td><td>4</td><td>4</td></tr><tr><td>double</td><td>8</td><td>8</td><td>8</td></tr><tr><td>long</td><td>4</td><td>4</td><td>8</td></tr><tr><td>long long</td><td>8</td><td>8</td><td>8</td></tr></tbody></table></div><h3 id="static与volatile"><a href="#static与volatile" class="headerlink" title="static与volatile"></a>static与volatile</h3><p>C语言中，static有两个作用：1、文件作用域，2、函数作用域<br>文件作用域关键字static 的作用是，以static 申明的全局变量、函数不得被其他文件所引用。<br>static 另外一个用途是函数内部静态变量，只会被初始化一次，而且变量存储在全局数据段中而不是函数栈中，所以其生命期会一直持续到程序退出。<strong>但注意static并不是const，static只是存储在静态存储区</strong></p><p>C语言中volatile表示这个变量很可能会被意想不到地改变，因此需要小心对待。也就是说，优化器在用到这个变量时必须每次重新从虚拟内存中读取这个变量的值，而不是使用保存在寄存器里的备份。<br>volatile只在以下三种场合是适合的：</p><ul><li>和信号处理（signal handler）相关的场合；</li><li>和内存映射硬件（memory mapped hardware）相关的场合；</li><li>和非本地跳转（setjmp 和 longjmp）相关的场合。</li></ul><p>参考<a href="https://zhuanlan.zhihu.com/p/33074506" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/33074506</a>:</p><ul><li><strong>naive case:</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// global shared data</span><br><span class="line">bool flag = false;</span><br><span class="line"></span><br><span class="line">thread1() &#123;</span><br><span class="line">    flag = false;</span><br><span class="line">    Type* value = new Type(/* parameters */);</span><br><span class="line">    thread2(value);</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        if (flag == true) &#123;</span><br><span class="line">            apply(value);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    thread2.join();</span><br><span class="line">    if (nullptr != value) &#123; delete value; &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">thread2(Type* value) &#123;</span><br><span class="line">    // do some evaluations</span><br><span class="line">    value-&gt;update(/* parameters */);</span><br><span class="line">    flag = true;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码将 thread1 作为主线程，等待 thread2 准备好 value。因此，thread2 在更新 value 之后将 flag 置为真，而 thread1 死循环地检测 flag。简单来说，这段代码的意图希望实现 thread2 在 thread1 使用 value 之前执行完毕这样的语义。</p><p>对多线程编程稍有了解的人应该知道，这段代码是有问题的。问题主要出在两个方面。其一，在 thread1 中，flag = false 到 while 死循环里，没有任何机会对 flag 的值做修改，<strong>因此编译器可能会将 if (flag == true) 的内容全部优化掉。</strong> 其二，在 thread2 中，尽管逻辑上 update 需要发生在 flag = true 之前，但编译器和 CPU 并不知道；因此 flag = true 可能发生在 update 完成之前，因此 thread1 执行 apply(value) 时可能 value 还未准备好。</p><ul><li><strong>错误理解：将flag加上volatile</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// global shared data</span><br><span class="line">volatile bool flag = false;  // 1.</span><br><span class="line"></span><br><span class="line">thread1() &#123;</span><br><span class="line">    flag = false;</span><br><span class="line">    Type* value = new Type(/* parameters */);</span><br><span class="line">    thread2(value);</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        if (flag == true) &#123;  // 2.</span><br><span class="line">            apply(value);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    thread2.join();</span><br><span class="line">    if (nullptr != value) &#123; delete value; &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">thread2(Type* value) &#123;</span><br><span class="line">    // do some evaluations</span><br><span class="line">    value-&gt;update(/* parameters */);</span><br><span class="line">    flag = true;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在1处定义了flag为volatile，所以if condition不会被优化掉。但value并不是。编译器仍有可能在优化时将 thread2 中的 update 和对 flag 的赋值交换顺序。此外，由于 volatile 禁止了编译器对 flag 的优化，这样使用 volatile 不仅无法达成目的，反而会导致性能下降。</p><ul><li><strong>再加一个volatile在value上：</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// global shared data</span><br><span class="line">volatile bool flag = false;</span><br><span class="line"></span><br><span class="line">thread1() &#123;</span><br><span class="line">    flag = false;</span><br><span class="line">    volatile Type* value = new Type(/* parameters */);   // 1.</span><br><span class="line">    thread2(value);</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        if (flag == true) &#123;</span><br><span class="line">            apply(value);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    thread2.join();</span><br><span class="line">    if (nullptr != value) &#123; delete value; &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">thread2(volatile Type* value) &#123;</span><br><span class="line">    // do some evaluations</span><br><span class="line">    value-&gt;update(/* parameters */);                    // 2.</span><br><span class="line">    flag = true;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来对两个变量都进行了volatile，但是volatile 只作用在编译器上，但我们的代码最终是要运行在 CPU 上的。尽管编译器不会将 (2) 处换序，但 CPU 的乱序执行（out-of-order execution）已是几十年的老技术了；在 CPU 执行时，value 和 flag 的赋值仍有可能是被换序了的（store-store）。此外，(2) 处的 value = new Type() 一行代码并不如想象中那么简单。它至少做了：</p><ul><li>分配一块 sizeof(Type) 大小的内存；</li><li>在这块内存上，执行 Type 类型的初始化；</li><li>将这块内存的首地址赋值给 value。</li></ul><p>在 CPU 乱序执行之下，甚至有可能发生 value 和 flag 已赋值完毕，但内存里尚未完成 Type 初始化的情况。此时若 thread1 中使用 value，则程序可能崩溃。</p><ul><li><strong>应该怎么做</strong>：</li></ul><ol><li>使用原子操作：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// global shared data</span><br><span class="line">std::atomic&lt;bool&gt; flag = false;  // #include &lt;atomic&gt;</span><br><span class="line"></span><br><span class="line">thread1() &#123;</span><br><span class="line">    flag = false;</span><br><span class="line">    Type* value = new Type(/* parameters */);</span><br><span class="line">    thread2(value);</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        if (flag == true) &#123;</span><br><span class="line">            apply(value);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    thread2.join();</span><br><span class="line">    if (nullptr != value) &#123; delete value; &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">thread2(Type* value) &#123;</span><br><span class="line">    // do some evaluations</span><br><span class="line">    value-&gt;update(/* parameters */);</span><br><span class="line">    flag = true;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>使用互斥量和条件变量</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// global shared data</span><br><span class="line">std::mutex m;                   // #include &lt;mutex&gt;</span><br><span class="line">std::condition_variable cv;     // #include &lt;condition_variable&gt;</span><br><span class="line">bool flag = false;</span><br><span class="line"></span><br><span class="line">thread1() &#123;</span><br><span class="line">    flag = false;</span><br><span class="line">    Type* value = new Type(/* parameters */);</span><br><span class="line">    thread2(value);</span><br><span class="line">    std::unique_lock&lt;std::mutex&gt; lk(m); //1互斥锁</span><br><span class="line">    cv.wait(lk, []()&#123; return flag; &#125;);</span><br><span class="line">    apply(value);</span><br><span class="line">    lk.unlock();</span><br><span class="line">    thread2.join();</span><br><span class="line">    if (nullptr != value) &#123; delete value; &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">thread2(Type* value) &#123;</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; lk(m); //1互斥锁</span><br><span class="line">    // do some evaluations</span><br><span class="line">    value-&gt;update(/* parameters */);</span><br><span class="line">    flag = true;</span><br><span class="line">    cv.notify_one();</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，由线程之间的同步由互斥量和条件变量来保证，同时也避免了 while (true) 死循环空耗 CPU 的情况。</p><p>在单任务的环境中，一个函数体内部，如果在两次读取变量的值之间的语句没有对变量的值进行修改，那么编译器就会设法对可执行代码进行优化。由于访问寄存器的速度要快过RAM（从RAM中读取变量的值到寄存器），以后只要变量的值没有改变，就一直从寄存器中读取变量的值，而不对RAM进行访问。</p><p>嵌入式变成中volatile的作用：</p><ol><li><p>告诉compiler不能做任何优化，比如要往某一地址送两个指令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">比如：</span><br><span class="line">int *ip = ...;</span><br><span class="line">*ip = 1;</span><br><span class="line">*ip = 2;</span><br><span class="line"></span><br><span class="line">优化后：</span><br><span class="line">int *ip = ...;</span><br><span class="line">*ip = 2;</span><br><span class="line"></span><br><span class="line">会造成第一个指令丢失。</span><br></pre></td></tr></table></figure></li><li><p>volatile定义的变量如果在程序外被改变，则每次都必须从内存中读取，而不能把他放在cache或寄存器中重复使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">volatile char a;</span><br><span class="line">a = 0;</span><br><span class="line">while(!a)&#123; //某个任务把a的值改掉后</span><br><span class="line">// do something</span><br><span class="line">&#125;</span><br><span class="line">doother();</span><br></pre></td></tr></table></figure></li></ol><p>如果没有volatile, doother()就不会执行。</p><p>volatile能够避免编译器优化带来的错误，但使用volatile的同时，也需要注意频繁的使用volatile很可能会降低代码尺寸和降低性能。</p><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>const T 是一个常量，表示该变量不可更改。<br>const T <em> 是一个指向常量的指针，该指针指向的变量不能变。<br><em>*从右向左读：</em></em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char * const cp;  // cp is a const pointer to char, 指针的内容（也就是变量地址）不能变</span><br><span class="line">const char * p;   // p is a pointer to const char;</span><br><span class="line">char const * p;   // 同上,因为C++里面没有const*的运算符，所以const只能属于前面的类型。</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++, 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决Mac上使用iterm2加载terminal出现(base)</title>
      <link href="/2019/10/31/%E8%A7%A3%E5%86%B3mac%E4%B8%8A%E4%BD%BF%E7%94%A8iterm2%E5%8A%A0%E8%BD%BDterminal%E5%87%BA%E7%8E%B0-base/"/>
      <url>/2019/10/31/%E8%A7%A3%E5%86%B3mac%E4%B8%8A%E4%BD%BF%E7%94%A8iterm2%E5%8A%A0%E8%BD%BDterminal%E5%87%BA%E7%8E%B0-base/</url>
      
        <content type="html"><![CDATA[<p>在mac上安装anaconda之后，发现打开iterms2的时候命令号前出现了(base)。并且打开terminal比较慢。</p><p>查阅参考<a href="https://blog.csdn.net/u010666669/article/details/90085125" target="_blank" rel="noopener">https://blog.csdn.net/u010666669/article/details/90085125</a></p><p>发现是因为每次打开terminal的时候conda都会创建一个虚拟环境(base)。</p><p>查看conda环境： <code>conda env list</code></p><p>配置conda不自动生成虚拟环境：<code>conda config --set auto_activate_base false</code> 设置conda不要自动启动base环境就可以了。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Set自定义排序与iterator的迷思</title>
      <link href="/2019/10/29/set%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F%E4%B8%8Eiterator%E7%9A%84%E8%BF%B7%E6%80%9D/"/>
      <url>/2019/10/29/set%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F%E4%B8%8Eiterator%E7%9A%84%E8%BF%B7%E6%80%9D/</url>
      
        <content type="html"><![CDATA[<h3 id="Set原型"><a href="#Set原型" class="headerlink" title="Set原型"></a>Set原型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class Key,</span><br><span class="line">          class Compare = less &lt;key&gt;,</span><br><span class="line">          class Alloc = alloc&gt;</span><br><span class="line">class set &#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>set是用红黑二叉树实现的不可存在重复元素Key的容器，默认采用Compare规则进行排序。可以快速插入和删除元素，插入删除相当于在二叉树上增加删除节点，<strong>删除节点不会返回set的iterator</strong>。</p><p>用一段代码来实现set的自定义排序，以及删除一个节点后，iterator的效果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmpSymbol</span>&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; a, <span class="keyword">const</span> <span class="keyword">int</span>&amp; b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>, cmpSymbol&gt; S;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">S.insert(<span class="number">1</span>);</span><br><span class="line">S.insert(<span class="number">2</span>);</span><br><span class="line">S.insert(<span class="number">3</span>);</span><br><span class="line">S.insert(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> s:S)&#123; <span class="comment">//使用自动迭代器，这里的s是内容，不是iterator</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// print 5, 3, 2, 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it = S.begin();</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator tmp = S.begin();</span><br><span class="line">tmp++; <span class="comment">//注意tmp = it+1是非法的</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;          <span class="comment">//print 5</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *tmp &lt;&lt; <span class="built_in">endl</span>;          <span class="comment">//print 3</span></span><br><span class="line"></span><br><span class="line">S.erase(it);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *S.begin() &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//print 3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;           <span class="comment">//print 5</span></span><br><span class="line">it++;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;           <span class="comment">//print 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ol><li>iterator是一个泛型指针，但并不是指针。指针是一个存放有另外一个变量的地址的特殊<strong>变量</strong>，而iterator是一个<strong>对象</strong>，只是参照了指针的++，—，和修改所指变量内容的特征进行设计的<strong>专门用于指向STL容器</strong>的对象。</li><li>set删除掉一个元素后，指向那个元素的迭代器并没有消失，可以想象成指针指向的空间并没有发生改变，只是二叉树的链接发生了改变。</li><li>但是删掉这个元素后，这个元素迭代器的下一个是什么元素并不确定，并不按照原来的排序进行。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode#179. Largest Number</title>
      <link href="/2019/10/12/Leetcode-179-Largest-Number/"/>
      <url>/2019/10/12/Leetcode-179-Largest-Number/</url>
      
        <content type="html"><![CDATA[<p>字符串比较的奇巧淫技。</p><p>Given a list of non negative integers, arrange them such that they form the largest number.</p><p>Example1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [10,2]</span><br><span class="line">Output: &quot;210&quot;</span><br></pre></td></tr></table></figure></p><p>Example2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,30,34,5,9]</span><br><span class="line">Output: &quot;9534330&quot;</span><br></pre></td></tr></table></figure></p><p>思路很确定就是先比较第一位排序然后第二位排序。下边的这个解法就只用了一次排序，虽然时间复杂度稍微高一点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">string</span>&amp; s1, <span class="built_in">string</span>&amp; s2)</span></span>&#123;</span><br><span class="line">        <span class="built_in">string</span> c = s1+s2;</span><br><span class="line">        <span class="built_in">string</span> d = s2+s1;</span><br><span class="line">        <span class="keyword">return</span> c.compare(d) &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">largestNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; strs;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            strs.push_back(to_string(nums[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        sort(strs.begin(), strs.end(), cmp);</span><br><span class="line">        <span class="built_in">string</span> ans = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;strs.size(); i++)&#123;</span><br><span class="line">            ans += strs[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(ans[<span class="number">0</span>] == <span class="string">'0'</span>) ans = <span class="string">"0"</span>; <span class="comment">//边界条件</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode#315.Count of Smaller Numbers After Self</title>
      <link href="/2019/10/11/Leetcode-315-Count-of-Smaller-Numbers-After-Self/"/>
      <url>/2019/10/11/Leetcode-315-Count-of-Smaller-Numbers-After-Self/</url>
      
        <content type="html"><![CDATA[<p>You are given an integer array nums and you have to return a new counts array. The counts array has the property where counts[i] is the number of smaller elements to the right of nums[i].</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [5,2,6,1]</span><br><span class="line">Output: [2,1,1,0] </span><br><span class="line">Explanation:</span><br><span class="line">To the right of 5 there are 2 smaller elements (2 and 1).</span><br><span class="line">To the right of 2 there is only 1 smaller element (1).</span><br><span class="line">To the right of 6 there is 1 smaller element (1).</span><br><span class="line">To the right of 1 there is 0 smaller element.</span><br></pre></td></tr></table></figure></p><p>这道题第一反应肯定是暴力求解，时间复杂度为O(n^2)。确实应该也能过。<br>思考优化的算法，首先确定，这个题肯定与排序有关。实现加速的排序，可以选择插入二分法，也就是二叉搜索树。<br>不同的是我们需要在每一个节点定义该节点左子树上的所有节点的个数，这样才能实现不需要遍历子树就能确定有多少个小于该节点的数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        TreeNode* left;</span><br><span class="line">        TreeNode* right;</span><br><span class="line">        </span><br><span class="line">        TreeNode(<span class="keyword">int</span> x): val(x), count(<span class="number">0</span>), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countSmaller(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans(n, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(nums[n<span class="number">-1</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-2</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            TreeNode* tmp = <span class="keyword">new</span> TreeNode(nums[i]);</span><br><span class="line">            TreeNode* curr = root;</span><br><span class="line">            <span class="keyword">int</span> nodes = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123; <span class="comment">//将tmp添加进BST</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;val &gt; curr-&gt;val)&#123; <span class="comment">//在当前节点右子树中</span></span><br><span class="line">                    nodes += curr-&gt;count+<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(!curr-&gt;right)&#123; <span class="comment">//找到空位</span></span><br><span class="line">                        curr-&gt;right = tmp;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                        curr = curr-&gt;right; <span class="comment">//在右子树中继续寻找</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span>&#123; <span class="comment">//在左子树中</span></span><br><span class="line">                    curr-&gt;count += <span class="number">1</span>; <span class="comment">//那么当前节点要的个数要加1</span></span><br><span class="line">                    <span class="keyword">if</span>(!curr-&gt;left)&#123; <span class="comment">//找到空位</span></span><br><span class="line">                        curr-&gt;left = tmp;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                        curr = curr-&gt;left;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans[i] = nodes;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode#406. Queue Reconstruction by Height</title>
      <link href="/2019/10/11/Leetcode-406-Queue-Reconstruction-by-Height/"/>
      <url>/2019/10/11/Leetcode-406-Queue-Reconstruction-by-Height/</url>
      
        <content type="html"><![CDATA[<p>Suppose you have a random list of people standing in a queue. Each person is described by a pair of integers (h, k), where h is the height of the person and k is the number of people in front of this person who have a height greater than or equal to h. Write an algorithm to reconstruct the queue.</p><p>Note:<br>The number of people is less than 1,100.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]</span><br></pre></td></tr></table></figure></p><p>这道题拿到的时候就想着要先按高矮进行排序，然后再交换，后来交换的时候绕晕了，看了一眼题解。</p><p>基本思路还是先按高矮进行排序，然后用贪心算法。每次取还没有安排位置最矮的。然后从0号位数到应该安排的位置（前边是空位，或者是和当前人一样高的，在当前人之前不可能有比他高的被安排。）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; p1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; p2)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(p1[<span class="number">0</span>] == p2[<span class="number">0</span>]) <span class="keyword">return</span> p1[<span class="number">1</span>] &lt; p2[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> p1[<span class="number">0</span>] &lt; p2[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; reconstructQueue(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; people) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> n = people.size();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pos(n, <span class="number">-1</span>);</span><br><span class="line">        sort(people.begin(), people.end(), cmp);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> curr = people[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(pos[j] == <span class="number">-1</span> &amp;&amp; cnt == people[i][<span class="number">1</span>])&#123;</span><br><span class="line">                    pos[j] = i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(pos[j] == <span class="number">-1</span> || people[pos[j]][<span class="number">0</span>] == curr)&#123; <span class="comment">//从小到大，前边不会出现比它大的</span></span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            ans.push_back(people[pos[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode#221.Maximal Square</title>
      <link href="/2019/10/11/Leetcode-221-Maximal-Square/"/>
      <url>/2019/10/11/Leetcode-221-Maximal-Square/</url>
      
        <content type="html"><![CDATA[<p>这是一道较为另类的动态规划。</p><p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing only 1’s and return its area.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line"></span><br><span class="line">1 0 1 0 0</span><br><span class="line">1 0 1 1 1</span><br><span class="line">1 1 1 1 1</span><br><span class="line">1 0 0 1 0</span><br><span class="line"></span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure></p><p>思路：<br>要组成一个正方形，就要找到最长的正方形边长。利用二维动态规划保存以每一个位置为正方形右下角的时候，能够找到的最大正方形边长。<br>考虑第(i, j)位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i-1][j-1]  dp[i-1][j]</span><br><span class="line">dp[i][j-1]    dp[i][j]</span><br></pre></td></tr></table></figure><p>状态转移公式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if(matrix[i][j] == 1) dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) +1</span><br><span class="line">else dp[i][j] = 0;</span><br></pre></td></tr></table></figure></p><p>这个题的坑在于，输入的是char而不是int，一定要注意。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.size();</span><br><span class="line">        <span class="keyword">if</span>(row == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">if</span>(col == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(row, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(col, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> max_edge = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;row; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][<span class="number">0</span>] == <span class="string">'1'</span>) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            max_edge = max(max_edge, dp[i][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;col; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[<span class="number">0</span>][i] == <span class="string">'1'</span>) dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">            max_edge = max(max_edge, dp[<span class="number">0</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;row; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j&lt;col; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    dp[i][j] = min(dp[i][j<span class="number">-1</span>], min(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j<span class="number">-1</span>])) +<span class="number">1</span>;</span><br><span class="line">                    max_edge = max_edge &gt; dp[i][j]? max_edge:dp[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max_edge * max_edge;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习损失函数</title>
      <link href="/2019/10/10/2019-10-10-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/"/>
      <url>/2019/10/10/2019-10-10-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>参考<a href="https://www.csuldw.com/2016/03/26/2016-03-26-loss-function/" target="_blank" rel="noopener">https://www.csuldw.com/2016/03/26/2016-03-26-loss-function/</a>， 《统计学习方法》</p><h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>损失函数（loss function）是用来估计你的模型预测值$f(x)$与真实值Y的不一致程度，它是一个非负值函数，通常用$L(Y, f(x))$来表示，损失函数越小，模型的预测能力就越好。损失函数是<strong>经验风险函数的核心部分</strong>，也是<strong>结构风险函数</strong>重要的组成部分。</p><p>由于模型的输入输出(X, Y)是随机变量，符合联合分布P(X, Y), 所以损失函数的期望是：</p><script type="math/tex; mode=display">R_{exp}(f) = E_{p}[L(Y, f(x))] = \int_{X*Y} L(Y, f(x)) P(X,Y)</script><p>这是理论模型f(x)上的关于联合分布P(X,Y)的平均意义下的损失，成为风险函数或者期望损失。学习的目标就是要<strong>选择期望风险最小的模型</strong>。由于P(X, Y)是不知道的，实际上如果P(X, Y)是已知的我们就不用学习了，这个损失没有办法直接计算。所以我们采用f(x)下关于训练数据集的平均损失作为<strong>经验风险</strong>：</p><script type="math/tex; mode=display">R_{emp}(f) = \frac{1}{N}\sum_{i=1}^{N}L(y_i, f(x_{i}))</script><p>当样本容量无限扩大的时候，经验风险<script type="math/tex">R_{emp}</script>无限趋近于期望风险<script type="math/tex">R_{exp}</script>。</p><p>但是当样本容量很小的时候，经验风险最小化的学习效果就不会很好，很可能会产生过拟合（over-fitting）的状况。这时我们采用<strong>结构风险最小化</strong>来防止过拟合。结构风险最小化等价于<strong>正则化</strong>：</p><script type="math/tex; mode=display">R_{srm}(f) = \frac{1}{N}\sum_{i=1}^{N}L(y_{i}, f(x_{i})) + \lambda J(f)</script><p>其中$J(f)$表示的是模型的复杂度，是定义在假设空间F上的泛函。复杂度表示了对复杂模型的惩罚。结构风险小需要经验风险与模型复杂度同时小。<strong>结构风险小的模型往往对训练数据以及未知的测试数据都有较好的预测。</strong></p><h3 id="1-log对数损失函数（logistic-regression）"><a href="#1-log对数损失函数（logistic-regression）" class="headerlink" title="1.log对数损失函数（logistic regression）"></a>1.log对数损失函数（logistic regression）</h3><p><strong>首先</strong>，logistic regression的损失函数不是平方损失。<br>在logistic regression中，它假设样本服从（0-1分布），然后求得满足该分布的似然函数，接着去对数求极值。logistic regression只是把极大化当做一种思想，从损失函数的视角来看，他就成了log损失函数。</p><ol><li>将特征线性求和，通过逻辑函数$g(z)$映射到0-1区间，作为假设函数来进行预测。<script type="math/tex; mode=display">g(z) = \frac{1}{1+e^{-z}}</script><script type="math/tex; mode=display">h_{\theta}(x) = g(\theta^{T}x) = \frac{1}{1+e^{-\theta^{T}x}}</script></li><li>假设样本服从0-1分布。<script type="math/tex; mode=display">P(y=1|x,\theta) = h_\theta(x)</script><script type="math/tex; mode=display">P(y=1|x,\theta) = 1-h_\theta(x)</script>也可以写成如下形式：<script type="math/tex; mode=display">P(y|x,\theta) = (h_\theta(x))^y(1-h_\theta(x))^{1-y}</script></li><li>对于训练数据集，假设是m个独立样本。那么损失函数定义为：<script type="math/tex; mode=display">L(\theta) = P(Y|X,\theta) = \prod_{i=1}^{m}P(y_i|x_i,\theta) = \prod_{i=1}^{m} (h_\theta(x))^y(1-h_\theta(x))^{1-y}</script></li></ol><p>这才是原始的logistic regression的损失函数。要对这个损失函数求一阶导数很困难（连乘）。所以我们对该损失函数取log，并没有改变函数的单调性，但是转化成了加法，容易求导。于是：</p><script type="math/tex; mode=display">l(\theta) = log L(\theta) = \sum_{i=1}^{m}y^{(i)}log(h_\theta(x^{(i)})) + (1-y^{(i)})log(1-h_\theta(x^{(i)}))</script><p><strong>log损失函数的标准形式</strong>:</p><script type="math/tex; mode=display">L(Y, P(Y|X)) = -logP(Y|X)</script><p>该损失函数表示，利用已知的样本分布，找到最有可能导致这种分布的参数值，或者说什么样的参数才能使我们观测到目前这组数据的概率最大。本质上是最大似然估计。</p><p>我们可以看出当P(Y|X)趋近于0的时候，损失函数趋近于无穷大，当P(Y|X)趋近于1的时候，损失函数趋近于0。</p><h3 id="2-平方损失函数（最小二乘法，Ordinary-Least-Squares）"><a href="#2-平方损失函数（最小二乘法，Ordinary-Least-Squares）" class="headerlink" title="2. 平方损失函数（最小二乘法，Ordinary Least Squares）"></a>2. 平方损失函数（最小二乘法，Ordinary Least Squares）</h3><p>最小二乘法是线性回归的一种，最小二乘把线性回归转换成了一个凸优化问题。<strong>在线性回归中，他假设样本和噪声都服从高斯分布</strong>，最后通过极大似然估计可以推出最小二乘式。最小二乘的基本原则是：最优化拟合直线应该是是各点到回归直线的距离和最小的直线，即平方和最小。<strong>最小二乘法是基于距离的</strong>，一般我们用的最多的是欧几里得距离。使用欧式距离作为误差度量的原因如下：</p><ul><li>简单，计算方便</li><li>欧式距离是一种很好的相似性度量标准</li><li>在不同的表示域变换后特征性质不变</li></ul><p>标准形式为：</p><script type="math/tex; mode=display">L(Y, f(x)) = \sum_{i=1}^{m}(y^{(i)}-f(x^{(i)}))^2</script><h3 id="3-指数损失函数（Adaboost）"><a href="#3-指数损失函数（Adaboost）" class="headerlink" title="3. 指数损失函数（Adaboost）"></a>3. 指数损失函数（Adaboost）</h3><p>Adaboost是一种叠加模型，基本思想是：获得一个弱分类器比较容易，而每个弱分类器能够较好的分类一部分数据集，那么在每一轮改变训练数据的权值和概率分布，将生成的若干个弱分类器合并成一个强分类器。它是前向分步加法算法的特例，是一个加和模型，损失函数就是指数函数。<br>在Adaboost中，经过m次迭代后，可以得到:</p><script type="math/tex; mode=display">f_m(x) = f_{m-1}(x) + \alpha_mG_m(x)</script><p>Adaboost每次迭代的目的是为了找到最小化函数距离的参数$\alpha$和分类器$G_m$</p><script type="math/tex; mode=display">\mathop{\arg\min}_{\alpha,G_m} = \sum_{i=1}^{N}exp[-y^{(i)}(f_{m-1}(x^{(i)}) + \alpha G(x^{(i)}))]</script><p>为什么要采用exp指数形式？回到损失函数定义，它是一个非负值函数。</p><p>所以指数损失函数（exp-loss）标准形式为：</p><script type="math/tex; mode=display">L(y, f(x)) = exp[-yf(x)]</script><h3 id="4-Hinge损失函数（SVM）"><a href="#4-Hinge损失函数（SVM）" class="headerlink" title="4. Hinge损失函数（SVM）"></a>4. Hinge损失函数（SVM）</h3><p>在机器学习算法中，hinge损失函数和SVM息息相关。在SVM中，我们要找到支持向量，支持向量为到分类直线最近的点的距离向量。<br>在分类空间中，直线的法向量为$\omega$，截距为b,那么点到直线的距离为$(\omega\cdot x^{(i)} + b)$。我们要找到一条直线距离两个分类空间距离最大。</p><p>函数间隔 $\widehat{\gamma}_i = y_i(\omega \cdot x_i + b)$<br>归一化法向量$||\omega|| = 1$,得到几何间隔 $\gamma_i = \frac{\omega}{||\omega||}\cdot x_i + \frac{b}{||\omega||}$</p><p>所以优化问题变为了：（硬间隔）</p><script type="math/tex; mode=display">\begin{split}&\mathop{\max}_{\omega, b} \gamma\\&s.t. y_i (\frac{\omega}{||\omega||}\cdot x_i + \frac{b}{||\omega||}) \geqslant \gamma\end{split}</script><p>转换成函数间隔就变为了：</p><script type="math/tex; mode=display">\begin{split}&\mathop{\max}_{\omega, b} \frac{\widehat{\gamma}}{||\omega||}\\&s.t. y_i (\omega \cdot x_i +b) \geqslant \widehat{\gamma}\end{split}</script><p>这里函数间隔并不影响最终优化问题的解，它既不对优化问题产生影响，也不对约束产生影响。我们可以把这个函数间隔取为1.也就是将最近的分类点到直线的距离取为1.</p><p>则SVM硬间隔问题就转化为了:</p><script type="math/tex; mode=display">\begin{split}&\mathop{\min}_{\omega, b} \frac{1}{2}||\omega||^2\\&s.t. y_i (\omega \cdot x_i +b) - 1 \geqslant 0 \end{split}</script><p>硬间隔对于现行不可分训练数据是不使用的，因为无法使不等式约束始终成立。所以我们修改了函数间隔的约束条件，增加一个松弛变量。软间隔问题表示为：</p><script type="math/tex; mode=display">\begin{split}\mathop{\min}_{\omega, b}\ & \frac{1}{2}||\omega||^2 + C\sum_{i=1}^{N}\xi_i \\s.t.\ & y_i (\omega \cdot x_i +b) \geqslant 1-\xi_i, i = 1,2,...N \\& \xi_i \geqslant 0\end{split}</script><p>上述软间隔优化问题从损失函数的角度来看就是最小化hinge-loss:</p><script type="math/tex; mode=display">\mathop{\min}_{\omega, b}\sum_{i=1}^{N}[1-y_i(\omega\cdot x_i+b)]_+ + \lambda||\omega||^2</script><p>hinge-loss的基本形式就是：</p><script type="math/tex; mode=display">L(y(\omega\cdot x+b))=[1-y(\omega\cdot x + b)]_+</script><p>其中，</p><script type="math/tex; mode=display">[z]_+ = \begin{cases} z,& z>0\\0,& z\leqslant 0 \\\end{cases}</script><p>我的理解就是，当函数间隔大于1的时候，这是线性可分区域，这部分数据的惩罚为0.当函数间隔小于1的时候，这部分是软间隔，要加入惩罚。<br>值得注意的是$[-y(\omega\cdot x + b)]_+$是感知机的损失函数，也就是当函数距离为正，惩罚为0，当函数距离为负的时候，加入惩罚。在SVM中，加入支持向量的的归一化长度1，是表示不仅要分类正确，还要在可信度足够高的时候惩罚才为0。</p><p><strong>核函数补充：SVM对偶问题</strong><br>我们可以从原始间隔优化问题（包含约束条件的问题）加入拉格朗日函数呈现优化问题的对偶问题。<br>原始软间隔问题为：</p><script type="math/tex; mode=display">\begin{split}\mathop{\min}_{\omega, b}\ & \frac{1}{2}||\omega||^2 + C\sum_{i=1}^{N}\xi_i \\s.t.\ & y_i (\omega \cdot x_i +b) \geqslant 1-\xi_i, i = 1,2,...N \\& \xi_i \geqslant 0\end{split}</script><p>转换为拉格朗日函数为：</p><script type="math/tex; mode=display">L(\omega,b,\xi,\alpha,\mu) = \frac{1}{2}||\omega||^2 + C\sum_{i=1}^{N}\xi_i - \sum_{i=1}^{N}\alpha_i(y_i(\omega\cdot x_i+b)-1+\xi_i) - \sum_{i=1}^{N}\mu_i\xi_i</script><p>其中，$\alpha_i \geqslant 0, \mu_i \geqslant 0$</p><p>对偶问题就是拉格朗日函数的极大极小问题。对拉格朗日函数求一阶导数，得到</p><script type="math/tex; mode=display">\mathop{\min}_{\omega, b, \xi}\ L(\omega, b, \xi, \alpha, \mu) = -\frac{1}{2} \sum_{i=1}^{N}\sum_{j=1}^{N}\alpha_i \alpha_j y_i y_j (x_i \cdot x_j) + \sum_{i=1}^{N}\alpha_i</script><p>再对$\alpha$求极大，得到对偶问题。</p><script type="math/tex; mode=display">\begin{align}\mathop{\max}_{\alpha}\ & -\frac{1}{2} \sum_{i=1}^{N}\sum_{j=1}^{N}\alpha_i \alpha_j y_i y_j (x_i \cdot x_j) + \sum_{i=1}^{N}\alpha_i \\s.t.\ & \sum_{i=1}^{N} \alpha_i y_i = 0 \\& 0 \leqslant \alpha_i \leqslant C, i = 1,2,...,N\\\end{align}</script><p><strong>什么是核函数？</strong><br>设$\mathcal{X}$是输入空间，$\mathcal{H}$为特征空间（希尔伯特空间，完备的内积空间）。如果存在一个从$\mathcal{X}$到H的映射：</p><script type="math/tex; mode=display">\phi(x): \mathcal{X} \rightarrow \mathcal{H}</script><p>是的对于所有的$x, z \in \mathcal{X}$, 函数$K(x, z)$满足条件（内积运算）</p><script type="math/tex; mode=display">K(x, z) = \phi(x) \cdot \phi(z)</script><p>则称$K(x, z)$为核函数，$\phi(x)$为映射函数。</p><p>核技巧的想法是，在学习和预测中只定义核函数，而不现实地定义映射函数。通常直接计算核函数比较容易。这样上述对偶问题的优化函数就变成了特征空间中的最小化问题：</p><script type="math/tex; mode=display">\mathop{\min}_{\alpha} W(\alpha) = \frac{1}{2} \sum_{i=1}^{N}\sum_{j=1}^{N}\alpha_i \alpha_j y_i y_j K(x_i, x_j) - \sum_{i=1}^{N}\alpha_i</script><p><strong>什么是希尔伯特空间？</strong><br>$欧式空间 \rightarrow 线性空间 + 定义内积 \Rightarrow 内积空间$</p><ul><li>欧式空间是一个特别的度量空间。</li><li>度量空间是一个定义了距离函数的集合，该距离函数定义集合内所有元素之间的距离。该距离函数被称为集合的度量。欧式空间则是以欧几里得距离定义的度量空间。</li><li>线性空间（或向量空间），一个对加法和数乘封闭的集合。</li></ul><p>$内积空间 + 完备性 \Rightarrow 希尔伯特空间$</p><ul><li>在欧几里得空间（本身就是线性空间）上定义内积。<script type="math/tex; mode=display">\langle x, y \rangle = \sum_{k=1}^{n}\overline{x_k} y_k</script></li><li>序列空间，假设B是任意一个任意维数的集合，可以定义其上序列空间<script type="math/tex; mode=display">\ell^2(B) = \left\{x: B \to \mathbb{C}\  \mid \sum_{b \in B}|x(b)|^2 < \infty \right\}</script>在此空间下定义如下内积:<script type="math/tex; mode=display">\langle x,y \rangle = \sum_{b \in B} \overline{x(b)} y(b)</script>则构成一个希尔伯特空间。完备性是什么意思，就是该空间内所有的柯西序列等价于收敛序列。在完备空间中，所有的柯西数列都有极限，且极限在这个空间里。完备性保证了微积分中的大部分概念都在该空间中成立。</li></ul><h3 id="经典的损失函数对比"><a href="#经典的损失函数对比" class="headerlink" title="经典的损失函数对比"></a>经典的损失函数对比</h3><p><img src="/images/2019-10-10-机器学习损失函数/loss function.png" alt="损失函数"><br>不同的损失函数其实都在近似0-1损失函数，也就是图中的黑线。当函数距离为负的时候就增大panelty，为正的时候减小panelty。这就是损失函数在做的事情。</p><h3 id="5-交叉熵损失函数-（经常用在神经网络中）"><a href="#5-交叉熵损失函数-（经常用在神经网络中）" class="headerlink" title="5. 交叉熵损失函数 （经常用在神经网络中）"></a>5. 交叉熵损失函数 （经常用在神经网络中）</h3><p><strong>熵 entropy:</strong> 假设随机变量X的概率分布是P(X)，则其熵为：</p><script type="math/tex; mode=display">H(P) = -\sum_{x}P(x)logP(x) = \sum_{x}P(x)log\frac{1}{P(x)}</script><p>熵满足下列不等式</p><script type="math/tex; mode=display">0 \leqslant H(P) \leqslant log|X|</script><p>其中，|X|是X的取值个数，当且仅当X的分布式均匀分布时右边的等号成立，这就是说，当X服从均匀分布的时候，熵最大。信息量定义为</p><script type="math/tex; mode=display">I(x_0) = -log(p(x_0))</script><p>直觉上来讲，越不可能发生的事情发生了，信息量越大，越可能的事情发生了，我们获得的信息量越小。熵就是所有信息量的期望。</p><p><strong>相对熵：（KL散度）</strong> 设p(x), q(x)是X中取值的两个概率分布，则p对q的相对熵（离散事件）如下：</p><script type="math/tex; mode=display">D(p||q) = \sum_{x}p(x)log\frac{p(x)}{q(x)} = \sum_{x}p(x)log{p(x)} - \sum_{x}p(x)log{q(x)} = H_{p}(q) - H(p)</script><p>KL散度是两个概率分布P和Q差别的非对称性度量。KL散度是用来度量使用<strong>基于Q的分布来编码服从P的分布的样本所需的额外的平均比特数</strong>。一定程度上，相对熵可以度量两个随机变量的距离。并且有$D(p||q)\neq D(q||p)$。需要注意的是 $D(p||q)$一定是大于等于0的。<br>从上述公式中我们可以看出：</p><ul><li>如果p(x) = q(x)，则两个事件分布完全相同，那么KL散度为0</li><li>观察导出式发现，KL散度由p(x)自己的熵与q(x)信息量在p(x)上的期望共同决定。</li></ul><p><strong>互信息：</strong>两个随机变量X，Y的互信息定义为X，Y的联合分布和各自独立分布乘积的相对熵，用I(X,Y)表示：</p><script type="math/tex; mode=display">I(X,Y) = \sum_{x, y}p(x, y)log\frac{p(x,y)}{p(x)p(y)} = D(p(x,y) || p(x)p(y))</script><p>接下来计算</p><script type="math/tex; mode=display">\begin{align}& H(Y) - I(X,Y) \\& = -\sum_{y}p(y)log{p(y)} - \sum_{x,y}p(x,y)log{\frac{p(x,y)}{p(x)p(y)}} \\& = -\sum_{y}(\sum_{x}p(x,y))log{p(y)} - \sum_{x,y}p(x,y)log{\frac{p(x,y)}{p(x)p(y)}} \\& = -\sum_{x,y} p(x,y)log{\frac{p(x,y)}{p(x)}} \\& = -\sum_{x,y} p(x,y)log{p(y|x)} \\& = H(Y|X)\end{align}</script><p><strong>交叉熵：</strong> 交叉熵与KL散度的公式非常接近。假设有两个分布p,q, 则它们在给定样本集上的交叉熵定义如下：</p><script type="math/tex; mode=display">CEH(p,q) = E_p[-log{q}] = -\sum_{x \in \mathcal{X}} p(x)log{q(x)} = H(p) + D_{KL}(p||q)</script><p>可以看出交叉熵与相对熵仅相差了p本身的熵H(p)。当p已知的时候，可以把H(p)看做一个常数，此时交叉熵与KL散度在行为上是等价的，都反应了分布p，q的相似程度。交叉熵越小，说明两个概率分布越相近。</p><p>特别的，在logistic regression中<br>p：真实样本分布，服从参数为p的0-1分布，即$X \sim B(1, p)$<br>q：待估计的模型，服从参数为q的0-1分布，即$X \sim B(1, q)$<br>单个样本两者的交叉熵为：</p><script type="math/tex; mode=display">\begin{align}CEH(p,q) & = -\sum_{x \in \mathcal{X}} p(x) log{q(x)} \\& = -[P_p(x=1)log{P_q(x=1)} + P_p(x=0)log{P_q(x=0)}] \\& = -[plogq + (1-p)log(1-q)] \\& = -[ylogh_\theta(x) + (1-y)log(1-h_\theta(x))]\end{align}</script><p>对所有的训练样本取均值就可以得出与最大似然估计取log方法求出的结果一致。</p><p><strong>在神经网络中处理多分类问题：</strong></p><ul><li>神经网络的原始输出（也就是结点的直接输出结果）不是一个概率值，实质上只是输入的数值做了复杂的加权和非线性处理之后的值，那么如何将这个输出变为概率分布，一般会采用softmax和sigmoid做激活处理。</li><li>对于多分类问题，采用<strong>softmax函数</strong>，原始输出为y1, y2, …yn. 经过softmax处理之后输出为：  </li></ul><script type="math/tex; mode=display">softmax(y_i) = \frac{e^{y_i}}{\sum_{i=1}^{n}e^{y_i}}</script><p>经过softmax的交叉熵也被成为softmax损失函数，它的表达式为：</p><script type="math/tex; mode=display">H(P,T) = -\sum_{1}^{C}p log(T)</script><p>其中P为样本期望输出，它是一个one-hot编码形式，T为样本的实际输出，其中T为$[softmax(y1), softmax(y2)…]$ </p><ul><li>对于单节点二分类问题，采用<strong>sigmoid函数</strong>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试C++总结</title>
      <link href="/2019/10/10/2019-10-10-%E9%9D%A2%E8%AF%95C-%E6%80%BB%E7%BB%93/"/>
      <url>/2019/10/10/2019-10-10-%E9%9D%A2%E8%AF%95C-%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>总结C++面试知识点，以及在刷题过程中发现的点。</p><h3 id="1-静态变量static的作用"><a href="#1-静态变量static的作用" class="headerlink" title="1. 静态变量static的作用"></a>1. 静态变量static的作用</h3><p>C/C++程序经过编译链接之后形成的二进制映像文件，这些文件包含：堆，栈，数据段（也叫静态存储区）和代码段。其中堆和栈为动态区域，数据段和代码段为静态区域</p><ol><li>栈区stack：由编译器自动分配释放，存放函数的参数值，局部变量等值。随着作用域而进栈出栈。最大占空间默认是1M，不过可以调整。</li><li>堆区heap：允许程序在运行时动态申请某个大小的内存。注意这个区域一般由程序员来维护（malloc和free）。如果不进行释放，很可能会造成内存泄露。</li><li>数据段：由三部分组成。<strong>只读数据段</strong>是程序中使用的一些不会被更改的数据，一般由const修饰的变量，以及程序中使用的文字常量。<strong>已初始化的读写数据段</strong>，已初始化数据是在程序中声明，并且具有初值的变量，主要为已初始化的全局变量和已初始化的静态局部变量（static修饰）。<strong>未初始化段</strong>存放程序中未初始化的全局变量和静态变量。</li><li>代码段：存放函数体的二进制代码，所有语句编译后会生成CPU指令存储在代码区。</li></ol><p><strong>new/delete和malloc/free的区别</strong><br>new/delete 是c++的关键字，而malloc/free是c语言的库函数。后者的使用必须指明申请内存空间的大小，对于class类型的对象，或者不会调用构造函数和析构函数。前者会调用构造函数，不用指定内存大小，返回的指针不用强转。</p><p>所以由static修饰的变量会存放在<strong>静态存储区</strong>，在整个程序中一直存在。</p><ul><li>对<strong>全局变量</strong>，静态全局变量在声明他的文件之外是不可见的，准确的说就是从定义之处开始到文件结尾。但运行过程中一直占用内存。</li><li>对<strong>局部变量</strong>，作用域为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。一样，当结束作用域的时候并没有销毁，只是不能进行访问。</li><li>对<strong>静态函数</strong>。函数的定义和声明在默认情况下都是extern的。但静态函数只在声明它的文件中可见，不能被其他文件使用，不会与其他文件中的同名函数引起冲突。</li><li><strong>类的静态成员</strong>。在类中，静态成员可以实现多个对象之间的数据共享。注意类的静态成员，不是对象成员，多个对象中的数据成员只存储一个，供所有对象使用。引用不需要用对象名。</li><li><strong>类的静态函数</strong>。与类的静态数据成员一样，不是对象成员。在静态成员函数的实现中不能直接引用类中说明的非静态成员，但可以引用类中说明的静态成员。因为非静态成员要通过对象来引用。</li></ul><p><strong>注意</strong>，在刷题过程中发现，STL中的sort函数，如果要使用自定义cmp函数，这个cmp函数需要是静态的或者是全局的。如果是自己写main函数，可以在main函数之外定义全局cmp函数，如果是在class中写成员函数，就需要加static修饰cmp函数（也就是类的静态函数）。</p><h3 id="2-C-中指针和引用的区别"><a href="#2-C-中指针和引用的区别" class="headerlink" title="2. C++中指针和引用的区别"></a>2. C++中指针和引用的区别</h3><p>引用变量是一个别名，也就是说，它是某个已经存在变量的另一个名字。它必须连接到一块合法的内存。这也就是为什么引用必须在创建时初始化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int i = 17;</span><br><span class="line">int&amp; r = i; //这里r是一个初始化为i的整数引用。当改变r的值的时候，同时会改变i的值。</span><br></pre></td></tr></table></figure></p><ol><li>指针本身占有一个4个字节的空间，而引用只是一个别名。使用sizeof看一个指针，返回4；看一个引用，返回的是被引用对象的大小。</li><li>指针可以被初始化为NULL，而引用必须初始化而且必须是一个已有对象的引用（比如0）。</li><li>作为参数传递的时候，指针需要被解引用（*操作）才能对对象进行操作；直接对引用的修改都会改变引用所指对象。</li><li>可以用const指针，但没有const引用。</li><li>指针在使用中可以指向其他对象，但是引用只能是一个对象的引用，不能被改变。</li><li>指针可以有多级指针（**p）,而引用最多一级。</li><li>指针和引用使用++运算符的意义不一样，指针++是指向下一个内存地址。引用则是在该内存表示的变量上加1。</li><li>如果返回动态内存分配的对象或内存，必须使用指针，引用可能引起内存泄露。但在函数中可以通过引用来动态改变动态内存中的值，函数声明为void。即void function(int&amp; a){}</li></ol><h3 id="3-const关键字"><a href="#3-const关键字" class="headerlink" title="3. const关键字"></a>3. const关键字</h3><p>const在C++中用来修饰内置类型变量，自定义对象，成员函数，返回值，函数参数。const允许指定一个语义约束，编译器会强制实施这个约束，允许程序员告诉编译器某个值是保持不变的。相对应的volatile关键字跟const相反，是易变的，不会被编译器优化。</p><ol><li><p>const修饰普通类型变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const int a = 8;</span><br><span class="line">int b = a; //这个操作是拷贝。</span><br><span class="line">a = 7; //错误，不能改变</span><br></pre></td></tr></table></figure></li><li><p>const修饰指针</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//A. const修饰指针指向的内容，则内容为不可变量。</span><br><span class="line">const int *p = 8; //指针指向的内容8不可变</span><br><span class="line">//B. const修饰指针，指针为不可变量，也就是说指针的地址不可变，但是地址中存储的值可以变。这个指针无法进行++操作。</span><br><span class="line">int a = 8;</span><br><span class="line">int* const p = &amp;a;</span><br><span class="line">*p = 9; //正确</span><br><span class="line">int b = 7;</span><br><span class="line">p = &amp;b; //错误</span><br><span class="line">// C. const 修饰指针和指针所指向的内容，则指针和指针指向的内容都不可变。</span><br><span class="line">const int * const p = &amp;a;</span><br></pre></td></tr></table></figure><ol><li>const 参数传递和函数返回值。<br><strong>参数传递：</strong><br>A. 函数值传递，一般不需要const修饰，因为函数会自动产生临时变量复制实参数。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void function(const int a)&#123;</span><br><span class="line">    cout &lt;&lt; a;</span><br><span class="line">    //++a; 是错误的因为a不能被改变；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>B. 当const参数为指针时，可以防止指针被意外篡改。<br>C. 自定义类型的参数传递，采用const加引用。这样防止对引用参数进行更改。<br><strong>函数返回值：</strong><br>A. const修饰内置类型的返回值，修饰和不修饰返回值作用一样<br>B. const修饰自定义类型作为返回值，返回的值不能作为左值使用，既不能被赋值，也不能被修改</p><ol><li>const修饰类成员函数</li></ol><p>const修饰类成员函数，目的是防止成员函数修改被调用对象的值，如果我们不想修改一个调用对象的值，那么成员函数都应当声明为const成员函数。 <code>void function() const</code></p><p><strong>常量定义</strong>：常量在c++里定义就是一个top-level const加上对象类型，常量定义必须初始化。对于局部对象，常量存放在栈区；对于全局对象，常量存放在全局、静态存储区。对于字面值常量，常量存放在常量存储区。注意与static区分，static修饰的变量都存放在静态存储区。</p><h3 id="4-C-中smart-pointer的四个智能指针：shared-ptr-unique-ptr-weak-ptr-auto-ptr"><a href="#4-C-中smart-pointer的四个智能指针：shared-ptr-unique-ptr-weak-ptr-auto-ptr" class="headerlink" title="4. C++中smart pointer的四个智能指针：shared_ptr, unique_ptr, weak_ptr, auto_ptr"></a>4. C++中smart pointer的四个智能指针：shared_ptr, unique_ptr, weak_ptr, auto_ptr</h3><p>智能指针的作用是管理一个指针，因为存在以下情况：申请的空间在函数结束时忘记释放，造成内存泄露。智能指针本身是一个类，当超出了类的作用域时，类会自动调用析构函数，释放资源。</p><ol><li><p>auto_ptr (C++98的方案，cpp11已经抛弃) 采用所有权模式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">auto_ptr&lt; string&gt; p1 (new string (&quot;I reigned lonely as a cloud.”));</span><br><span class="line">auto_ptr&lt;string&gt; p2;</span><br><span class="line">p2 = p1; //auto_ptr不会报错.</span><br><span class="line">//但是当程序访问p1将会报错，所以缺点是存在潜在的内存奔溃问题。</span><br></pre></td></tr></table></figure></li><li><p>unique_ptr（替换auto_ptr）<br>实现独占拥有概念，保证同一时间内只有一个只能指针可以指向该对象。</p></li><li>shared_ptr<br>实现共享概念，多个智能指针可以指向相同对象，该对象和相关资源会在”最后一个引用被销毁“时释放。通过成员函数use_count()来查看资源的所有者个数。</li><li>weak_ptr<br>是一种不控制对象声明周期的智能指针，它指向一个shared_ptr管理的对象，weak_ptr只提供了对管理对象的一个访问手段。weak_ptr对象的构造，他的构造和析构不会引起引用计数的增加或减少。</li></ol><p><strong>智能指针有没有内存泄露的情况</strong><br>当两个对象相互使用一个shared_ptr成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄露。<br>为了解决循环引用导致的内存泄露，引入了weak_ptr，weak_ptr的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但不指向引用计数的共享内存。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class B; //类声明</span><br><span class="line">class A&#123;</span><br><span class="line">    public:</span><br><span class="line">    shared_ptr&lt;B&gt; pb_; //循环引用1</span><br><span class="line">    ~A()</span><br><span class="line">    &#123;</span><br><span class="line">    cout&lt;&lt;&quot;A delete\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class B&#123;</span><br><span class="line">    public:</span><br><span class="line">    shared_ptr&lt;A&gt; pa_; //循环引用2</span><br><span class="line">    ~B()</span><br><span class="line">    &#123;</span><br><span class="line">    cout&lt;&lt;&quot;B delete\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">void fun()</span><br><span class="line">&#123;</span><br><span class="line">    shared_ptr&lt;B&gt; pb(new B());</span><br><span class="line">    shared_ptr&lt;A&gt; pa(new A());</span><br><span class="line">    pb-&gt;pa_ = pa;</span><br><span class="line">    pa-&gt;pb_ = pb;</span><br><span class="line">    cout&lt;&lt;pb.use_count()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;pa.use_count()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    fun();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行fun()到use_count()的时候，每个类的引用次数都为2。出了作用域后，指针引用减1，两个指针的引用次数都不会为0。但如果我们吧class A中的shared_ptr改为weak_ptr，这样的话pb.use_count()只会有1，出了作用域之后，pb引用次数降为0，得到释放，B的释放也会导致A的计数减1，同时A得到释放。</p><p>注意我们不能通过weak_ptr直接访问对象的方法。需要通过weak_ptr.lock()先转化为shared_ptr再进行访问。</p><h3 id="5-虚函数"><a href="#5-虚函数" class="headerlink" title="5. 虚函数"></a>5. 虚函数</h3><p>C++类的实质就是struct，struct与class的区别就在于class允许了继承和虚函数。也就是说struct缺少的就是虚函数。</p><ol><li>定义一个函数为<strong>虚函数virtual</strong>并不代表函数不被实现。定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。</li><li>定义一个函数为<strong>纯虚函数virtual void function（）=0</strong> 才代表函数没有被实现。定义纯虚函数是为了实现一个借口，起到一个规范的作用。规范继承这个类的程序员必须实现这个函数。定义了纯虚函数的类是抽象类，不能生成对象，只能派生。定义纯虚函数就是为了让基类不可实例化。纯虚函数的引入为了安全，也为了效率（程序执行效率和编码效率）</li></ol><p>虚函数的作用就在于”推迟联编“。一个类函数的调用并不是在编译时刻被确定的，而是在运行时刻被确定的。由于在编写代码的时候并不能确定被调用的是基类函数还是哪个派生类的函数，所以被定义为”虚函数“。<strong>虚函数只能借助指针或者引用来达到多态的效果。</strong></p><p>每个类都会维护一张虚表，编译时，编译器根据类的声明创建续表，当对象被构造的时候，虚表的地址就会被写入这个对象内存的起始位置。当通过指针或引用调用一个虚函数时，先找到虚函数表，然后根据这个虚函数在虚表中的偏移量找到正确的函数地址，再执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class A  </span><br><span class="line">&#123;  </span><br><span class="line">public:  </span><br><span class="line">    virtual void foo()  </span><br><span class="line">    &#123;  </span><br><span class="line">        cout&lt;&lt;&quot;A::foo() is called&quot;&lt;&lt;endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">class B:public A  </span><br><span class="line">&#123;  </span><br><span class="line">public:  </span><br><span class="line">    void foo()  </span><br><span class="line">    &#123;  </span><br><span class="line">        cout&lt;&lt;&quot;B::foo() is called&quot;&lt;&lt;endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">int main(void)  </span><br><span class="line">&#123;  </span><br><span class="line">    A *a = new B();  //基类指针指向子类</span><br><span class="line">    a-&gt;foo();   // 在这里，a虽然是指向A的指针，但是被调用的函数(foo)却是B的!  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：wuxinliulei</span><br><span class="line">链接：https://www.zhihu.com/question/23971699/answer/69592611</span><br><span class="line">来源：知乎</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h3 id="6-重载和重写-（c-的多态）"><a href="#6-重载和重写-（c-的多态）" class="headerlink" title="6. 重载和重写 （c++的多态）"></a>6. 重载和重写 （c++的多态）</h3><p><strong>重载（静态多态）</strong>：两个函数名相同，但是参数列表不同，返回值类型没有要求，在同一作用域中。本质上是两个函数。<br>构成函数重载要满足以下几个条件：1. 作用域相同；2.函数名相同；3. 参数列表不同。（参数个数，参数类型或参数顺序不同，包括返回参数）<br><strong>重写（动态多态）</strong>：子类继承了父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数。这种情况是重写。</p><p><strong>静态函数和虚函数的区别</strong>：静态函数在编译时就已经确定了运行时机，虚函数在运行的时候动态绑定。虚函数因为使用了虚函数表机制，调用的时候会增加一次内存开销，降低效率。</p><h3 id="7-STL容器"><a href="#7-STL容器" class="headerlink" title="7. STL容器"></a>7. STL容器</h3><div class="table-container"><table><thead><tr><th>容器</th><th>底层实现</th><th>功能支持</th></tr></thead><tbody><tr><td>vector</td><td>数组，一倍数组长度增加，内存中是连续的存储</td><td>支持快速随机访问</td></tr><tr><td>list</td><td>双向链表，在内存中并不是连续存储</td><td>只是快速增删</td></tr><tr><td>deque</td><td>双向队列，</td><td>支持首尾增删，也支持随机访问</td></tr><tr><td>stack</td><td>底层一般用list或deque实现</td><td></td></tr><tr><td>queue</td><td>底层一般用list或deque实现</td><td></td></tr><tr><td>set</td><td>红黑树，有序</td><td>不重复</td></tr><tr><td>map</td><td>红黑树，有序</td><td>不重复</td></tr><tr><td>hash_set</td><td>hash表，无序</td><td>不重复</td></tr><tr><td>hash_map</td><td>hash表，无序</td><td>不重复</td></tr></tbody></table></div><ol><li>map和set有什么区别：</li></ol><ul><li>map和set都是c++的关联容器，底层实现都是红黑树。都能够实现自动排序。</li><li>map元素是key-value对，set就是关键字的简单集合。set中每个元素只包含一个关键字。</li><li>set的迭代器是const的，不允许修改元素的值；map允许修改value，但是不允许修改key。原因就是map和set是根据关键字排序来保证其有序性。</li><li>map支持下标操作，set不支持下标操作。不过，如果find能解决需要，尽可能用find。</li></ul><ol><li>STL迭代器删除元素：</li></ol><ul><li>对于序列容器vector，queue来说，使用erase(iterator)之后，后边的每个元素的迭代器都会失效，但是后边每个元素都会向前移动一个位置，但是erase会返回一个有效的迭代器；</li><li>对于关联容器map，set来说，使用erase后，当前元素的迭代器失效，删除当前元素不会影响到下一个元素的迭代器。</li><li>对于list，他使用了不连续分配的内存，并且他的erase方法也会返回下一个有效的iterator。</li></ul><ol><li>vector和list的区别：</li></ol><ul><li>vector：连续存储的容器，动态数组，在堆上分配连续内存空间。底层实现为数组。数组容量两倍长度增长。访问O(1)，尾部插入删除很快，中间插入删除需要进行数组拷贝。使用场景：经常随机访问，且不经常对非尾节点进行插入删除。</li><li>list：动态链表，在堆上分配不连续空间，每插入一个元素都会分配空间，每删除一个元素都会释放空间。插入删除很快，常数开销。使用场景：经常插入删除大量数据。</li></ul><h3 id="8-基本类型与存储大小"><a href="#8-基本类型与存储大小" class="headerlink" title="8. 基本类型与存储大小"></a>8. 基本类型与存储大小</h3><div class="table-container"><table><thead><tr><th>基本类型</th><th>存储大小（32位）/字节</th><th>存储大小（64位）/字节</th><th>取值范围(32位)</th></tr></thead><tbody><tr><td>char</td><td>1</td><td>1</td><td>-128 ~ 127</td></tr><tr><td>unsigned char (当byte用)</td><td>1</td><td>1</td><td>0 ~ 255</td></tr><tr><td>short</td><td>2</td><td>2</td><td>-32768 ~ 32767</td></tr><tr><td>unsigned short</td><td>2</td><td>2</td><td>0~65536</td></tr><tr><td>int</td><td>4</td><td>4</td><td>-2,147,483,648 ~ 2,147,483,647</td></tr><tr><td>unsigned int</td><td>4</td><td>4</td><td>0 ~ 4,294,967,295</td></tr><tr><td>long</td><td>4</td><td>8</td><td>–2,147,483,648 ~ 2,147,483,647</td></tr><tr><td>unsigned long</td><td>4</td><td>8</td><td>0 ~ 4,294,967,295</td></tr><tr><td>long long</td><td>8</td><td>8</td><td>-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807</td></tr><tr><td>指针</td><td>4</td><td>8</td><td></td></tr><tr><td>float</td><td>4</td><td>4</td><td>3.4E +/- 38 (7 digits)</td></tr><tr><td>double</td><td>8</td><td>8</td><td>1.7E +/- 308 (15 digits)</td></tr></tbody></table></div><p>注意浮点型数字不能使用==来判断是否相等，事实上上应该尽量避免判断浮点数是否相等，因为精度的问题，一般不能得到正确的结论，如果非要判断浮点数是否相等，可以判断两数的差是否小到可以忽略即可。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS Learning: Path Planing</title>
      <link href="/2019/10/09/ROS-Learning-Path-Planing/"/>
      <url>/2019/10/09/ROS-Learning-Path-Planing/</url>
      
        <content type="html"><![CDATA[<h3 id="EE3305-Experiment-2：-Path-planning-in-a-maze"><a href="#EE3305-Experiment-2：-Path-planning-in-a-maze" class="headerlink" title="EE3305 Experiment 2： Path planning in a maze"></a>EE3305 Experiment 2： Path planning in a maze</h3><h4 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a>Problem Statement</h4><p>In this lab, you are required to perform a simulation in the following situation:</p><ul><li>A robot is put at the original point (0, 0) in a 2D predefined maze. </li><li>The robot has no knowledge of the maze.</li><li>The robot is provided with a laser scan and an odometry data input.</li><li>Given the target coordinate, move the robot to the target position while avoid hitting the wall.</li></ul><h4 id="Environment-Required"><a href="#Environment-Required" class="headerlink" title="Environment Required"></a>Environment Required</h4><ol><li><p>Install turtlebot3 package:<br> <code>sudo apt-get install ros-[ros_version]-turtlebot-*</code></p><ul><li>The package will be installed under the default dir of ros</li><li>Check whether you can find the turtlebot3_gazebo: <code>rospack list | grep turtlebot3</code></li><li>Try to launch the turtlebot3 using one of the example launch file. <code>roslaunch turtlebot3_gazebo launchfile.launch</code></li><li>There should be an error indicating you need to configure the turtlebot3 model by adding an environment variable. Here we use the “burger”. <code>export TURTLEBOT3_MODE=&quot;burger&quot;</code>.</li><li>Check the nodes currently running. Check the topics and msgs currently published. Using cmd <code>rostopic list</code>, <code>rostopic info [topic_name]</code>, <code>rostopic echo [topic_name]</code>, <code>rosmsg info [msgs_name]</code>.</li><li>The laser scan data input is provided with <code>/scan</code> topic. The odometry data input is provided with <code>/odom</code> topic. The to control turtlebot, publish on the <code>/cmd_vel</code> to configure the velocity.</li><li><p>Check the msgs definition, and the topics content.</p><p><strong>[Q1]</strong> Please find out the angle range (in degree), angle scan increment, and find out the direction of the 0, 1/4*data_size, 1/2*data_size data point with respect to the robot coordinate system.</p><p><strong>[Q2]</strong> Please find out how the odometry information is defined, and write down the equation of transforming the odometry data to position and euler angle under the world coordinate system. (Given that the robot will not have z direction movement nor rotation along x axis and y axis.)</p></li></ul></li><li><p>If you get some errors when launching the environment, update gazebo9. Find it in Trouble Shooting.</p></li><li><p>Launch the turtlebot in the predefined maze. The maze file is provided in under <code>/worlds/test_world_1.world</code>.</p><ul><li>Write your launch file. (This can be done by changing the world file in previous example launch file)</li><li>Write shell to configure the robot initial orientation and position. Note that, in ubuntu, after you write down a shell program, you need to configure it as a executable file before you can run it. You can use <code>ls -ll</code> to find out the current state of your file. You can use <code>chmod 777 file.sh</code> to guarantee a file with 777 permission(read (r), write (w) and execute (x)).</li><li>The launch environment should be as follows:</li></ul></li></ol><p><img src="/images/ROS-Learning-Path-Planing/lab2_launch_environment.png" alt="lab2_launch_environment"></p><h4 id="Structure-Design"><a href="#Structure-Design" class="headerlink" title="Structure Design"></a>Structure Design</h4><p>The task can be broken down into three parts: first, the robot needs to get the information of the map, specifically, where are the walls; second, the robot needs to find the shortest path heading based on the current map information, which can be performed using dijkstra algorithm or other path finding algorithm, and the robot needs to decided where is the next heading target at the current position; third, the robot needs to implement a pid control to move itself steadily towards the heading target. This process will go over and over again until the robot reaching the final target. Each part can be written as a node.</p><h5 id="1-Perception-Node"><a href="#1-Perception-Node" class="headerlink" title="1. Perception Node"></a>1. Perception Node</h5><p>This node is input with the laser scan data and the odometry data to detect the wall within the current cell. Pass the detected range to decision making node. </p><p><strong>[Q3]</strong> Because the laser scan data is taken under the robot coordinate system, the map needed to be construct is under the world coordinate system. Given the odometry information and the laser scan data, how can you find out whether this is a wall in North, South, East, or West of the current cell the robot locates at. Please write down the equation.</p><h5 id="2-Decision-Node"><a href="#2-Decision-Node" class="headerlink" title="2. Decision Node"></a>2. Decision Node</h5><ul><li>Maintain and update the map of the maze using the wall detection from Perception Node and localization from Odometry. </li><li>Using Dijkstra Algorithm to find the path with minimum length to the target. </li><li>Decide the next cell the robot needs to heading. Pass the decision (the next heading target) to Control Node.</li></ul><h5 id="3-Control-Node"><a href="#3-Control-Node" class="headerlink" title="3. Control Node"></a>3. Control Node</h5><p>Receives next heading cell from the decision node. Use PID Control to stabilize the robot movement.</p><h4 id="Example-Steps"><a href="#Example-Steps" class="headerlink" title="Example Steps:"></a>Example Steps:</h4><h5 id="1-Build-the-example-package-using-catkin"><a href="#1-Build-the-example-package-using-catkin" class="headerlink" title="1. Build the example package using catkin"></a>1. Build the example package using catkin</h5><h5 id="2-Launching-the-environment"><a href="#2-Launching-the-environment" class="headerlink" title="2. Launching the environment"></a>2. Launching the environment</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ee3305_path_plan_v2/bin</span><br><span class="line">./melodic_project_init_world_1.sh</span><br></pre></td></tr></table></figure><p>And wait until the gazebo shows the maze and the robot</p><h5 id="3-Launching-all-the-nodes"><a href="#3-Launching-all-the-nodes" class="headerlink" title="3. Launching all the nodes"></a>3. Launching all the nodes</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roslaunch ee3305_path_plan_v2 start_all_nodes.launch</span><br></pre></td></tr></table></figure><h4 id="Trouble-shooting-in-melodic"><a href="#Trouble-shooting-in-melodic" class="headerlink" title="Trouble shooting in melodic"></a>Trouble shooting in melodic</h4><p>When installing the turtlebot3 package, there might be some situation occurs. Here are some trouble shooting solutions:</p><ol><li><p><strong>[Problem]</strong>There are a lot of pkgs showing error “can not find resources”<br><strong>[Ans]</strong> <a href="https://answers.ros.org/question/325039/apt-update-fails-cannot-install-pkgs-key-not-working/" target="_blank" rel="noopener">https://answers.ros.org/question/325039/apt-update-fails-cannot-install-pkgs-key-not-working/</a><br>This is because we are using the old public key to fetching the updated resource. We need to update the public key.</p></li><li><p><strong>[Proble]</strong>Gazebo crashing when launching the navigation node<br><strong>[Ans]</strong> <a href="https://stackoverflow.com/questions/55181205/gazebo-crashing-when-subscribing-to-scan" target="_blank" rel="noopener">https://stackoverflow.com/questions/55181205/gazebo-crashing-when-subscribing-to-scan</a><br>This should be gazebo version problem. Update the gazebo 7 should be good.<br>Just update gazebo using <code>sudo apt-get upgrade gazebo9</code></p></li><li><p><strong>[Error]</strong>E: Could not get lock /var/lib/dpkg/lock-frontend - open (11: Resource temporarily unavailable)<br>E: Unable to acquire the dpkg frontend lock (/var/lib/dpkg/lock-frontend), is another process using it?<br><strong>[Solution]</strong> Type all the following cmds to fix the problem.<br>sudo killall apt apt-get<br>sudo rm /var/lib/apt/lists/lock<br>sudo rm /var/cache/apt/archives/lock<br>sudo rm /var/lib/dpkg/lock*<br>sudo dpkg —configure -a<br>sudo apt update</p></li><li><p><strong>[Error]</strong> libcurl: (51) SSL: no alternative certificate subject name matches target host name ‘api.ignitionfuel.org’<br><strong>[Solution]</strong> You need to change ~/.ignition/fuel/config.yaml as following.<br> <code>url: https://api.ignitionfuel.org</code><br>to<br> <code>url: https://api.ignitionrobotics.org</code></p></li><li><p><strong>[Error]</strong> gazebo has died when launching the gazebo.<br><strong>[Solution]</strong> Terminate the current process and restart the gazebo again.<br>If the process still died. Check <code>gazebo --verbose</code> which will provide more information about the running status of gazebo. And here is what I see:<br><code>Error: there is another gazebo process running.</code><br>But there seems no other gazebo process I have started, which means, some process is taking the gazebo server all the time. Use <code>killall gzserver</code>, to kill all the process, and restart the gazebo.</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> NUS Student Manual </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS Project: PID Control</title>
      <link href="/2019/10/09/ROS-Project-PID-Control/"/>
      <url>/2019/10/09/ROS-Project-PID-Control/</url>
      
        <content type="html"><![CDATA[<h3 id="EE3305-Experiment-1-PID-Control"><a href="#EE3305-Experiment-1-PID-Control" class="headerlink" title="EE3305 Experiment 1: PID Control"></a>EE3305 Experiment 1: PID Control</h3><p>Useful Materials: <a href="https://rsl.ethz.ch/education-students/lectures/ros.html" target="_blank" rel="noopener">https://rsl.ethz.ch/education-students/lectures/ros.html</a></p><h4 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a>Problem Statement</h4><p>In this lab, you are required to perform a simulation in the following situation:</p><ul><li>A robot is put at the original position (0, 0).</li><li>A target (a pillar) is put at the target position (X, Y).</li><li>Implement a PID Controller to make the robot reach the target with a certain distance. The PID Controller subscribes the laser scan data to evaluate the position error, and publishes the next velocity parameter. </li></ul><h4 id="Environment-Required"><a href="#Environment-Required" class="headerlink" title="Environment Required"></a>Environment Required</h4><ol><li>Install ROS: follow the WiKi steps</li><li>Install catkin: follow the WiKi steps</li><li><p>Install husky simulator:</p><p> <a href="http://wiki.ros.org/husky_gazebo/Tutorials/Simulating%20Husky" target="_blank" rel="noopener">http://wiki.ros.org/husky_gazebo/Tutorials/Simulating%20Husky</a><br> <code>sudo apt-get install ros-&lt;distro&gt;-husky-simulator</code> change the <distro> to your ROS version.</distro></p><ul><li>The package will be installed under the default dir of ROS.</li><li>Check whether you can find the package husky_gazebo: <code>rospack list | grep husky</code></li><li>Try to launch the husky using one of the example launch file: <code>roslaunch husky_gazebo husky_empty_world.launch</code></li><li>Check the nodes currently running. Check the topics and msgs currently published. Using cmd <code>rostopic list</code>, <code>rostopic info [topic_name]</code>, <code>rostopic echo [topic_name]</code>, <code>rosmsg info [msgs_name]</code></li><li>The laser scan data input is provided with <code>/scan</code> topic. To control the robot, publish on the <code>/husky_velocity_controller/cmd_vel</code> to configure the velocity.</li><li><p>Check the msgs definition, and the topics content.</p><p><strong>[Q1]</strong> Please find out the angle range (in degree), angle scan increment of the laser scan data. How can you find the distance and orientation of the pillar (under the coordinate system of the robot)?</p></li></ul></li></ol><h4 id="Task-Goal"><a href="#Task-Goal" class="headerlink" title="Task Goal"></a>Task Goal</h4><h5 id="Step-1-Familiar-with-ROS-operation"><a href="#Step-1-Familiar-with-ROS-operation" class="headerlink" title="Step 1: Familiar with ROS operation:"></a>Step 1: Familiar with ROS operation:</h5><h5 id="1-1-create-a-catkin-package"><a href="#1-1-create-a-catkin-package" class="headerlink" title="1.1. create a catkin package"></a>1.1. create a catkin package</h5><ul><li>Create a source file folder <code>~/ROSLearning</code></li><li>cmd <code>catkin create pkg pid_control</code></li><li>A folder <code>pid_control</code> will be generated, with two files <code>CMakeLists.txt</code> and <code>package.xml</code></li><li>Create a soft link in <code>~/catkin_ws/src</code> using cmd <code>ln -s [source_dir]</code>. So that you don’t change anything in catkin_ws project, rather you write your code in your source folder.</li><li>You can build your package using cmd <code>catkin build [package_name]</code>. It is suggested to use build command rather than make command. You can also use cmd <code>catkin clean</code> to remove the previously generated file from the <code>catkin_ws/src</code>. After using the <code>catkin build</code> command, the project folder is like:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|-- catkin_ws</span><br><span class="line">    |--src : to include your source code</span><br><span class="line">    |--devel : generated settings, no touch</span><br><span class="line">    |--build : generated build files, no touch</span><br><span class="line">    |--logs : log file</span><br></pre></td></tr></table></figure><p><img src="/images/ROS-Project-PID-Control/package_build.png" alt="package_build"></p><h5 id="1-2-know-the-CMakeLists-txt"><a href="#1-2-know-the-CMakeLists-txt" class="headerlink" title="1.2. know the CMakeLists.txt"></a>1.2. know the CMakeLists.txt</h5><p><img src="/images/ROS-Project-PID-Control/CMakeLists_txt.png" alt="CMakeLists"><br>From <a href="https://rsl.ethz.ch/education-students/lectures/ros.html" target="_blank" rel="noopener">https://rsl.ethz.ch/education-students/lectures/ros.html</a></p><p>The <code>CMakelists.txt</code> controls the build process of your source code. So you need to make changes as you add source file into your project. The first goal is to generate the world and the robot you want to control. This can be done by adding the related module in the launch file.  </p><h5 id="1-3-know-the-package-xml"><a href="#1-3-know-the-package-xml" class="headerlink" title="1.3. know the package.xml"></a>1.3. know the package.xml</h5><p>The <code>package.xml</code> defines the properties of the package, especially the dependencies required to performing your node.</p><p>You can find all the built-in ros package using the cmd <code>rospack list</code>. Do remind that if the <code>rospack list</code> does not find the package you created, it is because you haven’t include the path to <code>$ROS_PACKAGE_PATH</code>. You can check the path using cmd <code>echo $ROS_PACKAGE_PATH</code>, if you can’t find the directory in your <code>catkin_ws/src</code>, you need to update the setup through:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">catkin_ws/devel $ source setup.bash</span><br></pre></td></tr></table></figure><h5 id="1-4-generate-a-world-and-a-robot"><a href="#1-4-generate-a-world-and-a-robot" class="headerlink" title="1.4. generate a world and a robot"></a>1.4. generate a world and a robot</h5><p>Launch file is a tool to start multiple nodes as well as setting parameters. A launch file is written in xml as <code>*.launch</code>.</p><p>Create a <code>launch</code> folder in you source directory, and create a launch file <code>pid_control.launch</code> as follows.</p><p><img src="/images/ROS-Project-PID-Control/launch file 1.png" alt="launch file 1"></p><p>So the above launch file, we include a world with directory <code>$(find ee3305_pid_control)/worlds/singlePillar.world</code>. <code>$(find ee3305_pid_control)</code> is shell cmd same as <code>rospack find ee3305_pid_control</code>. Create a worlds folder in your src directory and import the world file provided. A robot model is also included with directory <code>$(find husky_gazebo)</code> check this package by yourself. In the end we add a node to visualise the world and the robot.</p><p>First, start the roscore to manage all the system. cmd <code>roscore</code>, and leave it in an independent window.</p><p>Launch all the nodes using cmd <code>roslaunch [pkg_name] [launch_file_name]</code> or find the launch file directory cmd <code>roslaunch [launch_file_name]</code>.</p><p><img src="/images/ROS-Project-PID-Control/world_and_robot.png" alt="world and robot"></p><h5 id="1-5-check-the-topics-published"><a href="#1-5-check-the-topics-published" class="headerlink" title="1.5. check the topics published"></a>1.5. check the topics published</h5><ul><li>Use <code>rostopic list</code> to view all the topics</li><li>Use <code>rostopic echo [topic_name]</code> to view the msgs in the topic</li><li>Use <code>rostopic type [topic_name]</code> to view the type of msgs of the topic</li><li>Use <code>rostopic show [topic_name]</code> to view how the msgs are define (the structure of the msgs)</li></ul><p>Check the topic on <code>/scan</code> and <code>/husky_velocity_controller/odom</code>.</p><h4 id="Step-2-Create-your-node-with-pid-control"><a href="#Step-2-Create-your-node-with-pid-control" class="headerlink" title="Step 2: Create your node with pid control"></a>Step 2: Create your node with pid control</h4><p>Before you create your algorithm node, your project file should be like this:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|--pid_control</span><br><span class="line">    |--worlds : contains the singlePillar world </span><br><span class="line">    |--launch : contains the launch file</span><br><span class="line">    |--CMakeLists.txt</span><br><span class="line">    |--package.xml</span><br></pre></td></tr></table></figure><h5 id="2-1-Create-your-node"><a href="#2-1-Create-your-node" class="headerlink" title="2.1 Create your node"></a>2.1 Create your node</h5><ol><li>Create the <code>src</code> folder (store your processing code) and the <code>include</code> folder (store your header code)</li><li>Creating your code as provided</li><li><p><strong>Modify the CMakeLists.txt and package.xml</strong><br> The compile procedure:<br> <img src="/images/ROS-Project-PID-Control/HowToCompile.jpg" alt="how_to_compile"></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CMakeLists.txt</span><br><span class="line">-- find_package : tell catkin to find the required packages, </span><br><span class="line">-- catkin_package : add include_dirs, libraries, catkin_depends, depends</span><br><span class="line">-- add_executable : tell catkin the file you want to create the executable object</span><br><span class="line">-- target_link_libraries : link the relevant object file</span><br><span class="line"></span><br><span class="line">package.xml : indicate the dependencies your package required.</span><br></pre></td></tr></table></figure></li></ol><ol><li><p><strong>Modify the launch file</strong><br>Add <code>&lt;node&gt;</code> tag<br><code>&lt;node pkg=&quot;pkg_name&quot; type=&quot;executable_name&quot; name=&quot;node_name&quot; output=&quot;screen&quot;&gt;</code><br>pkg_name: The name when you use catkin create pkg<br>executable_name: The name in CMakeLists.txt add_executable<br>node_name: The name when you initialize a node using ros::init(“node_name”)</p></li><li><p><code>roslaunch</code> your launch file, and check the node has been launched. Use <code>rqt_graph</code> to check the topics that connects all the nodes.</p><p> <img src="/images/ROS-Project-PID-Control/nodes_graph.png" alt="nodes_graph"></p></li><li><p>Use <code>rqt_plot</code> to show the error in a new terminal window.<br><img src="/images/ROS-Project-PID-Control/error_forward.png" alt="error_forward"><br><img src="/images/ROS-Project-PID-Control/error_angle.png" alt="error_angle"></p></li><li><p>Change the gain of PID control in config.yaml, and check the difference.</p></li></ol><ul><li>Why do you need a config file? In PID control, you have some parameters to tune to achieve a good performance. Traditionally, the parameters are defined in the code, then once you change the parameter, you have to compile and build again. However, if you use a config file, your algorithm will first load the parameters from the config file when initializing the node rather than compile the code again.</li><li>config.yaml is just a text file, using <code>name: value</code> pair to indicate the parameters.</li><li>In your code, use the following example:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(!nodehandle_.getParam(&quot;/Kp_f&quot;, Kp_f))&#123;</span><br><span class="line">ROS_ERROR(&quot;Kp_f Load Error&quot;);</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> NUS Student Manual </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo主题设置</title>
      <link href="/2019/10/09/2019-10-09-hexo%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AE/"/>
      <url>/2019/10/09/2019-10-09-hexo%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>原本的主题比较丑，重新配置一下hexo主题，亲测在设置deploy key的情况下可以直接覆盖原来远程分支中的内容。</p><h3 id="1-hexo与github-Pages的关系"><a href="#1-hexo与github-Pages的关系" class="headerlink" title="1. hexo与github Pages的关系"></a>1. hexo与github Pages的关系</h3><p>使用<code>hexo init [folder_name]</code>创建一个网站后，会在相应的目录下生成如下结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/root</span><br><span class="line">|--_config.yml 主站设置</span><br><span class="line">|-- package.json</span><br><span class="line">|-- scaffolds</span><br><span class="line">|-- source 存放网站内容md文件</span><br><span class="line">    |--_posts</span><br><span class="line">|-- themes 存放主题，设置网站渲染</span><br><span class="line">    |--next</span><br><span class="line">        |-- _config.yml 主题设置</span><br></pre></td></tr></table></figure></p><p>相关配置完成之后（运行<code>hexo s</code>或<code>hexo g</code>或<code>hexo d</code>之后），目录呈现如下结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/root</span><br><span class="line">|--_config.yml 主站设置</span><br><span class="line">|-- package.json</span><br><span class="line">|-- package-lock.json</span><br><span class="line">|-- db.json</span><br><span class="line">|-- scaffolds</span><br><span class="line">|-- public 这个文件存放由原始md文档生成的html文档，也就是最终要推到github Pages的所有内容</span><br><span class="line">|-- source 存放网站内容md文件</span><br><span class="line">    |--_posts</span><br><span class="line">|-- themes 存放主题，设置网站渲染</span><br><span class="line">    |--next</span><br><span class="line">        |-- _config.yml 主题设置</span><br></pre></td></tr></table></figure></p><p>所以在本地仓库中保留着所有的以上目录，在远程github.io仓库只有public中的内容。</p><h3 id="2-hexo主站设置与主题设置"><a href="#2-hexo主站设置与主题设置" class="headerlink" title="2. hexo主站设置与主题设置"></a>2. hexo主站设置与主题设置</h3><h4 id="hexo主站设置"><a href="#hexo主站设置" class="headerlink" title="hexo主站设置"></a>hexo主站设置</h4><p>主要配置网站基本信息以及部署信息。最重要的是设置hexo一键部署deploy：<br>在deploy中填写:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:username/username.github.io.git</span><br><span class="line">  brance: master</span><br></pre></td></tr></table></figure></p><p>要使用hexo的一键部署，还需要在github.io仓库中添加deploy key。参考<a href="https://segmentfault.com/a/1190000005125610" target="_blank" rel="noopener">https://segmentfault.com/a/1190000005125610</a></p><ul><li>查看 <code>~/.ssh</code>，查看是否存在id_rsa.pub</li><li>使用ssh-keygen生成密钥 <code>ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</code></li><li>如果选用默认文件名保存就会保存在id_rsa中，简化可以不用加密码，全部enter通过</li><li>在github.io仓库中添加deploy key。“Settings-&gt;Deploy Keys-&gt;Add deploy key”</li><li><code>cat ~/.ssh/id_rsa.pub</code> 复制public key到仓库deploy key中</li><li>检查是否配置成功 <code>ssh -T git@github.com</code></li><li>如果出现以下就证明配置成功：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hi FloodShao/FloodShao.github.io! </span><br><span class="line">You&apos;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure><ul><li>之后使用<code>hexo d</code>对网站进行一键部署</li></ul><h4 id="主题设置"><a href="#主题设置" class="headerlink" title="主题设置"></a>主题设置</h4><p>主要是更改了如下几个地方：</p><ol><li>menu的改变：添加了categories, tags, about等菜单内容</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home</span><br><span class="line">  about: /about/ || user</span><br><span class="line">  tags: /tags/ || tags</span><br><span class="line">  categories: /categories/ || th</span><br><span class="line">  archives: /archives/ || archive</span><br><span class="line">  #schedule: /schedule/ || calendar</span><br><span class="line">  #sitemap: /sitemap.xml || sitemap</span><br><span class="line">  #commonweal: /404/ || heartbeat</span><br></pre></td></tr></table></figure><p>注意每添加一个菜单内容点进去都是一个page。需要在source中添加该页面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo new page &quot;categories&quot;</span><br><span class="line">INFO  Created: ~/GitHub/test/source/categories/index.md</span><br></pre></td></tr></table></figure><p>并修改index.md如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2019-10-09 14:41:11</span><br><span class="line">type: &quot;categories&quot; #这一行是添加的</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>也可以在下方添加内容，比如在about中添加相关信息。</p><ol><li>设置sidebar来实现每一篇post的目录显示等功能：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#添加社交网络</span><br><span class="line">social:</span><br><span class="line">  GitHub: https://github.com/floodshao || github</span><br><span class="line">  E-Mail: mailto:guoliang_shao@u.nus.edu || envelope</span><br><span class="line"></span><br><span class="line">#post目录显示</span><br><span class="line">sidebar:</span><br><span class="line">  # Sidebar Position, available value: left | right (only for Pisces | Gemini).</span><br><span class="line">  position: left</span><br><span class="line">  #position: right</span><br><span class="line"></span><br><span class="line">  # Sidebar Display, available value (only for Muse | Mist):</span><br><span class="line">  #  - post    expand on posts automatically. Default.</span><br><span class="line">  #  - always  expand for all pages automatically</span><br><span class="line">  #  - hide    expand only when click on the sidebar toggle icon.</span><br><span class="line">  #  - remove  Totally remove sidebar including sidebar toggle.</span><br><span class="line">  #display: post</span><br><span class="line">  display: always</span><br><span class="line">  #display: hide</span><br><span class="line">  #display: remove</span><br><span class="line"></span><br><span class="line"># 博客头像显示</span><br><span class="line">avatar: /images/avatar.png</span><br></pre></td></tr></table></figure><ol><li>博文设置：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 主目录设置自动隐藏内容</span><br><span class="line">auto_excerpt:</span><br><span class="line">  enable: true</span><br><span class="line">  length: 150</span><br></pre></td></tr></table></figure><ol><li>第三方库设置：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#使用latex渲染</span><br><span class="line">mathjax:</span><br><span class="line">  enable: true</span><br><span class="line">  per_page: false</span><br><span class="line">  cdn: //cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML</span><br></pre></td></tr></table></figure><h3 id="3-hexo部署"><a href="#3-hexo部署" class="headerlink" title="3. hexo部署"></a>3. hexo部署</h3><p><code>hexo s</code>查看生成本地网站，可以实时更新<br>远端部署首先要<code>hexo g</code> 生成所有的文件，然后在<code>hexo d</code>。</p><h3 id="4-hexo-中结合valine添加评论"><a href="#4-hexo-中结合valine添加评论" class="headerlink" title="4. hexo 中结合valine添加评论"></a>4. hexo 中结合valine添加评论</h3><ul><li>在LeanCloud中注册登录，并进行实名验证。<br><a href="https://leancloud.cn/dashboard/login.html#/signin" target="_blank" rel="noopener">LeanCloud官网登录入口</a></li><li>创建应用APP，获得AppID和AppKey</li><li>Next主题已经获得valine支持，所以在主题设置下进行配置：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Valine.</span><br><span class="line"># You can get your appid and appkey from https://leancloud.cn</span><br><span class="line"># more info please open https://valine.js.org</span><br><span class="line">valine:</span><br><span class="line">  enable: true # 是否开启</span><br><span class="line">  appid:                            # 填上之前获取的AppID</span><br><span class="line">  appkey:                           # 填上之前获取的AppKey</span><br><span class="line">  notify: false # 新留言是否需要通知 https://github.com/xCss/Valine/wiki</span><br><span class="line">  verify: false # 是否需要验证，验证比较反人类建议false关闭</span><br><span class="line">  placeholder: Just to go # 默认留言框内的文字</span><br><span class="line">  avatar: mm # 默认头像</span><br><span class="line">  guest_info: nick,mail # 默认留言框的头部需要访问者输入的信息</span><br><span class="line">  pageSize: 10 # pagination size #默认单页的留言条数</span><br></pre></td></tr></table></figure></li></ul><p>至此不用改变其他状态就可以添加评论，直接进行部署就可以了。</p><h3 id="5-latex公式渲染出现问题"><a href="#5-latex公式渲染出现问题" class="headerlink" title="5. latex公式渲染出现问题"></a>5. latex公式渲染出现问题</h3><p>更换 Hexo 的 markdown 渲染引擎，hexo-renderer-kramed 引擎是在默认的渲染引擎 hexo-renderer-marked 的基础上修改了一些 bug ，两者比较接近，也比较轻量级。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo 部署 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NewCoder刷题总结</title>
      <link href="/2019/09/16/2019-09-16-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>/2019/09/16/2019-09-16-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="关于输入输出"><a href="#关于输入输出" class="headerlink" title="关于输入输出"></a>关于输入输出</h3><ol><li>已知数组个数，输入数组</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; nums[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>输入两行数字，但是不知道个数</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums1;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; a)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">        nums1.push_back(a);</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        nums2.push_back(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar(); <span class="comment">//查看后边的字符输入是不是换行，如果是的话就换到下一行</span></span><br><span class="line">    <span class="keyword">if</span>(ch == <span class="string">'\n'</span>)&#123;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然还有第二种方法就是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> line;</span><br><span class="line">getline(<span class="built_in">cin</span>, line);</span><br><span class="line"><span class="function"><span class="built_in">istringstream</span> <span class="title">ss</span><span class="params">(line)</span></span>;</span><br><span class="line">istream_iterator&lt;<span class="keyword">int</span>&gt; begin(ss), end;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums(begin, end);</span><br></pre></td></tr></table></figure><h3 id="python中能够直接使用的库，为了过题，不一定要使用c"><a href="#python中能够直接使用的库，为了过题，不一定要使用c" class="headerlink" title="python中能够直接使用的库，为了过题，不一定要使用c++"></a>python中能够直接使用的库，为了过题，不一定要使用c++</h3><p>遇到计算字符串表达式的题目。<br>python3提供了eval()函数来计算一个字符串表达式，并返回表达式的值。</p><p>输出可以使用print</p><p>python输入可以为input()</p><p>例如：实现一个整数计算器的话，可以使用 print( eval(input()))</p><p>或者实现多行输入的话：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def main():</span><br><span class="line">    while 1:</span><br><span class="line">        i = input()</span><br><span class="line">        if i == &quot;END&quot;:</span><br><span class="line">            break</span><br><span class="line">        exec(&quot;print(&quot;+i+&quot;)&quot;)</span><br><span class="line"> </span><br><span class="line">if __name__==&quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019毕业面试总结（持续更新）</title>
      <link href="/2019/08/22/2019-08-22-%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
      <url>/2019/08/22/2019-08-22-%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="面试经历"><a href="#面试经历" class="headerlink" title="面试经历"></a>面试经历</h3><div class="table-container"><table><thead><tr><th>编号</th><th>面试时间</th><th>面试公司</th><th>面试方式</th><th>面试结果</th></tr></thead><tbody><tr><td>1</td><td>2019.08.22</td><td>华为消费者终端事业部（上海）</td><td>电话面（55min）</td><td>二轮技术面和主管面</td></tr><tr><td>2</td><td>2019.09.03</td><td>阿里巴巴校招</td><td>onsite面试（30min）</td><td>被拒</td></tr><tr><td>3</td><td>2019.09</td><td>微软中国</td><td>在线笔试</td><td>远程一二面</td></tr></tbody></table></div><h3 id="面试过程"><a href="#面试过程" class="headerlink" title="面试过程"></a>面试过程</h3><h4 id="1-华为消费者终端事业部（上海）"><a href="#1-华为消费者终端事业部（上海）" class="headerlink" title="1. 华为消费者终端事业部（上海）"></a>1. 华为消费者终端事业部（上海）</h4><p><strong>2019.08.22</strong><br>面试内容：</p><ol><li>围绕论文发表内容阐述算法研究内容，并从内容中引申出相关的问题，自己要对研究的内容非常熟悉，并且要经常从逻辑的角度来想自己的目标是什么，为什么要这么做。 </li><li>从研究经历出发，从工程的角度来衡量你的工程实践能力（我面试的主要是软件开发相关，所以问了一下代码行数），主要使用的工具使什么</li><li>我的问题是消费者终端事业部主要是做什么的：面试官的项目组主要是做手机系统的整体仿真和图像算法的处理（会涉及到GAN以及算法性能的评估）</li></ol><p>面试收获：<br>华为产品线的加班比较严重，但是非产品线的加班会看项目进度来。项目进度紧急的话会996，但不是全年。薪资不透露。</p><p><strong>2019.09 更新</strong><br>通过了在线笔试，和第一轮技术面试。之前的电话面试是闲聊，不属于正式面试。<br>增加了关于C++语法知识的考察（static，STL容器等方面的考察）。问了一下CNN基本知识。</p><p><strong>2019.10 更新</strong><br>技术二面，主要是对项目的质询。主要了解SLAM技术和关于磁定位项目的陈述。<br>最后写一个题本来要挟FFT的蝶形运算图，但是太久远了没办法写。最后写了一个SLAM的整体流程图。</p><h4 id="2-阿里巴巴校招"><a href="#2-阿里巴巴校招" class="headerlink" title="2. 阿里巴巴校招"></a>2. 阿里巴巴校招</h4><p><strong>2019.09.03</strong><br>面试内容：</p><ol><li>简单自我介绍（1min）</li><li>两道算法题，白板写（15min）</li><li>机器学习算法以及相关项目经历</li></ol><p>自我介绍：突出了一下组里没有人做相关背景的东西，我相当于是从0开始（然后被面试官问这是不是亮点，我来了一句这好像也不能算亮点）</p><p>两道算法题：<br>A. 翻转二叉树（写出来，但是没有注意边界条件，就是用递归）<br>B. IOU 给出两个矩形的对角线顶点，求两个矩形的交叉面积（绕进去了，没有想明白）<br><strong>正确的思路：</strong><br>假设rect 1有点（Ax, Ay）和（Bx, By）；假设rect 2有点（Cx, Cy）和（Dx, Dy）；<br>首先第一步，确保A，C是左上角， B，D是右下角<br>那么：<br>width1 = Bx - Ax；<br>height1 = By - Ay；<br>width2 = Dx - Cx;<br>height2 = Dy - Cy;</p><p>startx = min(Ax, Cx);<br>endx = max(Ax+width1, Cx+width2);</p><p>starty = min(Ay, Cy);<br>endy = max(Ay+height1, Cy+height2);</p><p>现在来判断x方向 width1 + width2 - (endx - startx) 和 y方向 height1 + height2 - (endy - starty) 如果任何一个小于0，则说明没有相交。<br>如果大于零，那么这两个值就是相交区域的边长。</p><p>这是广泛用在cv领域的iou</p><p>机器学习算法需要你对算法为什么是这样的有比较深入的理解。比如logistic regression的loss function为什么是这样构造的。以及朴素贝叶斯大概的应用是什么。总结就是回去要好好看书，andrew ng的视频两倍速来补一下。</p><h4 id="3-微软1，2面试"><a href="#3-微软1，2面试" class="headerlink" title="3. 微软1，2面试"></a>3. 微软1，2面试</h4><p>1轮面试问了项目，做了一道题，字符串找出包含最长子串。Teams面试，上来有点懵，最开始想用动态规划写，但是递推公式没退出来，后来改成暴力。但是最后面试官说有点问题。</p><p>2轮面试先问了什么是“动态编译”，潜意识里有点抗拒问计算机组成原理的内容，知道是在问关于继承虚函数的内容，但是怂了怕说错就说不太了解相关领域的内容。<br>做了两道题，第一道，翻转字符串“I am a student”换成“student a am I”。第一遍没看明白，做了个2 pointer翻转，后来面试官说你跑一下看看是什么。发现问题之后有写了一遍。稍微有点小问题就是在最后一个单词push进来的时候，经过提醒更正。<br>第二道，二维排序数组找到查找是否存在一个数。首先是暴力，面试官说减小复杂度，然后就是两个二分法。首先最后一列二分法找到大于等于target的最小的数，然后在该行二分法查找是否存在这个数。写出来面试官说没什么问题。然后我的问题是我哪些方面不足，面试官说你需要补计算机组成原理，你需要知道这些相关内容。</p><p>结果应该是凉了。因为没有接到三面通知。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>极大似然估计与最大熵估计</title>
      <link href="/2019/08/21/2019-08-21-%E8%B4%9D%E5%8F%B6%E6%96%AF%E4%BC%B0%E8%AE%A1%E4%B8%8E%E6%9E%81%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1/"/>
      <url>/2019/08/21/2019-08-21-%E8%B4%9D%E5%8F%B6%E6%96%AF%E4%BC%B0%E8%AE%A1%E4%B8%8E%E6%9E%81%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p>本系列为在温习《统计学习方法》过程中的思考总结<br><a id="more"></a> <!-- 摘要 --></p><h3 id="生成模型与判别模型"><a href="#生成模型与判别模型" class="headerlink" title="生成模型与判别模型"></a>生成模型与判别模型</h3><p>学习一个模型就是对给定的输入预测相应的输出，也就是写出一个决策函数（对应回归问题）：$Y = f(X)$ 或条件概率（对应分类问题）： $P(Y|X)$</p><h4 id="生成方法"><a href="#生成方法" class="headerlink" title="生成方法"></a>生成方法</h4><p>生成方法出发点是<strong>学习联合概率分布函数</strong>$P(X, Y)$, 然后求出条件概率分布 $P(Y|X)$。</p><script type="math/tex; mode=display">\begin{align}    P(Y|X) = \frac{P(X, Y)}{P(X)}\end{align}</script><p>而联合分布函数$P(X, Y)$和$P(X)$由概率最大似然估计从<strong>观测数据中求得</strong>。典型的生成模型有 <em>朴素贝叶斯法</em> 和 <em>隐含马尔科夫型</em> 。</p><h4 id="判别方法"><a href="#判别方法" class="headerlink" title="判别方法"></a>判别方法</h4><p>判别方法是由数据直接学习决策函数$f(X)$或条件概率分布$P(Y|X)$。</p><p>基本思路是设定一个<strong>含有模型参数的决策模型</strong>，然后通过最大似然拟合观测数据来选出<strong>最优化模型参数</strong>，从而得到最终的决策模型。</p><p>典型的判别模型有 k-means，感知机，决策树，logistic regression，最大熵模型，支持向量机，提升方法和条件随机场。</p><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><p>生成方法的学习收敛速度快，当样本容量增加的时候，学到的模型可以更快的收敛于真是模型。当存在隐变量的时候，仍然可以使用生成方法。</p><p>判别方法直接面对预测，往往学习的准确率更高。并且可以对数据进行各种程度上的抽象、定义特征并使用特征，可以简化学习问题。</p><h3 id="似然估计与似然函数"><a href="#似然估计与似然函数" class="headerlink" title="似然估计与似然函数"></a>似然估计与似然函数</h3><h4 id="最大似然估计原理"><a href="#最大似然估计原理" class="headerlink" title="最大似然估计原理"></a>最大似然估计原理</h4><p>给定一个概率分布$D$， <strong>已知</strong>其概率分布函数（模型） 为$f_D$, 该概率分布函数包含一个模型参数$\theta$。在这个概率分布中进行采样得到数据集$T = {x_1, x_2, x_3, x_4,… x_n}$。 <strong>求解</strong>参数$\theta$来确定该分布$f_D$。</p><p>我们可以构建似然函数：</p><script type="math/tex; mode=display">\begin{align}L(\theta|x_1, ..., x_n) = f_D(x1, x2, ..., x_n|\theta)\end{align}</script><p>注意$L(\theta|x_1, …, x_n)$是$\theta$的函数，而$f_D(x1, x2, …, x_n|\theta)$是$x_1, …, x_n$的函数。$f_D(x1, x2, …, x_n|\theta)$表示在确定$\theta$的情况下，产生数据集$T$的概率。</p><p>通过最大化似然函数$L(\theta)$我们可以找到使得数据集$T$出现概率最大的模型。</p><h4 id="进行独立分布假设"><a href="#进行独立分布假设" class="headerlink" title="进行独立分布假设"></a>进行独立分布假设</h4><p>似然函数可以写成<br><strong>形式1</strong></p><script type="math/tex; mode=display">\begin{equation}L(\theta|x_1, ..., x_n) = f_D(x1, x2, ..., x_n|\theta) = \prod_{i=1}^{n} f_D(x_i|\theta)\end{equation}</script><p>假设随机变量X是离散的，具有取值范围为${v_1, v_2, … v_k}$ 那么上述极大似然函数可以写为<br><strong>形式2</strong>：</p><script type="math/tex; mode=display">\begin{align}L(\theta|x_1, ..., x_n) = \prod_{i=1}^{k} f_D(v_i)^{C(x=v_{i})}\end{align}</script><p>两边对等开n次方可得：</p><script type="math/tex; mode=display">\begin{align}L(\theta|x_1, ..., x_n)^{1/n} = \prod_{i=1}^{k} f_D(v_i)^{C(x=v_{i})/n}\end{align}</script><p>其中$C(x=v_{i})$是随机变量X取得$v_i$的数量，$n$为所有样本总数</p><p>此时注意到$\bar{f<em>D}(x)=C(x=v</em>{i})/n$，就是从数据中得来的经验概率。</p><p>而求$L(\theta|x_1, …, x_n)^{1/n}$的最大值和求$L(\theta|x_1, …, x_n)$是等价的，所以我们就可以把似然函数写成<br><strong>形式3</strong>：</p><script type="math/tex; mode=display">L(\theta|x) = \prod_{i=1}^{n}P(x|\theta)^{\bar{P}(x)}</script><p>这也就是似然函数的一般形式</p><script type="math/tex; mode=display">\begin{align}L(\theta|x) = \prod_{i=1}^{n}P(x)^{\bar{P}(x)}\end{align}</script><h4 id="求解模型参数"><a href="#求解模型参数" class="headerlink" title="求解模型参数"></a>求解模型参数</h4><script type="math/tex; mode=display">\begin{align}\hat{\theta} = \mathop{\arg\max}_{\theta} L(\theta|x)\end{align}</script><h3 id="朴素贝叶斯估计-生成模型"><a href="#朴素贝叶斯估计-生成模型" class="headerlink" title="朴素贝叶斯估计-生成模型"></a>朴素贝叶斯估计-生成模型</h3><p>（1）估计$P(x, y) = \bar{P}(x|y) \bar{P}(y)$, 其中$\bar{P}(x|y)$和$\bar{P}(y)$是从数据集中得来的经验概率（条件概率和先验概率）<br>（2）进行独立分布假设<br>$\bar{P}(X=x|Y=c<em>k)=\bar{P}(X=x_1,x_2,…,x_n|Y=c_k) = \prod</em>{j=1}^{n} P(X = x_j|Y=c_k)$<br>（3）计算分入某个类的概率(贝叶斯公式)</p><script type="math/tex; mode=display">\begin{align}P(Y=c_k|X=x) = \frac{P(X=x|Y=c_k) P(Y=c_k)}{\sum_k P(X=x|Y=c_k) P(Y=c_k)}\end{align}</script><p>注意分母是全概率$P(X=x)$与$Y$没有关系。<br>(4) 选取概率最大的那个类作为估计输出 $\mathop{\arg\max}_{c_k} P(c_k | X=x)$</p><script type="math/tex; mode=display">\begin{align}y = \mathop{\arg\max}_{c_k} P(Y=c_k) \prod_j(X=x_j|Y=c_k)\end{align}</script><p>朴素贝叶斯估计是将实例分到后验概率最大的类中，等价于期望风险最小化。</p><h3 id="Logistic-Regression-二元-判别模型"><a href="#Logistic-Regression-二元-判别模型" class="headerlink" title="Logistic Regression (二元) - 判别模型"></a>Logistic Regression (二元) - 判别模型</h3><p>(1) 设定模型为logistic model：<br>认为一个事件发生的概率为p，那么定义其对数几率(log odds)为$logit(p) = \frac{p}{1-p}$。<br>模型认为$logit(p) = w\cdot x+b$，也就是一个事件发生的对数几率是其输入的线性模型。<br>由此推出的：</p><script type="math/tex; mode=display">p(Y=1|X) = \frac{exp(w\cdot x+b)}{1+exp(w\cdot x+b)} = \pi(x)</script><script type="math/tex; mode=display">P(Y=0|X) = 1-p(Y=1|X) = \frac{1}{1+exp(w\cdot x+b)} = 1-\pi(x)</script><p>(2) 参数模型估计，极大似然估计 （采用形式2）</p><script type="math/tex; mode=display">L(w) = \mathop{\prod}_{i=1}^{N} [\pi(x_i)]^{y_i} [1-\pi(x_i)]^{1-y_i}</script><p>对数似然函数为</p><script type="math/tex; mode=display">L(w) = \mathop{\sum}_{i=1}^{N}[y_i(w \cdot x_i) - log(1+exp(w \cdot x_i))]</script><p>最大化似然估计求得模型参数</p><h3 id="最大熵模型-判别模型"><a href="#最大熵模型-判别模型" class="headerlink" title="最大熵模型 - 判别模型"></a>最大熵模型 - 判别模型</h3><h4 id="最大熵原理"><a href="#最大熵原理" class="headerlink" title="最大熵原理"></a>最大熵原理</h4><p>最大熵原理认为，学习概率模型时，在所有可能的概率模型中，熵最大的模型是最好的模型。（对比于上式logistic regression认为极大似然概率最大的模型是最好的模型，当然极大似然估计可能会出现overfitting的问题）。</p><p>直观的来说，最大熵原理认为要选择的概率模型首先必须满足已有的实时，即在约束条件下，在没有更多信息的情况下，那么不确定的部分都是”等可能的“。这时候熵可以来作为可优化的指标。</p><h4 id="模型定义"><a href="#模型定义" class="headerlink" title="模型定义"></a>模型定义</h4><p>（1）特征函数$f(x, y)$描述输入x和输出y之间的某一个事实，是一个二值函数，当x，y满足这个事实的时候取值为1，否则取值为0。</p><p>（2）特征函数关于经验分布$\bar{P}(x, y)$的期望为</p><script type="math/tex; mode=display">E_{\bar{P}}(f) = \mathop{\sum}_{x,y}\bar{P}(x, y) f(x,y)</script><p>关于模型$P(Y|X)$和经验分布$\bar{P}(X)$的期望为</p><script type="math/tex; mode=display">E_{P}(f) = \mathop{\sum}_{x,y}\bar{P}(x) P(Y|X) f(x,y)</script><p><strong>如果模型能够获取训练数据的信息，那么两个期望应该相等</strong>。注意，这个模型可能有很多个，凡是能够拟合训练数据的模型都满足这个约束条件。</p><p>（3）最大熵模型，假设满足所有约束条件的模型集合为C，那么定义在条件概率分布$P(Y|X)$上的条件熵为</p><script type="math/tex; mode=display">H(P) = -\mathop{\sum}_{x,y}\bar{P}(x) P(Y|X) log(P(Y|X))</script><p>则模型中条件熵$H(P)$最大的模型成为最大熵模型。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 统计学习方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯算法</title>
      <link href="/2019/08/16/2019-08-12-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
      <url>/2019/08/16/2019-08-12-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h3><ol><li>概念：回溯算法实际上是一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现不满足求解条件时，就回溯返回，尝试别的路径。许多复杂的，规模较大的问题都可以使用回溯法。</li><li>基本思想：在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根节点触发深度探索解空间树。当搜索到某一节点时，要先判断该节点是否包含问题的解，如果包含，就从该节点触发极速探索；如果不包含，则逐层向其祖先节点回溯。</li><li>使用回溯法求解所有问题，要回溯到根，且根节点的所有可行子树都要被搜索遍历才结束。使用回溯法求解一个问题，只要搜索到问题的一个解就可以结束。</li></ol><h3 id="回溯算法框架："><a href="#回溯算法框架：" class="headerlink" title="回溯算法框架："></a>回溯算法框架：</h3><p>设问题的解是一个n维向量(a1, a2, …, an)，约束条件是ai(i=1,2,3,…,n)之间满足某种条件，即为f(ai)。</p><ol><li><p>非递归框架：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[n], i;</span><br><span class="line">i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i&gt;<span class="number">0</span>(有路可走)  <span class="keyword">and</span>  (未达目标))&#123; <span class="comment">//还未回溯到头</span></span><br><span class="line">    <span class="keyword">if</span>(i &gt; n)&#123;</span><br><span class="line">        搜索到一个解，输出；</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        a[i]第一个可能的值；</span><br><span class="line">        <span class="keyword">while</span>(a[i]在不满足约束条件且在搜索空间内)&#123;</span><br><span class="line">            a[i]下一个可能的值；</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[i]在搜索空间内)&#123;</span><br><span class="line">            标识占用资源；</span><br><span class="line">            i = i+<span class="number">1</span>； <span class="comment">//扩展下一节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            清理所占空间状态； <span class="comment">//回溯</span></span><br><span class="line">            i=i<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>递归框架</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[n];</span><br><span class="line">i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">try</span>(<span class="keyword">int</span> i)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; n) 输出结果；</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(j = 下界; j&lt;=上界;j=j+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fun(j))&#123;</span><br><span class="line">                a[i] = j;</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">try</span>(i+<span class="number">1</span>);</span><br><span class="line">                清理工作;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LeetCode题解"><a href="#LeetCode题解" class="headerlink" title="LeetCode题解"></a>LeetCode题解</h3><h4 id="784-Letter-Case-Permutation"><a href="#784-Letter-Case-Permutation" class="headerlink" title="784. Letter Case Permutation"></a>784. Letter Case Permutation</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; letterCasePermutation(<span class="built_in">string</span> S) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        backTracking(S, ans, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backTracking</span><span class="params">(<span class="built_in">string</span>&amp; s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; ans, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        ans.push_back(s);</span><br><span class="line">        <span class="keyword">while</span>(i &lt; s.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">isdigit</span>(s[i])) &#123; <span class="comment">//is char</span></span><br><span class="line">                s[i] = toggle(s[i]); <span class="comment">//转变大小写</span></span><br><span class="line">                backTracking(s, ans, i+<span class="number">1</span>); <span class="comment">//增加一个解空间子树</span></span><br><span class="line">                s[i] = toggle(s[i]); <span class="comment">//返回原来子树</span></span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">toggle</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isupper</span>(c)? <span class="built_in">tolower</span>(c) : <span class="built_in">toupper</span>(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hive与MySQL数据库操作</title>
      <link href="/2019/08/15/2019-08-15-Hive%E4%B8%8EMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/"/>
      <url>/2019/08/15/2019-08-15-Hive%E4%B8%8EMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="基本通用的SQL语句"><a href="#基本通用的SQL语句" class="headerlink" title="基本通用的SQL语句"></a>基本通用的SQL语句</h2><h3 id="Hive数据类型"><a href="#Hive数据类型" class="headerlink" title="Hive数据类型"></a>Hive数据类型</h3><p>Hive所有的数据类型分为如下四种：</p><ul><li>列类型<ul><li>整形 INT，当数据范围超过INT时需要使用BIGINT</li><li>字符串类型 可以使用单引号或双引号来指定，包含VARCHAR和CHAR两种数据类型。</li><li>时间戳 支持传统的UNIX时间戳可选纳秒的精度</li><li>日期 DATE</li><li>小数点</li><li>联合类型</li></ul></li><li>文字<ul><li>浮点类型</li><li>十进制类型</li></ul></li><li>Null 缺少值通过特殊值 NULL 来表示</li><li>复杂类型<ul><li>数组</li><li>映射</li><li>结构体</li></ul></li></ul><h3 id="创建数据库，删除数据库，选择使用数据库"><a href="#创建数据库，删除数据库，选择使用数据库" class="headerlink" title="创建数据库，删除数据库，选择使用数据库"></a>创建数据库，删除数据库，选择使用数据库</h3><h4 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h4><p><code>create database [if not exists] &lt;database_name&gt;;</code><br>这里if not exists是可选自居，通知用户已经存在相同名称的数据库。<br><code>show databases;</code> 显示所有数据库<br><code>drop database &lt;database_name&gt;</code><br><code>use &lt;database_name&gt;</code> 选择数据库</p><h4 id="Hive"><a href="#Hive" class="headerlink" title="Hive"></a>Hive</h4><p><code>create database|schema [if not exists] &lt;database_name&gt;;</code><br><code>show databases;</code><br><code>drop database StatementDrop (database|schema) [if exists] &lt;database_name&gt; [restrict|cascade];</code><br>使用cascade查询删除数据库表示在删除数据库之前全部删除相应的表。<br><code>use &lt;database_name&gt;</code></p><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><h4 id="MySQL-1"><a href="#MySQL-1" class="headerlink" title="MySQL"></a>MySQL</h4><p>通用表示为<code>create table table_name (col_name data_type)</code></p><p>例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table config(</span><br><span class="line">id int auto_increment,</span><br><span class="line">    key_ varchar(255),</span><br><span class="line">    value varchar(255),</span><br><span class="line">    primary key (id)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure></p><h4 id="Hive-1"><a href="#Hive-1" class="headerlink" title="Hive"></a>Hive</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create [temporary] [external] table [if not exists] [db_name.] table_name</span><br><span class="line">[(col_name data_type [comment col_comment], ...)]</span><br><span class="line">[comment table_comment]</span><br><span class="line">[row format row_format]</span><br><span class="line">[stored as file_format]</span><br></pre></td></tr></table></figure><p>注意Hive没有主键(primary key)或者基于序列密钥生成的自增键(auto_increment)的概念。</p><p>一般来说，sql创建表后，可以使用insert语句来插入数据。在Hive中，可以使用load data语句插入数据。<br>同时将数据插入到hive，最好是使用load data来存储大量记录。有两种方法用来加载数据：1. 从本地文件系统，2.从hadoop文件系统</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load data [local] inpath &apos;filepath&apos; [overwrite] into table tablename [partition (partcol1=val, partcol2=val2 ...)]</span><br></pre></td></tr></table></figure><h3 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h3><h4 id="MySQL-2"><a href="#MySQL-2" class="headerlink" title="MySQL"></a>MySQL</h4><p><code>alter table name operation;</code></p><h4 id="Hive-2"><a href="#Hive-2" class="headerlink" title="Hive"></a>Hive</h4><p>修改数据表属性的alter语句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alter table name rename to new_name;</span><br><span class="line">alter table name add columns (col_spec[, col_spec ...]);</span><br><span class="line">alter table name drop [column] column_name;</span><br><span class="line">alter table name change column_name new_name new_type;</span><br><span class="line">alter table name replace columns (col_spec[, col_spec ...]);</span><br></pre></td></tr></table></figure></p><h2 id="差异很大的操作"><a href="#差异很大的操作" class="headerlink" title="差异很大的操作"></a>差异很大的操作</h2><h3 id="查询表结构信息"><a href="#查询表结构信息" class="headerlink" title="查询表结构信息"></a>查询表结构信息</h3><h4 id="Hive-3"><a href="#Hive-3" class="headerlink" title="Hive"></a>Hive</h4><p><code>desc table_name</code> 显示表字段信息<br><code>desc formatted table_name</code> 显示包含表存储等详细信息,包括数据库在hdfs中的存储位置信息。</p><h4 id="MySQL-3"><a href="#MySQL-3" class="headerlink" title="MySQL"></a>MySQL</h4><p><code>show table_name</code> 显示表字段信息。</p><h3 id="Hive-模糊搜索表"><a href="#Hive-模糊搜索表" class="headerlink" title="Hive 模糊搜索表"></a>Hive 模糊搜索表</h3><p><code>show tables like &#39;*name*&#39;</code></p><h3 id="Hive分区"><a href="#Hive分区" class="headerlink" title="Hive分区"></a>Hive分区</h3><p>Hive组织表到分区。它是将一个表基于分区列，如日期，城市和部门的值相关方式。使用分区，很容易对数据进行部分查询。<br>表或分区是细分成桶，以提供额外的结构，可以使用更高效的查询的数据。桶的工作是基于表的一些列的散列函数值。</p><p>例如，一个名为Tab1表包含雇员数据。假设需要检索所有在2012年加入，查询搜索整个表所需的信息员工的详细信息。如果用年份分区雇员数据并将其存储在一个单独的文件，就减少了查询处理时间。</p><p><strong>如何建立建立分区</strong>：</p><ul><li>因为整个Hive数据库是分布式存储的，一个分区实际上是以一个单独文件的形式独立存放的，所以必须在建立数据库的时候就声明分区是什么。一旦建立数据库，就无法再使用alter语句对数据库进行分区修改了。</li><li><p>建立数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; create table student_parted_gender (eid int, name string, age int) partitioned by (gender string)</span><br><span class="line">    &gt; row format delimited</span><br><span class="line">    &gt; fields terminated by &apos;\t&apos;</span><br><span class="line">    &gt; lines terminated by &apos;\n&apos;;</span><br></pre></td></tr></table></figure></li><li><p><code>fields terminated by &#39;\t&#39;</code> 表示导入数据的时候数据单元格之间以<code>tab</code>为间隔</p></li><li><code>lines terminated by &#39;\n&#39;</code> 表示每条数据之间以<code>换行</code>为间隔</li><li><code>partitioned by</code> 后边的属性不能与前边定义的属性重复，也就是说，建立分区是单独的column，然而在select查看表内容的时候分区还是以column形式出现。</li><li><p>建立数据库后要增加分区：（注意，增加分区的意思是，在gender这一列的属性中增加一个’M‘的属性，而不是说增加一个叫做gender的列）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table student_parted_gender add partition (gender=&apos;M&apos;);</span><br></pre></td></tr></table></figure></li><li><p>导入数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load data loca inpath &apos;/usr/local/hadoop/hdfs_local_dir/student_parted_gender_M.txt&apos; overwrite into table student_parted_gender partition (gender=&apos;M&apos;);</span><br></pre></td></tr></table></figure></li></ul><p>这里overwrite表示重新覆盖数据库的数据数据。<br>不过这里要注意：<br>在txt文件中可以不包含gender这一项。如果包含了gender这一项，那么在导入的时候，源数据会直接被置为一直的’M‘，即使源数据里是’F‘。<br>并且，txt文件中可以包含多个列，但读取fields只会选取最前边的几个列。</p><h4 id="添加分区"><a href="#添加分区" class="headerlink" title="添加分区"></a>添加分区</h4><p>假设我们有一个表叫employee， 拥有id， name， salary， designation， dept， yoj（year of join）等字段。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table table_name add [if not exists] partition partition_spec[location &apos;location1&apos;] partition_spec [location &apos;location2&apos;] ...;</span><br></pre></td></tr></table></figure><p>也就是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; alter table employee</span><br><span class="line">&gt; add partition (year=&apos;2013&apos;)</span><br><span class="line">&gt; location &apos;/2012/part2012&apos;;</span><br></pre></td></tr></table></figure></p><h4 id="重命名分区"><a href="#重命名分区" class="headerlink" title="重命名分区"></a>重命名分区</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table table_name partition partition_spec rename to partition partition_spec;</span><br></pre></td></tr></table></figure><h4 id="删除分区"><a href="#删除分区" class="headerlink" title="删除分区"></a>删除分区</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table table_name drop [if exists] partition partition_spec, partition partition_spec, ...;</span><br></pre></td></tr></table></figure><h4 id="查看分区信息"><a href="#查看分区信息" class="headerlink" title="查看分区信息"></a>查看分区信息</h4><p><code>show partitions table_name;</code></p><h4 id="根据分区查询数据"><a href="#根据分区查询数据" class="headerlink" title="根据分区查询数据"></a>根据分区查询数据</h4><p><code>select table_column from table_name where partition_name=&#39;partition_spec&#39;</code></p><h3 id="Hive创建一个视图"><a href="#Hive创建一个视图" class="headerlink" title="Hive创建一个视图"></a>Hive创建一个视图</h3><p>在实行select语句的时候，可以创建一个视图来保存数据及结果。与SQL视图用法相同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create view [if not exists] view_name [(column_name [Comment column_comment], ...)] [comment table_comment]</span><br><span class="line">as select ...</span><br></pre></td></tr></table></figure><h3 id="Hive内置函数"><a href="#Hive内置函数" class="headerlink" title="Hive内置函数"></a>Hive内置函数</h3><p>全部参考 <a href="https://www.yiibai.com/hive/hive_built_in_functions.html" target="_blank" rel="noopener">https://www.yiibai.com/hive/hive_built_in_functions.html</a></p><p>主要有</p><div class="table-container"><table><thead><tr><th>返回类型</th><th>函数名</th><th>说明</th></tr></thead><tbody><tr><td>BIGINT</td><td>round(double a)</td><td>返回离a最近的BIGNINT</td></tr><tr><td>BIGINT</td><td>floor(double a)</td><td>返回小于等于a的最大BIGINT</td></tr><tr><td>BIGINT</td><td>ceil(double a)</td><td>返回大于等于a的最小BIGINT</td></tr><tr><td>double</td><td>rand(), rand(int seed)</td><td>返回随机数</td></tr><tr><td>string</td><td>concat(string A, string B, …)</td><td>返回A和B的串联字符串</td></tr><tr><td>string</td><td>substr(string A, int start, int length)</td><td>返回字符串字串</td></tr><tr><td>string</td><td>upper(string A)</td><td>转换成大写</td></tr><tr><td>string</td><td>lower(String A)</td><td>转换成小写</td></tr><tr><td>string</td><td>trim(string A)</td><td>减掉字符串A两端的空格</td></tr><tr><td>int</td><td>size(Map(K, V))</td><td>返回映射类型的元素数量</td></tr><tr><td>int</td><td>size(Array<t>)</t></td><td>返回数组类型的元素数量</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hive </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/2019/08/12/2019-08-12-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2019/08/12/2019-08-12-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<a id="more"></a> <!-- 摘要 --><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序的基本思想是，每一次冒泡，都从数组末端将最小的数或者最大的数冒泡到最上端。<br>时间复杂度为<code>o(n^2)</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sortArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums.size() &lt;=<span class="number">1</span>) <span class="keyword">return</span> nums;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = nums.size()<span class="number">-1</span>; j&gt;i; j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &lt; nums[j<span class="number">-1</span>])&#123;</span><br><span class="line">                    swap(nums, j, j<span class="number">-1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>选择排序思想有点类似于冒泡排序，都是在一次排序后把最小的元素放到最前边。但是过程不同。<br>冒泡排序是通过交换相邻元素。而选择排序是通过对整体的选择。<br>例如，对[5,3,8,6,4]进行选择排序：</p><ol><li>5和剩余序列[3, 8, 6, 4]中最小的元素交换。变为[3, 5, 8, 6, 4]。</li><li>5和剩余序列[8, 6, 4]中最小元素交换。变为[3, 4, 8, 6, 5]。</li><li>依次类推<br>可以看出时间复杂度仍为<code>O(n^2)</code>。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sortArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums.size() &lt;=<span class="number">1</span>) <span class="keyword">return</span> nums;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> minIdx = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j&lt;nums.size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &lt; nums[minIdx])&#123;</span><br><span class="line">                    minIdx = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(minIdx != i)&#123; <span class="comment">//如果发现了剩余序列的最小值</span></span><br><span class="line">                swap(nums, i, minIdx);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>例如[5, 3, 8, 6, 4]进行排序。</p><ol><li>假设第一个数5位置是对的</li><li>下一个拿到3，就要把3放在5前边，5向后移位</li><li>以此类推，要保证每一次插入，前边的序列是有序的。<br>时间复杂度仍然为<code>O(n^2)</code>。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sortArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums.size() &lt;=<span class="number">1</span>) <span class="keyword">return</span> nums;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">int</span> target = nums[i];</span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; target &lt; nums[j<span class="number">-1</span>])&#123;</span><br><span class="line">                nums[j] = nums[j<span class="number">-1</span>]; <span class="comment">//向后移位，这时原本的nums[i]已经保存成了target</span></span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[j] = target;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序是<strong>冒泡+二分法</strong>。在冒泡排序中，每一次只能把整个序列的一个最值浮出来。而快速排序实现了一次遍历将最小和最大分别移到中点两侧。<strong>思路是：两个指针，右指针找比基准大的，左指针找比基准小的。直到相遇。</strong><br>举例：[5, 3, 8, 6, 4]</p><ol><li>以5为中点，将剩余序列分为比5大的和比5小的。左指针指向最左，右指针指向最右。相向遍历。</li><li><strong>首先移动右指针还是左指针？</strong>。这取决于最后你的左右指针在何处相遇，因为我们要交换基准点和指针相遇处的值。一般我们选择序列第一个值为基准点，那么我们需要指针相遇在<strong>小于基准点的那个界限</strong>，这样才符合我们的思路。那么我们就需要<strong>先移动右指针</strong>。如果先移动左指针就会相遇在大于基准点的界限。</li><li>在指针相遇之前，如果左指针大于基准，右指针小于基准，那么交换两指针的值，继续进行遍历。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sortArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums.size() &lt;=<span class="number">1</span>) <span class="keyword">return</span> nums;</span><br><span class="line">        </span><br><span class="line">        quickSort(nums, <span class="number">0</span>, nums.size()<span class="number">-1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt;= end) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> baseP = partition(nums, start, end); <span class="comment">//一次遍历，找到基准位置</span></span><br><span class="line">        quickSort(nums, start, baseP<span class="number">-1</span>);</span><br><span class="line">        quickSort(nums, baseP+<span class="number">1</span>, end);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> basePoint = nums[start];</span><br><span class="line">        <span class="keyword">int</span> leftP = start;</span><br><span class="line">        <span class="keyword">int</span> rightP = end;</span><br><span class="line">        <span class="keyword">while</span>(leftP &lt; rightP)&#123;</span><br><span class="line">            <span class="keyword">while</span>(leftP &lt; rightP &amp;&amp; nums[rightP] &gt;= basePoint)&#123;</span><br><span class="line">                rightP--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(leftP &lt; rightP &amp;&amp; nums[leftP] &lt;= basePoint)&#123;</span><br><span class="line">                leftP++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            swap(nums, leftP, rightP);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, start, leftP);<span class="comment">//将基准换到中间去</span></span><br><span class="line">        <span class="keyword">return</span> leftP; <span class="comment">//返回当前基准点的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><h4 id="1-什么是堆："><a href="#1-什么是堆：" class="headerlink" title="1. 什么是堆："></a>1. 什么是堆：</h4><p>堆（Heap）是一种具有如下性质的<strong>二叉树</strong>：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。<br>也就是：<br>大顶堆满足 root &gt; left &amp;&amp; root &gt; right<br>小顶堆满足 root &lt; left &amp;&amp; root &lt; right<br>这样一种数据结构能够满足，整个堆的根节点一定是最大值或者最小值。</p><h4 id="2-堆排序："><a href="#2-堆排序：" class="headerlink" title="2. 堆排序："></a>2. 堆排序：</h4><p>根据堆这种数据结构进行<strong>选择排序</strong>，也就是一个一个确定最大数或最小数（遍历n），然后再对剩余序列进行操作（遍历logn），最坏最好时间复杂度均为<code>O(nlogn)</code>。也是不稳定排序。</p><h4 id="3-用线性数组表示堆："><a href="#3-用线性数组表示堆：" class="headerlink" title="3. 用线性数组表示堆："></a>3. 用线性数组表示堆：</h4><ul><li>现在我们用<strong>先序遍历</strong>二叉树得到一个线性数组，那么此时root和child之间的下标关系是什么呢。</li><li>我们知道每一个root至多对应两个child，在堆中不允许出现空缺叶节点。所以：</li><li>第i行总共有$2^{i-1}$个节点</li><li>等比数列可知，第i行最后一个节点下标为$2^i-1-1 = 2^i-2$</li><li>第i行的第一个节点下标为$2^{i-1}-2+1 = 2^{i-1}-1$</li><li>所以第i行的第m个节点下标为$root=2^{i-1}+m-2$</li><li>那么第i行的第m个节点对应的左节点为第i+1行的第$(m-1)*2+1$个节点，也就是下标为$left=2^{i}-2+2*(m-1)+1=2^{i}+2*m-3=2*(2^{i-1}+m-2)+1=2*root+1$</li><li>同理$right=2*root+2$<h4 id="4-堆排序算法："><a href="#4-堆排序算法：" class="headerlink" title="4. 堆排序算法："></a>4. 堆排序算法：</h4>堆排序算法要解决两个问题：</li><li>如何从无序数组构建一个堆<br>考虑一个root根节点，如何实现一个堆。（以大顶堆为例）<br>第一，找到两个子节点中最大的那个large<br>第二，如果root&gt;large那么该根节点已经满足<br>第三，如果root&lt;large，那个交换root和large，此时注意，该节点的结构发生了变化，要跟踪root表示的值以及其子树的变化<br>第四，从第一个非叶子节点开始遍历，一直到堆顶。第一个非叶子节点一般取（n/2）</li><li>在输出堆首后，如何重建堆<br>重要的是<strong>升序大顶堆，降序小顶堆</strong>因为在最后构建排序数组的时候要堆顶出栈，而堆顶出栈肯定不能仍然放在堆顶，那么只能放在最末端。<br>算法实现：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sortArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">0</span> || nums.size() == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = nums.size()/<span class="number">2</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="comment">//构建大推顶</span></span><br><span class="line">            heapAdjust(nums, i, nums.size()<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = nums.size()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            swap(nums, <span class="number">0</span>, i); <span class="comment">//大推顶交换，heap 头一定是最大的，那么放到最末尾去</span></span><br><span class="line">            heapAdjust(nums, <span class="number">0</span>, i<span class="number">-1</span>); <span class="comment">//重新构建大推顶 </span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">heapAdjust</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="comment">//just deal with the start node</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//heap head</span></span><br><span class="line">        <span class="keyword">int</span> tmp = nums[start];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>*start+<span class="number">1</span>; i&lt;=end; i=i*<span class="number">2</span>+<span class="number">1</span>)&#123; </span><br><span class="line">            <span class="comment">//找到子节点</span></span><br><span class="line">            <span class="comment">//left is 2*start+1, right is 2*start+2</span></span><br><span class="line">            <span class="keyword">if</span>(i&lt;end &amp;&amp; nums[i]&lt;nums[i+<span class="number">1</span>])&#123;</span><br><span class="line">                i++;<span class="comment">//升序用大推顶，找到子节点中较大的那个</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//here nums[i] is the largest child</span></span><br><span class="line">            <span class="keyword">if</span>(tmp &gt;= nums[i])&#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">//已经满足大推顶</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//swap the top and the smallest child</span></span><br><span class="line">            nums[start] = nums[i];</span><br><span class="line">            start = i; <span class="comment">//check the new heap</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//insert the original root to the right place</span></span><br><span class="line">        nums[start] = tmp;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">            nums[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序是插入排序的一种高效率实现，也叫缩小增量排序。他的依据是，当序列是有序的时候，插入排序的最佳时间复杂度为<code>O(n)</code>。基本思想：先将整个待排记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录基本有序时再对全体记录进行一次直接插入排序。</p><p>希尔排序的时间复杂度是复杂的，在大量的实验基础上，可以证明在n属于一定范围的时候，时间复杂度约为<br>O(n^1.3)。</p><p>图解见:<a href="https://www.cnblogs.com/chengxiao/p/6104371.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengxiao/p/6104371.html</a><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//插入排序移动法</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sortArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums.size()&lt;=<span class="number">1</span>) <span class="keyword">return</span> nums;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//逐步缩小gap</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> gap = nums.size()/<span class="number">2</span>; gap&gt;<span class="number">0</span>; gap/=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="comment">//对每个分组进行插入排序。注意这里i++,其实每次对应的是一个分组的添加</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = gap; i&lt;nums.size(); i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> j = i;</span><br><span class="line">                <span class="keyword">int</span> tmp = nums[j];</span><br><span class="line">                <span class="keyword">while</span>(j-gap&gt;=<span class="number">0</span> &amp;&amp; tmp &lt; nums[j-gap])&#123;</span><br><span class="line">                    nums[j] = nums[j-gap];</span><br><span class="line">                    j -= gap; <span class="comment">//原版插入排序是减1，现在是减gap</span></span><br><span class="line">                &#125;</span><br><span class="line">                nums[j] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//插入排序交换法，其实就是冒泡的变体</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sortArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums.size() &lt;= <span class="number">1</span>) <span class="keyword">return</span> nums;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> gap = nums.size()/<span class="number">2</span>; gap&gt;<span class="number">0</span>; gap/=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = gap; i&lt;nums.size(); i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> j = i;</span><br><span class="line">                <span class="keyword">while</span>(j-gap &gt;=<span class="number">0</span> &amp;&amp; nums[j] &lt; nums[j-gap])&#123;</span><br><span class="line">                    swap(nums, j, j-gap);</span><br><span class="line">                    j -= gap;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//传统交换</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//不新开辟内存空间</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        nums[i] = nums[i] + nums[j];</span><br><span class="line">        nums[j] = nums[i] - nums[j];</span><br><span class="line">        nums[i] = nums[i] - nums[j];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序是另一种不同的排序方法，完全使用了分治思想。思路就是，将一个序列看成两个有序的序列进行合并，然后递归解决问题。时间复杂度为<code>O(nlogn)</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sortArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        </span><br><span class="line">        mSort(nums, <span class="number">0</span>, nums.size()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(start &gt;= end) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> mid = (start+end)/<span class="number">2</span>;</span><br><span class="line">        mSort(nums, start, mid); <span class="comment">//一分为2</span></span><br><span class="line">        mSort(nums, mid+<span class="number">1</span>, end);</span><br><span class="line">        merge(nums, start, mid, end); <span class="comment">//两个分数组合并</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums, <span class="keyword">int</span> start, <span class="keyword">int</span> mid, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp(end-start+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> i = start;</span><br><span class="line">        <span class="keyword">int</span> j = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//两个数组都没遍历完</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=end)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt;= nums[j])&#123;</span><br><span class="line">                tmp[k++] = nums[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                tmp[k++] = nums[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid)&#123;</span><br><span class="line">            tmp[k++] = nums[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;=end)&#123;</span><br><span class="line">            tmp[k++] = nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k&lt;end-start+<span class="number">1</span>; k++)&#123;</span><br><span class="line">            nums[start+k] = tmp[k];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p>如果面试的过程中面试官要求写一个时间复杂度为O(n)的排序，那么这是可能的。虽然前边的排序方法时间复杂度的下线是O(nlogn)。但确实是有线性时间复杂度的排序，但对待排序的数要满足一定的范围的整数。而且计数排序需要更多的辅助空间。基本思想： <em>用待排序的数作为计数数组的下标，统计每个数字的个数。然后依次输出即可得到有序序列。</em> </p><p>因为待排序数组是计数数组的下标，那么就要求待排序数组是<strong>非负整数</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sortArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() &lt;= <span class="number">1</span>) <span class="keyword">return</span> nums;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> MAX = max(nums);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; count(MAX+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            count[nums[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(nums.size(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;=max; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;count[i]; j++)&#123;</span><br><span class="line">                res[k++] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> MAX = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> ele:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ele &gt; MAX)&#123;</span><br><span class="line">                MAX = ele;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> MAX;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p>桶排序是计数排序的一种改进和推广。<br>基本思想：<br>假设有一组长度为N的待排关键字序列K[1, 2, …, n]。首先将这个序列划分为M个的子区间（桶）。然后基于某种<strong>映射函数</strong>，将待排序列的关键字k映射到第i个桶中（即桶数组B的下标i），那么该关键字k就作为B[i]中的元素（每个桶B[i]都是一组大小为N/M的序列。）接着对每个桶B[i]中的所有元素进行比较排序（也可以使用快排）。然后依次枚举输出B[0]…B[M]中的全部内容即是一个有序序列。</p><p>桶排序的高效性体现在映射函数：他必须做到，如果关键字<code>k1 &lt; k2</code>,那么 <code>f(k1) &lt; f(k2)</code>。</p><p>举例：</p><p><img src="/images/2019-08-12-排序算法/桶排序.gif" alt="桶排序"></p><p>桶排序利用函数的映射关系，减少了几乎所有的比较工作。实际上，桶排序的f(k)值的计算，其作用就相当于快排中的划分，希尔排序中的子序列，归并排序中的子问题，已经把大量数据分隔成了基本有序的数据块。然后只需要对桶中少量的数据做先进的比较排序即可。</p><p>对N个关键字进行桶排序的时间复杂度分为两个部分：</p><ol><li>循环计算每个关键字的桶映射函数，时间复杂度为O(N)</li><li>利用先进的比较排序算法对每个桶内的所有数据进行排序，时间复杂度为 $\sum O(N_ilog{N_i})$。其中$N_i$为第i个桶的数据量。</li></ol><p>显然第2部分是桶排序性能好坏的决定性因素。所以尽量减少桶内数据的数量是提高效率的唯一办法。（因为基于比较排序的最好平均时间复杂度就是O(nlogn)）。因此需要做到两点：</p><ol><li>映射函数f(k)能够将N个数据平均分配到M个桶中，这样每个桶就有[N/M]个数据量。</li><li>尽量增大桶的数量。极限情况下，每个桶只能得到一个数据（就是计数排序），这样就完全避开了桶内数据的比较排序操作。当然，数据量巨大的情况下，f[k]函数会使桶集合的数量巨大，空间浪费严重。这就是一个时间代价和空间代价的权衡问题。</li></ol><p>所以平均时间复杂度为<br><code>O(N) + O(M*(N/M)*log(N/M)) = O(N+NlogN-NlogM)</code></p><p>所以当N=M时，即极限情况下每个桶只有一个数据能够达到最好效率O(N)。</p><p>例子参考<a href="http://www.codeceo.com/article/10-sort-algorithm-interview.html#0-tsina-1-10490-397232819ff9a47a7b7e80a40613cfe1" target="_blank" rel="noopener">http://www.codeceo.com/article/10-sort-algorithm-interview.html#0-tsina-1-10490-397232819ff9a47a7b7e80a40613cfe1</a>。</p><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>基数排序又是一种和前面排序方式不同的排序方式，基数排序不需要进行记录关键字之间的比较。基数排序是一种借助多关键字排序思想对单逻辑关键字进行排序的方法。所谓的多关键字排序就是有多个优先级不同的关键字。比如说成绩的排序，如果两个人总分相同，则语文高的排在前面，语文成绩也相同则数学高的排在前面。如果对数字进行排序，那么个位、十位、百位就是不同优先级的关键字，如果要进行升序排序，那么个位、十位、百位优先级一次增加。基数排序是通过多次的收分配和收集来实现的，关键字优先级低的先进行分配和收集。</p><h3 id="什么是稳定的排序"><a href="#什么是稳定的排序" class="headerlink" title="什么是稳定的排序"></a>什么是稳定的排序</h3><p>假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/images/2019-08-12-排序算法/排序总结.png" alt="排序总结"></p><p>冒泡排序、选择排序、插入排序三种简单的排序及其变种快速排序、堆排序、希尔排序三种比较高效的排序。基于分治递归思想的归并排序还有计数排序、桶排序、基数排序三种线性排序。我们可以知道排序算法要么简单有效，要么是利用简单排序的特点加以改进，要么是以空间换取时间在特定情况下的高效排序。</p><ol><li>从平均时间来看，快速排序是效率最高的，但快速排序在最坏情况下的时间性能不如堆排序和归并排序。而后者相比较的结果是，在n较大时归并排序使用时间较少，但使用辅助空间较多。</li><li>上面说的简单排序包括除希尔排序之外的所有冒泡排序、插入排序、简单选择排序。其中直接插入排序最简单，但序列基本有序或者n较小时，直接插入排序是好的方法，因此常将它和其他的排序方法，如快速排序、归并排序等结合在一起使用。</li><li>基数排序的时间复杂度也可以写成O(d*n)。因此它最使用于n值很大而关键字较小的的序列。若关键字也很大，而序列中大多数记录的最高关键字均不同，则亦可先按最高关键字不同，将序列分成若干小的子序列，而后进行直接插入排序。</li><li>从方法的稳定性来比较，基数排序是稳定的内排方法，所有时间复杂度为O(n^2)的简单排序也是稳定的。但是快速排序、堆排序、希尔排序等时间性能较好的排序方法都是不稳定的。稳定性需要根据具体需求选择。</li><li>上面的算法实现大多数是使用线性存储结构，像插入排序这种算法用链表实现更好，省去了移动元素的时间。具体的存储结构在具体的实现版本中也是不同的。</li></ol>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Spring框架</title>
      <link href="/2019/08/11/2019-08-11-Java%20Spring%E6%A1%86%E6%9E%B6/"/>
      <url>/2019/08/11/2019-08-11-Java%20Spring%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<p>Spring是一个基于IOC和AOP结构的J2EE系统的框架。<br>IOC反转控制是Spring的基础，简单来说就是创建对象由以前的程序员自己new构造方法来调用，变成了交由Spring创建对象。</p><p>Spring创建对象<br>DI依赖注入Dependency Inject。简单地说就是拿到的对象的属性已经被注入好相关值了，直接使用即可。<br><a id="more"></a> <!-- 摘要 --></p><h3 id="Spring-框架测试"><a href="#Spring-框架测试" class="headerlink" title="Spring 框架测试"></a>Spring 框架测试</h3><h4 id="建立一个类"><a href="#建立一个类" class="headerlink" title="建立一个类"></a>建立一个类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line">package com.how2java.pojo;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author shaoguoliang</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Category &#123;</span><br><span class="line">    private int id;</span><br><span class="line">    private String name;</span><br><span class="line">    </span><br><span class="line">    public int getId()&#123;</span><br><span class="line">    return id;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setId(int id)&#123;</span><br><span class="line">    this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public String getName()&#123;</span><br><span class="line">    return name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setName(String name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在src文件夹下建立applicationContext-xml文件"><a href="#在src文件夹下建立applicationContext-xml文件" class="headerlink" title="在src文件夹下建立applicationContext.xml文件"></a>在src文件夹下建立applicationContext.xml文件</h4><p>在bean中配置类的实例c, 并配置实例属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line">    xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;</span><br><span class="line">    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;</span><br><span class="line">   http://www.springframework.org/schema/beans</span><br><span class="line">   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span><br><span class="line">   http://www.springframework.org/schema/aop</span><br><span class="line">   http://www.springframework.org/schema/aop/spring-aop-3.0.xsd</span><br><span class="line">   http://www.springframework.org/schema/tx</span><br><span class="line">   http://www.springframework.org/schema/tx/spring-tx-3.0.xsd</span><br><span class="line">   http://www.springframework.org/schema/context     </span><br><span class="line">   http://www.springframework.org/schema/context/spring-context-3.0.xsd&quot;&gt;</span><br><span class="line">  </span><br><span class="line">    &lt;bean name=&quot;c&quot; class=&quot;com.how2java.pojo.Category&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;name&quot; value=&quot;category 1&quot; /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">  </span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p><h4 id="测试Spring类"><a href="#测试Spring类" class="headerlink" title="测试Spring类"></a>测试Spring类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line">package com.how2java.test;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line">import com.how2java.pojo.Category;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author shaoguoliang</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class TestSpring &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">    ApplicationContext context = new ClassPathXmlApplicationContext(new String[] &#123;&quot;applicationContext.xml&quot;&#125;);</span><br><span class="line">    </span><br><span class="line">    Category c = (Category) context.getBean(&quot;c&quot;);</span><br><span class="line">    </span><br><span class="line">    System.out.println(c.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="运行测试类，获得结果"><a href="#运行测试类，获得结果" class="headerlink" title="运行测试类，获得结果"></a>运行测试类，获得结果</h4><p><img src="/images/2019-08-11-Java Spring框架/testSpring_result.png" alt="testSpring_result"></p><h4 id="通过applicationContext注入一个对象"><a href="#通过applicationContext注入一个对象" class="headerlink" title="通过applicationContext注入一个对象"></a>通过applicationContext注入一个对象</h4><p>建立一个Product类，其字段中包含Category类。</p><p>那么在applicationContext.xml文件中，按如下方式注入对象。注意<code>ref=&quot;c&quot;</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean name=&quot;p&quot; class=&quot;com.how2java.pojo.Product&quot;&gt;</span><br><span class="line">   &lt;property name=&quot;name&quot; value=&quot;product 1&quot; /&gt;</span><br><span class="line">   &lt;property name=&quot;Category&quot; ref=&quot;c&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p><h3 id="通过注解来注入对象"><a href="#通过注解来注入对象" class="headerlink" title="通过注解来注入对象"></a>通过注解来注入对象</h3><h4 id="通过-对注入对象行为进行注解"><a href="#通过-对注入对象行为进行注解" class="headerlink" title="通过 对注入对象行为进行注解"></a>通过<context:annotation-config> 对注入对象行为进行注解</context:annotation-config></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:annotation-config/&gt;</span><br><span class="line">&lt;bean name=&quot;c&quot; class=&quot;com.how2java.pojo.Category&quot;&gt;</span><br><span class="line">   &lt;property name=&quot;name&quot; value=&quot;category 1&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean name=&apos;p&apos; class=&quot;com.how2java.pojo.Product&quot;&gt;</span><br><span class="line">   &lt;property name=&quot;name&quot; value=&quot;product 1&quot;/&gt;</span><br><span class="line">   &lt;!-- 在Product代码中加入@Autowired注解 --&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>Product代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Product &#123;</span><br><span class="line">    </span><br><span class="line">    private int id;</span><br><span class="line">    private String name;</span><br><span class="line">    @Autowired</span><br><span class="line">    private Category category;</span><br><span class="line">    </span><br><span class="line">    public int getId() &#123;</span><br><span class="line">    return id;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">    return name;</span><br><span class="line">    &#125;</span><br><span class="line">    public Category getCategory() &#123;</span><br><span class="line">    return category;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setId(int id) &#123;</span><br><span class="line">    this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setCategory(Category category) &#123;</span><br><span class="line">    this.category = category;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也可以在setCategory(Category cat) 函数上加@autowired，可以起到同样的效果 </p><p>除了@autowired之外也可以加上@Resource<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Resource(name=&quot;c&quot;)</span><br><span class="line">private Category category;</span><br></pre></td></tr></table></figure></p><h4 id="在applicationContext-xml文件中"><a href="#在applicationContext-xml文件中" class="headerlink" title="在applicationContext.xml文件中"></a>在applicationContext.xml文件中</h4><p>添加<code>&lt;context:component-scan base-package=&quot;com.how2java.pojo&quot;/&gt;</code><br>表示告诉Spring，bean都放在com.how2java.pojo这个包里。注意的是因为配置从applicationContext.xml移植出来了，所以对象初始化要放在类定义里边。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package com.how2java.pojo;</span><br><span class="line"> </span><br><span class="line">import javax.annotation.Resource;</span><br><span class="line"> </span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"> </span><br><span class="line">@Component(&quot;p&quot;)</span><br><span class="line">public class Product &#123;</span><br><span class="line"> </span><br><span class="line">    private int id;</span><br><span class="line">    private String name=&quot;product 1&quot;;</span><br><span class="line">     </span><br><span class="line">    @Autowired</span><br><span class="line">    private Category category;</span><br><span class="line"> </span><br><span class="line">    public int getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setId(int id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public Category getCategory() &#123;</span><br><span class="line">        return category;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public void setCategory(Category category) &#123;</span><br><span class="line">        this.category = category;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package com.how2java.pojo;</span><br><span class="line"> </span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"> </span><br><span class="line">@Component(&quot;c&quot;)</span><br><span class="line">public class Category &#123;</span><br><span class="line">  </span><br><span class="line">    public int getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setId(int id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    private int id;</span><br><span class="line">    private String name=&quot;category 1&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AOP面向切面编程"><a href="#AOP面向切面编程" class="headerlink" title="AOP面向切面编程"></a>AOP面向切面编程</h3><p>AOP 即 Aspect Oriented Program面向切面编程。<br>在面向切面编程的思想里边，把功能分为<strong>核心业务功能</strong>和<strong>周边功能</strong>。<br>核心业务功能，包括登录，增加数据，删除数据等。<br>周边功能，包括性能统计，日志，事务管理等等。</p><p>周边功能在Spring的面向切面编程AOP思想里，即被定义为切面。<br>在面向切面编程AOP的思想里边，核心业务功能和切面功能分别<strong>独立进行开发</strong>，然后把切面功能和核心业务功能“编制”在一起，这就叫做AOP。</p><p>AOP的基本思路：</p><ol><li>功能分为两大类，辅助功能和核心业务功能</li><li>辅助功能和核心业务功能彼此独立进行开发</li><li>比如登录功能，即使没有性能统计和日志输出也可以正常运行</li><li>如果有需要，就把“日志输出”和“登录”功能编织在一起，这样登录的时候就可以看到日志输出了</li><li>辅助功能，又叫做切面，这种能够 <em>选择性的，低耦合的</em> 把切面和核心业务功能结合在一起的编程思想，就叫做切面编程。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//核心功能代码</span><br><span class="line"></span><br><span class="line">package com.how2java.service;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author shaoguoliang</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class ProductService &#123;</span><br><span class="line">    public void doSomeService()&#123;</span><br><span class="line">    System.out.println(&quot;do Some Service&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//切面功能代码1</span><br><span class="line">package com.how2java.aspect;</span><br><span class="line"></span><br><span class="line">import org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author shaoguoliang</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class LoggerAspect &#123;</span><br><span class="line">    </span><br><span class="line">    public Object log(ProceedingJoinPoint joinPoint) throws Throwable&#123;</span><br><span class="line">    System.out.println(&quot;start log:&quot; + joinPoint.getSignature().getName());</span><br><span class="line">    Object object = joinPoint.proceed();</span><br><span class="line">    System.out.println(&quot;end log:&quot; + joinPoint.getSignature().getName());</span><br><span class="line">    return object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//切面功能代码2</span><br><span class="line">package com.how2java.aspect;</span><br><span class="line"></span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">import org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author shaoguoliang</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class PerformerAspect &#123;</span><br><span class="line"></span><br><span class="line">    public Object spend(ProceedingJoinPoint proceedingJoinPoint) throws Throwable&#123;</span><br><span class="line">    </span><br><span class="line">    long start = System.currentTimeMillis();</span><br><span class="line">    System.out.println(&quot;start at &quot; + new Date(start));</span><br><span class="line">    </span><br><span class="line">    Object object = proceedingJoinPoint.proceed();</span><br><span class="line">    </span><br><span class="line">    long end = System.currentTimeMillis();</span><br><span class="line">       System.out.println(&quot;end at&quot;+new Date(end));</span><br><span class="line">       System.out.println(&quot;total time&quot;+(end-start)+&quot;毫秒&quot;);</span><br><span class="line">       </span><br><span class="line">       return object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//在applicationContext.xml中进行耦合</span><br><span class="line"></span><br><span class="line">&lt;beans&gt;</span><br><span class="line">&lt;!-- 声明核心业务 --&gt;</span><br><span class="line">    &lt;bean name=&quot;s&quot; class=&quot;com.how2java.service.ProductService&quot;/&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- 声明日志切面 --&gt;</span><br><span class="line">    &lt;bean id=&quot;loggerAspect&quot; class=&quot;com.how2java.aspect.LoggerAspect&quot;/&gt;</span><br><span class="line">    &lt;bean id=&quot;performerAspect&quot; class=&quot;com.how2java.aspect.PerformerAspect&quot;/&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;aop:config&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;!-- 设置切入点的作用对象和id --&gt;</span><br><span class="line">        &lt;aop:pointcut id=&quot;loggerCutpoint&quot; </span><br><span class="line">        expression=</span><br><span class="line">        &quot;execution(* com.how2java.service.ProductService.*(..)) &quot;/&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;!-- 设置切面id --&gt;</span><br><span class="line">        &lt;aop:aspect id=&quot;logAspect&quot; ref=&quot;loggerAspect&quot;&gt;</span><br><span class="line">            &lt;aop:around pointcut-ref=&quot;loggerCutpoint&quot; method=&quot;log&quot;/&gt;</span><br><span class="line">        &lt;/aop:aspect&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;aop:aspect id=&quot;performAspect&quot; ref=&quot;performerAspect&quot;&gt;</span><br><span class="line">            &lt;aop:around pointcut-ref=&quot;loggerCutpoint&quot; method=&quot;spend&quot;/&gt;</span><br><span class="line">        &lt;/aop:aspect&gt;</span><br><span class="line">        </span><br><span class="line">    &lt;/aop:config&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src="/images/2019-08-11-Java Spring框架/AOP.png" alt="AOP"></p><h4 id="使用注解方式配置AOP"><a href="#使用注解方式配置AOP" class="headerlink" title="使用注解方式配置AOP"></a>使用注解方式配置AOP</h4><p>核心功能<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.how2java.service;</span><br><span class="line"></span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author shaoguoliang</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">@Component(&quot;s&quot;)</span><br><span class="line">public class ProductService &#123;</span><br><span class="line">    public void doSomeService()&#123;</span><br><span class="line">    System.out.println(&quot;do Some Service&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>切片功能<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package com.how2java.aspect;</span><br><span class="line"></span><br><span class="line">import org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line">import org.aspectj.lang.annotation.Around;</span><br><span class="line">import org.aspectj.lang.annotation.Aspect;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author shaoguoliang</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">@Aspect</span><br><span class="line">@Component</span><br><span class="line">public class LoggerAspect &#123;</span><br><span class="line">    @Around(value = &quot;execution(* com.how2java.service.ProductService.*(..))&quot;)</span><br><span class="line">    public Object log(ProceedingJoinPoint joinPoint) throws Throwable&#123;</span><br><span class="line">    System.out.println(&quot;start log:&quot; + joinPoint.getSignature().getName());</span><br><span class="line">    Object object = joinPoint.proceed();</span><br><span class="line">    System.out.println(&quot;end log:&quot; + joinPoint.getSignature().getName());</span><br><span class="line">    return object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>applicationContext.xml配置文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:component-scan base-package=&quot;com.how2java.aspect&quot;/&gt;</span><br><span class="line">&lt;context:component-scan base-package=&quot;com.how2java.service&quot;/&gt;</span><br><span class="line">&lt;aop:aspectj-autoproxy/&gt;</span><br></pre></td></tr></table></figure></p><p>其运行结果与上述相类似。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Junit单元测试</title>
      <link href="/2019/08/10/2019-08-10-Java%E7%9A%84Junit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
      <url>/2019/08/10/2019-08-10-Java%E7%9A%84Junit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>使用Junit框架来进行Java单元测试应对一下两种情况：</p><ol><li>增加的测试可能会破坏原来的测试逻辑，并且增加的测试需要在原来测试的基础上修改</li><li>测试成功或测试失败需要有标记，在测试量很大的时候可以进行快速定位<a id="more"></a> <!-- 摘要 --></li></ol><h3 id="Junit的使用"><a href="#Junit的使用" class="headerlink" title="Junit的使用"></a>Junit的使用</h3><ol><li>下载juint.jar导入到项目中。</li><li><p>创建TestCase类，并创建方法如下：<br>这是一个由@Test进行注解，表示这个方法是一个测试方法。<br>Assert.assertEquals表示对result的期待是3，如果是其他数值就无法通过测试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCase</span></span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSum1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = SumUtil.sum1(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    Assert.assertEquals(result, <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行junit Test。 Run As-&gt;Junit Test</p></li><li>测试结果</li></ol><p><img src="/images/2019-08-10-Java的Junit单元测试/Junit测试结果.png" alt="Junit测试"></p><h4 id="Before和-After"><a href="#Before和-After" class="headerlink" title="@Before和@After"></a>@Before和@After</h4><p>@Before和@After也是常见的测试框架注解，用来标注在测试开始之前做的事情和结束之后做的事情。</p><h3 id="使用TestSuite执行多个测试"><a href="#使用TestSuite执行多个测试" class="headerlink" title="使用TestSuite执行多个测试"></a>使用TestSuite执行多个测试</h3><p>测试文件包含多个测试程序，那么如何全部执行而不是一个一个执行呢。<br>JUnit用例都是在Runner（运行器）来执行的。通过它，可以为这个测试类指定一个特定的Runner。<br>@RunWith指定了Suite类，说明这个TestSuite类是一个套件。通过@Suite.SuiteClasses指定了要执行的测试类（这些类中的所有用例都会执行）。</p><p><em>需要注意的是，这个TestSuite类本身用例则不会执行了</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line">package juinttest;</span><br><span class="line"></span><br><span class="line">import org.junit.runner.RunWith;</span><br><span class="line">import org.junit.runners.Suite;</span><br><span class="line">import org.junit.runners.Suite.SuiteClasses;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author shaoguoliang</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">@RunWith(Suite.class)</span><br><span class="line">@SuiteClasses(&#123;Test1.class, Test2.class&#125;)</span><br><span class="line"></span><br><span class="line">public class Testsuite &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="在maven中添加juint"><a href="#在maven中添加juint" class="headerlink" title="在maven中添加juint"></a>在maven中添加juint</h3><p>在pom.xml的依赖包中添加如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.3.1&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hive介绍与安装</title>
      <link href="/2019/08/07/2019-08-07-Hive%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%89%E8%A3%85/"/>
      <url>/2019/08/07/2019-08-07-Hive%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>参考<a href="http://www.hainiubl.com/topics/103" target="_blank" rel="noopener">http://www.hainiubl.com/topics/103</a><br><a id="more"></a> <!-- 摘要 --></p><h3 id="Hive介绍"><a href="#Hive介绍" class="headerlink" title="Hive介绍"></a>Hive介绍</h3><p>Hive是一个机遇Hadoop的开源数据仓库工具，用于存储和处理海量结构化数据。提供了类似于SQL语法的HQL语句作为数据访问接口。</p><h4 id="Hive优缺点"><a href="#Hive优缺点" class="headerlink" title="Hive优缺点"></a>Hive优缺点</h4><p><strong>优点</strong>：</p><ul><li>Hive使用类SQL查询语法，最大限度的实现了和SQL标准的兼容</li><li>使用JDBC接口/ODBC接口，开发人员更易开发应用</li><li>以<strong>MapReduce</strong>作为计算引擎、HDFS作为存储系统，为超大数据集提供计算和扩展能力。</li><li>有统一的元数据管理（Derby、MySql等），可以与Pig和Spark共享</li></ul><p><strong>缺点</strong>：</p><ul><li>HQL表达能力有限，不支持UPDATE、非等值连接、DELETE、INSERT单条等</li><li>Hive自动生成MapReduce作业，HQL调优困难</li><li>粒度较粗，可控性差</li></ul><h4 id="Hive与传统数据库的区别"><a href="#Hive与传统数据库的区别" class="headerlink" title="Hive与传统数据库的区别"></a>Hive与传统数据库的区别</h4><ul><li>存储文件的系统不同：Hive使用的是HDFS，传统数据库使用的是服务器本地的文件系统</li><li>Hive使用mapreduce做运算，比传统数据库相比运算规模要大很多</li><li>关系数据库是为了实时查询的业务进行设计的，Hive是为了海量数据做数据挖掘设计的，实时性很差。实时性的区别导师Hive的应用场景和关系数据库有非常大的不同</li><li>Hive很容易扩展自己的存储能力和计算能力，而关系型数据库在这方面比数据库差很多</li></ul><h4 id="Hive组成"><a href="#Hive组成" class="headerlink" title="Hive组成"></a>Hive组成</h4><p>Hive由服务端组件和客户端组件构成。<br>服务端组件包括：</p><ul><li>Driver组件：包括Compiler、Optimizer和Executor。作用是将HQL语句进行解析，编译优化，生成执行计划。然后调用底层的mapreduce计算框架。</li><li>Metastore组件：元数据服务组件，这个组件存储Hive的元数据。<strong>Hive元数据存储在关系型数据库中</strong>，Hive支持Derby和MySql。Hive支持把Metastore服务独立出来，安装到远程的服务器集群中，从而解耦Hive服务和Metastore服务，保证Hive运行的健壮性。</li><li>Thrift服务：Thrift是Facebook开发的一个软件框架，可以用来进行可扩展且跨语言的服务的开发，Hive集成这项服务可以用不同的编程语言调用Hive接口</li></ul><p>客户端组件：</p><ul><li>CLI：Command Line Interface命令行接口</li><li>JDBC/ODBC：Hive架构的JDBC和ODBC接口是建立在Thrift客户端之上的。</li><li>WEBGUI：Hive客户端提供了一种通过网页的方式访问Hive所提供的服务。这个接口对应Hive的HWI（Hive Web Interface），使用前要启动HWI服务。</li></ul><p><img src="/images/2019-08-07-Hive介绍与安装/HiveStruct.png" alt="HiveStruct"></p><h3 id="Hive安装"><a href="#Hive安装" class="headerlink" title="Hive安装"></a>Hive安装</h3><p>环境MacOS</p><h4 id="安装MySql"><a href="#安装MySql" class="headerlink" title="安装MySql"></a>安装MySql</h4><p>这一步我的系统之前已经安装过了MySql。</p><h4 id="解压配置环境变量"><a href="#解压配置环境变量" class="headerlink" title="解压配置环境变量"></a>解压配置环境变量</h4><ul><li>将bin压缩包解压至/usr/local/路径</li><li>配置环境变量/etc/profile<br><code>export HIVE_HOME=/usr/local/hive</code><br><code>export HIVE_CONF_DIR=/usr/local/hive/conf</code></li></ul><h4 id="本地环境安装hive"><a href="#本地环境安装hive" class="headerlink" title="本地环境安装hive"></a>本地环境安装hive</h4><ul><li><p>mysql建立新的用户（注意我使用的是mysql8.0，在grant all privileges语句中可能有版本差异）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#命令行进入mysql</span><br><span class="line">mysql -u root -p</span><br><span class="line">#数据库用户配置</span><br><span class="line">create user &apos;hive&apos;@&apos;localhost&apos; identified by &apos;000000&apos;;</span><br><span class="line">grant all privileges on *.* to &apos;hive&apos;@&apos;localhost&apos; with grant option;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure></li><li><p>下载Mysql-connector-Java 8.0 并解压放到hive/lib目录</p></li><li><p>配置hive-site.xml<br>注意以下的配置需要自行搜索寻找，不在同一个地方</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 数据库地址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionURL<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>jdbc:mysql://localhost:3306/hive<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>JDBC connect string for a JDBC metastore<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 数据库连接驱动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionDriverName<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">value</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">description</span>&gt;</span>Driver class name for a JDBC metastore<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 数据库名字--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionUserName<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">value</span>&gt;</span>hive<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">description</span>&gt;</span>Username to use against metastore database<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 数据库密码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionPassword<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">value</span>&gt;</span>000000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">description</span>&gt;</span>password to use against metastore database<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 下面--四个---的配置都是临时存储目录，自己新建然后填上绝对路径--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 我设置的是/Users/shaoguoliang/hiveIOtmp--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.exec.local.scratchdir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/usr/Hadoop/hive/iotmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Local scratch space for Hive jobs<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.downloaded.resources.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/usr/Hadoop/hive/iotmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Temporary local directory for added resources in the remote file system.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.server2.logging.operation.log.location<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/usr/Hadoop/hive/iotmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Top level directory where operation logs are stored if logging functionality is enabled<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.querylog.location<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/usr/Hadoop/hive/iotmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Location of Hive run time structured log file<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置hive-env.sh，从template复制文件到本地目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 在末尾添加,其实不添加也可以</span><br><span class="line"> export HIVE_CONF_DIR=/usr/local/hive/conf</span><br></pre></td></tr></table></figure></li><li><p>配置hive-log4j.properties，从template复制文件到本地目录</p></li><li>在/hive/bin目录下，新建元数据schema<br><code>./schematool -initSchema -dbType mysql</code><br>这里出现了问题是：</li></ul><ol><li>报错出现找不到mysql Driver，发现是解压之后要把jar包包含在/hive/lib路径下</li><li>报错出现找不到hive database，通过mysql创建<code>create database hive</code></li></ol><ul><li><p>启动hadoop，启动mysql<br>注意这里一定要确认hadoop是否成功启动，是否成功启动namenode和datanode（单机模式）<br>如果发现namenode挂了，去查看<a href="/2019/06/06/2019-06-06-hadoop_hdfs/" title="Hadoop HDFS 初始与操作">Hadoop HDFS 初始与操作</a><br>在hdfs-site.xml中添加</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.name.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/usr/local/hadoop/hdfs/name<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>namenode上存储hdfs名字空间元数据 <span class="tag">&lt;/<span class="name">description</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.data.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/usr/local/hadoop/hdfs/data<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">description</span>&gt;</span>datanode上数据块的物理存储位置<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在hive/bin下运行hive<br><img src="/images/2019-08-07-Hive介绍与安装/启动hive.png" alt="启动hive"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark WordCount 探索RDD编程</title>
      <link href="/2019/08/06/2019-08-06-SparkWordCount%E6%8E%A2%E7%B4%A2RDD%E7%BC%96%E7%A8%8B/"/>
      <url>/2019/08/06/2019-08-06-SparkWordCount%E6%8E%A2%E7%B4%A2RDD%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>通过编写WordCount来探索RDD编程，还是没能完全改成函数式编程，所以这里的代码主要使用了Java API，即使是函数式编程也是在Java1.8下的。没有在scala下。稍微有些不习惯scala下var和val自动定义变量类型。<br><a id="more"></a> <!-- 摘要 --></p><h3 id="SparkConf"><a href="#SparkConf" class="headerlink" title="SparkConf"></a>SparkConf</h3><p>每一个Spark任务都需要一个driver执行所有的操作，那么每一个spark程序的开头都是定义这么一个driver。在wordcount应用中，只需要定义driver的名字和master就可以了。</p><h3 id="SparkContext"><a href="#SparkContext" class="headerlink" title="SparkContext"></a>SparkContext</h3><p>SparkContext是Spark应用程序中用到的第一个类。SparkContext为Spark的主要入口点，简明扼要，如把Spark集群当作服务端那Spark Driver就是客户端，SparkContext则是客户端的核心。<br>SparkContext用于连接Spark集群、创建RDD、累加器（accumlator）、广播变量（broadcast variables）。</p><p>wordcount程序基本只需要创建RDD，那么创建RDD有两种基本方式：</p><ul><li>从文件中读取 textFile()</li><li>parallelize()</li></ul><p>例如：<br><strong>通过textFile()建立</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SparkConf conf = new SparkConf();</span><br><span class="line">conf.setAppName(&quot;SecondarySort&quot;);</span><br><span class="line">conf.setMaster(&quot;local&quot;);</span><br><span class="line">JavaSparkContext sc = new JavaSparkContext(conf);</span><br><span class="line"></span><br><span class="line">//导入文本</span><br><span class="line">JavaRDD&lt;String&gt; input = sc.textFile(src_file);</span><br></pre></td></tr></table></figure></p><p>注意src_file的路径有两种方式：</p><ul><li>位于hdfs上的路径采用<code>hdfs://</code>前缀</li><li>位于主机本地上的路径采用<code>file://</code>前缀</li></ul><p><strong>通过parallelize()建立</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SparkConf conf = new SparkConf().setAppName(&quot;text&quot;);</span><br><span class="line">conf.setMaster(&quot;local&quot;);</span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(1,2,3,4);</span><br><span class="line">JavaSparkContext sc = new JavaSparkContext(conf);</span><br><span class="line">JavaRDD&lt;Integer&gt; numberRDD = sc.parallelize(list, 4);</span><br></pre></td></tr></table></figure></p><h3 id="RDD操作"><a href="#RDD操作" class="headerlink" title="RDD操作"></a>RDD操作</h3><p>我们想要实现统计一段文本中出现频率最高的单词。也就是说结果是单词按照词频降序排列。那么应该想到有以下步骤：</p><ol><li>分词，String-&gt;String.iterator 从长文本变为单词迭代器。这就设计到了转换，使用flatMap<br><strong>map与flatMap的区别：</strong></li></ol><ul><li>map()是将函数用于RDD中的每个元素，将返回值构成新的RDD。</li><li>flatmap()是将函数应用于RDD中的每个元素，将<strong>返回的迭代器</strong>的所有内容构成新的RDD</li></ul><ol><li>赋值词频1，String-&gt; <string, 1> 用到map</string,></li><li>合并词频，<string, 1> -&gt; <string, v> 用到reduce</string,></string,></li><li>按照词频排序，首先要将key变为词频计数。<string, v> -&gt; <v, string>, 用到map</v,></string,></li><li>按key排序，用到sortByKey(false)。false表示降序</li><li>输出结果并保存。启用设定格式，去掉括号，用到map</li></ol><p>整体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">package wordcountsort;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line"></span><br><span class="line">import org.apache.spark.SparkConf;</span><br><span class="line">import org.apache.spark.api.java.JavaPairRDD;</span><br><span class="line">import org.apache.spark.api.java.JavaRDD;</span><br><span class="line">import org.apache.spark.api.java.JavaSparkContext;</span><br><span class="line">import org.apache.spark.api.java.function.FlatMapFunction;</span><br><span class="line">import org.apache.spark.api.java.function.Function;</span><br><span class="line">import org.apache.spark.api.java.function.Function2;</span><br><span class="line">import org.apache.spark.api.java.function.PairFunction;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import scala.Tuple2;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author shaoguoliang</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class WordCountSort &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">    </span><br><span class="line">    String src_file = &quot;file:///Users/shaoguoliang/Workspaces/MyEclipse 2017 CI/spark-rdd/data/wordtext.txt&quot;;</span><br><span class="line">    String dest_file = &quot;file:///Users/shaoguoliang/Workspaces/MyEclipse 2017 CI/spark-rdd/data/wordtext_result.txt&quot;;</span><br><span class="line">    </span><br><span class="line">    SparkConf conf = new SparkConf();</span><br><span class="line">    conf.setAppName(&quot;SecondarySort&quot;);</span><br><span class="line">    conf.setMaster(&quot;local&quot;);</span><br><span class="line">    JavaSparkContext sc = new JavaSparkContext(conf);</span><br><span class="line">    </span><br><span class="line">    //导入文本</span><br><span class="line">    JavaRDD&lt;String&gt; input = sc.textFile(src_file);</span><br><span class="line">    </span><br><span class="line">    //分词</span><br><span class="line">    //JavaRDD&lt;String&gt; words = input.flatMap(x-&gt; Arrays.asList(x.split(&quot; &quot;)).iterator() );</span><br><span class="line">    JavaRDD&lt;String&gt; words = input.flatMap(new FlatMapFunction&lt;String, String&gt;() &#123;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public Iterator&lt;String&gt; call(String t) throws Exception &#123;</span><br><span class="line">    // TODO Auto-generated method stub</span><br><span class="line">    return Arrays.asList(t.split(&quot; &quot;)).iterator();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    //构建&lt;word, count&gt;, 并且reduce</span><br><span class="line">    JavaPairRDD&lt;String, Integer&gt; wordPair1 = words.mapToPair(new PairFunction&lt;String, String, Integer&gt;() &#123;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public Tuple2&lt;String, Integer&gt; call(String t) throws Exception &#123;</span><br><span class="line">    // TODO Auto-generated method stub</span><br><span class="line">    return new Tuple2&lt;String, Integer&gt;(t, 1);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    JavaPairRDD&lt;String, Integer&gt; wordPair = wordPair1.reduceByKey(new Function2&lt;Integer, Integer, Integer&gt;() &#123;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public Integer call(Integer v1, Integer v2) throws Exception &#123;</span><br><span class="line">    // TODO Auto-generated method stub</span><br><span class="line">    return v1+v2;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    //因为只能对key进行排序，我们要统计词频出现最多的单词，将key， value倒置</span><br><span class="line">    //JavaPairRDD&lt;Integer, String&gt; wordCount = wordPair.mapToPair(x-&gt; new Tuple2(x._2, x._1));</span><br><span class="line">    JavaPairRDD&lt;Integer, String&gt; wordCount = wordPair.mapToPair(new PairFunction&lt;Tuple2&lt;String,Integer&gt;, Integer, String&gt;() &#123;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public Tuple2&lt;Integer, String&gt; call(Tuple2&lt;String, Integer&gt; t) throws Exception &#123;</span><br><span class="line">    // TODO Auto-generated method stub</span><br><span class="line">    return new Tuple2&lt;Integer, String&gt;(t._2, t._1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    //降序排列</span><br><span class="line">    JavaPairRDD&lt;Integer, String&gt; wordCountSort = wordCount.sortByKey(false);</span><br><span class="line">    </span><br><span class="line">    //去掉括号</span><br><span class="line">    //JavaRDD&lt;String&gt; wordCountOutput = wordCountSort.map(x-&gt; new String(x._1 + &quot;,&quot; + x._2));</span><br><span class="line">    JavaRDD&lt;String&gt; wordCountOutput = wordCountSort.map(new Function&lt;Tuple2&lt;Integer,String&gt;, String&gt;() &#123;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public String call(Tuple2&lt;Integer, String&gt; v1) throws Exception &#123;</span><br><span class="line">    // TODO Auto-generated method stub</span><br><span class="line">    return v1._1 + &quot;,&quot; + v1._2;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    //输出</span><br><span class="line">    wordCountOutput.foreach(x-&gt; System.out.println(x));</span><br><span class="line">    </span><br><span class="line">    wordCountOutput.saveAsTextFile(dest_file);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="编译提交"><a href="#编译提交" class="headerlink" title="编译提交"></a>编译提交</h3><p>maven编译参考<a href="/2019/07/10/2019-07-10-Spark环境搭建与RDD编程基础/" title="Spark环境搭建与RDD编程基础">Spark环境搭建与RDD编程基础</a></p><p>提交：<br><code>spark-submit --master &quot;localhost:7077&quot; ./spark-rdd-0.0.1-SNAPSHOT.jar</code></p><h3 id="RDD-Tips"><a href="#RDD-Tips" class="headerlink" title="RDD Tips"></a>RDD Tips</h3><p>在RDD编程的过程中一定要先想好你想要的结果是什么，然后再去选择合适的RDD编程架构。</p><p>在上述代码中，结果会出现如下：</p><p><img src="/images/2019-08-06-SparkWordCount探索RDD编程/统计错误.png" alt="统计错误"></p><p>所以在分词的过程中，不仅要添加<code>空格</code>还要添加可能的标点符号。</p><p>所以需要使用正则表达式进行字符串分隔。</p><p><code>return Arrays.asList(t.split(&quot;[\\p{Punct}\\s]+&quot;)).iterator();</code></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark启动历史日志以及Web UI</title>
      <link href="/2019/08/05/2019-08-05-Spark%E5%90%AF%E5%8A%A8%E5%8E%86%E5%8F%B2%E6%97%A5%E5%BF%97/"/>
      <url>/2019/08/05/2019-08-05-Spark%E5%90%AF%E5%8A%A8%E5%8E%86%E5%8F%B2%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p>在使用Spark的过程中，我们有时候会关注job的历史日志，但在spark的默认设置下，历史日志是关闭的。本篇记录如何启动spark的历史日志。</p><p>环境：</p><ul><li>单机伪分布</li><li>MacOS系统</li><li>Hadoop-2.9.2</li><li>Spark-2.4.3<a id="more"></a> <!-- 摘要 --></li></ul><h3 id="Spark-伪分布安装"><a href="#Spark-伪分布安装" class="headerlink" title="Spark 伪分布安装"></a>Spark 伪分布安装</h3><p>接上文 <a href="/2019/07/10/2019-07-10-Spark环境搭建与RDD编程基础/" title="Spark环境搭建与RDD编程基础">Spark环境搭建与RDD编程基础</a><br>在将spark安装包解压并添加环境变量后，我们需要修改spark安装包用户权限。<br><code>chown -R shaoguoliang:staff spark-2.4.3-bin-hadoop2.7</code> 为了防止之后运行出现权限问题。</p><h4 id="修改Spark配置文件"><a href="#修改Spark配置文件" class="headerlink" title="修改Spark配置文件"></a>修改Spark配置文件</h4><p>配置文件为 <code>conf/spark-env.sh</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 配置文件修改如下</span><br><span class="line">export JAVA_HOME=/usr/local/jdk</span><br><span class="line">export SCALA_HOME=/usr/local/scala</span><br><span class="line">export SPARK_WORKER_MEMORY=1G</span><br><span class="line">export HADOOP_HOME=/usr/local/hadoop</span><br><span class="line">export HADOOP_CONF_DIR=/usr/local/hadoop/etc/hadoop</span><br><span class="line">export SPARK_MASTER_IP=localhost</span><br></pre></td></tr></table></figure></p><h4 id="启动hadoop"><a href="#启动hadoop" class="headerlink" title="启动hadoop"></a>启动hadoop</h4><p>在$HADOOP_HOME/sbin下启动<code>./start-all.sh</code><br>此时运行<code>jps</code>命令会得到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">83603 NodeManager</span><br><span class="line">74787</span><br><span class="line">83012 SecondaryNameNode</span><br><span class="line">82532 DataNode</span><br><span class="line">83143 ResourceManager</span><br><span class="line">85677 Jps</span><br></pre></td></tr></table></figure></p><h4 id="启动spark"><a href="#启动spark" class="headerlink" title="启动spark"></a>启动spark</h4><p>在$SPARK_HOME/sbin下启动<code>./start-all.sh</code><br>此时运行<code>jps</code>命令会得到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">86112 Worker  #spark</span><br><span class="line">83603 NodeManager</span><br><span class="line">74787</span><br><span class="line">83012 SecondaryNameNode</span><br><span class="line">82532 DataNode</span><br><span class="line">83143 ResourceManager</span><br><span class="line">85720 Master  #spark</span><br><span class="line">86157 Jps</span><br></pre></td></tr></table></figure></p><h4 id="浏览器查看localhost-8080"><a href="#浏览器查看localhost-8080" class="headerlink" title="浏览器查看localhost:8080"></a>浏览器查看localhost:8080</h4><p><img src="/images/2019-08-05-Spark启动历史日志/Spark浏览器查看状态.png" alt="Spark浏览器查看状态"><br>此时说明spark启动成功</p><h3 id="Spark查看历史日志"><a href="#Spark查看历史日志" class="headerlink" title="Spark查看历史日志"></a>Spark查看历史日志</h3><ol><li>修改配置文件 spark-defaults.conf 添加如下内容<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 修改配置信息</span><br><span class="line">spark.eventLog.enabled          true</span><br><span class="line"># 设置hdfs目录，需要和自己的hadoop目录匹配</span><br><span class="line">spark.eventLog.dir              hdfs://localhost:9000/var/log/spark</span><br><span class="line">spark.eventLog.compress         true</span><br></pre></td></tr></table></figure></li></ol><p>注意spark.eventLog.dir是log文件最终存放的地点，如果是配置在hdfs上就采取上述地址<br>如果是配置在本地主机上，那么要改为<code>file:///Users/shaoguoliang/var/log/spark</code></p><ol><li>修改配置文件 spark-env.sh<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//配置文件最后加入</span><br><span class="line">export SPARK_HISTORY_OPTS=&quot;-Dspark.history.ui.port=18080 -Dspark.history.retainedApplications=3 -Dspark.history.fs.logDirectory=hdfs:/localhost:9000/var/log/spark&quot;</span><br></pre></td></tr></table></figure></li></ol><p>同上，如果是保存在本地主机上，那么最后一项要改为相应的位置。<br>同时如果想要修改显示web端口位置，那么更改相应的port NO.</p><ol><li>创建目录日志<br>spark不会创建目录日志，需要我们自己去创建<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//首先进入hadoop的bin目录</span><br><span class="line">cd /usr/local/hadoop/bin</span><br><span class="line">//创建文件夹命令</span><br><span class="line">./hadoop fs -mkdir /var</span><br><span class="line">./hadoop fs -mkdir /var/log</span><br><span class="line">./hadoop fs -mkdir /var/log/spark</span><br></pre></td></tr></table></figure></li></ol><p>如果是保存在本地主机上，那么在相应位置建立文件夹</p><ol><li>启动spark历史日志web端<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//进入spark的bin目录</span><br><span class="line">cd /usr/local/spark/sbin</span><br><span class="line">//如果spark集群正在启动，首先停止集群</span><br><span class="line">./stop-all.sh</span><br><span class="line">//重新启动集群</span><br><span class="line">./start-all.sh</span><br><span class="line">//启动job历史端口</span><br><span class="line">./start-history-server.sh</span><br></pre></td></tr></table></figure></li></ol><p><strong>一定要启动最后一个 start-history-server</strong>，否则log文件只会存在上述建立的log文件目录中，并不会以web显示的方式展现出来。</p><ol><li>查看spark日志是否启动成功 localhost:18080</li></ol><p><img src="/images/2019-08-05-Spark启动历史日志/spark-localhost_18080.png" alt="spark18080"></p><p>做了一个union操作可以通过DAG图来展示</p><p><img src="/images/2019-08-05-Spark启动历史日志/DAG-union-operation.png" alt="spark18080"></p><h3 id="Spark-Web-UI解析"><a href="#Spark-Web-UI解析" class="headerlink" title="Spark Web UI解析"></a>Spark Web UI解析</h3><p>参考<a href="https://blog.csdn.net/qq_27639777/article/details/81069893" target="_blank" rel="noopener">https://blog.csdn.net/qq_27639777/article/details/81069893</a></p><h4 id="Jobs"><a href="#Jobs" class="headerlink" title="Jobs"></a>Jobs</h4><p>在提交spark任务运行后，日志中会输出tracking URL即任务的日志链接。在浏览器中打开tracking URL后，默认进入Jobs页。Jobs展示的是整个spark应用任务的job整体信息：</p><ul><li>User: spark任务提交的用户，用以进行权限控制与资源分配。</li><li>Total Uptime: spark application总的运行时间，从appmaster开始运行到结束的整体时间。</li><li>Scheduling Mode: application中task任务的调度策略，由参数spark.scheduler.mode来设置，可选的参数有FAIR和FIFO，默认是FIFO。这与yarn的资源调度策略的层级不同，yarn的资源调度是针对集群中不同application间的，而spark scheduler mode则是针对application内部task set级别的资源分配，不同FAIR策略的参数配置方式与yarn中FAIR策略的配置方式相同。</li><li>Completed Jobs: 已完成Job的基本信息，如想查看某一个Job的详细情况，可点击对应Job进行查看。</li><li>Active Jobs: 正在运行的Job的基本信息。</li><li>Event Timeline: 在application应用运行期间，Job和Exector的增加和删除事件进行图形化的展现。这个就是用来表示调度job何时启动何时结束，以及Excutor何时加入何时移除。我们可以很方便看到哪些job已经运行完成，使用了多少Excutor，哪些正在运行。</li></ul><p>Job间默认是串行提交运行的，如果Job间没有依赖可以使用<strong>多线程</strong>并行提交job，实现job多并发。</p><h4 id="Job-details"><a href="#Job-details" class="headerlink" title="Job details"></a>Job details</h4><p>点进一个Job后可以看到如下信息：</p><ul><li>Staus: 展示Job的当前状态信息。</li><li>Active Stages: 正在运行的stages信息，点击某个stage可进入查看具体的stage信息。</li><li>Pending Stages: 排队的stages信息，根据解析的DAG图stage可并发提交运行，而有依赖的stage未运行完时则处于等待队列中。</li><li>Completed Stages: 已经完成的stages信息。</li><li>Event Timeline: 展示当前Job运行期间stage的提交与结束、Executor的加入与退出等事件信息。</li><li>DAG Visualization: 当前Job所包含的所有stage信息（stage中包含的明细的tranformation操作），以及各stage间的DAG依赖图。DAG也是一种调度模型，在spark的作业调度中，有很多作业存在依赖关系，所以没有依赖关系的作业可以并行执行，有依赖的作业不能并行执行。 </li></ul><h4 id="Stages"><a href="#Stages" class="headerlink" title="Stages"></a>Stages</h4><ul><li>Total time across all tasks: 当前stage中所有task花费的时间和。</li><li>Locality Level Summary: 不同本地化级别下的任务数，本地化级别是指数据与计算间的关系（PROCESS_LOCAL进程本地化：task与计算的数据在同一个Executor中。NODE_LOCAL节点本地化：情况一：task要计算的数据是在同一个Worker的不同Executor进程中；情况二：task要计算的数据是在同一个Worker的磁盘上，或在 HDFS 上，恰好有 block 在同一个节点上。RACK_LOCAL机架本地化，数据在同一机架的不同节点上：情况一：task计算的数据在Worker2的Executor中；情况二：task计算的数据在Worker2的磁盘上。ANY跨机架，数据在非同一机架的网络上，速度最慢）。</li><li>Input Size/Records: 输入的数据字节数大小/记录条数。</li><li>Shuffle Write: 为下一个依赖的stage提供输入数据，shuffle过程中通过网络传输的数据字节数/记录条数。应该尽量减少shuffle的数据量及其操作次数，这是spark任务优化的一条基本原则。</li><li>DAG Visualization: 当前stage中包含的详细的tranformation操作流程图。</li><li>Metrics: 当前stage中所有task的一些指标（每一指标项鼠标移动上去后会有对应解释信息）统计信息。</li><li>Event Timeline: 清楚地展示在每个Executor上各个task的各个阶段的时间统计信息，可以清楚地看到task任务时间是否有明显倾斜，以及倾斜的时间主要是属于哪个阶段，从而有针对性的进行优化。</li><li>Aggregated Metrics by Executor: 将task运行的指标信息按excutor做聚合后的统计信息，并可查看某个Excutor上任务运行的日志信息。</li><li>Tasks: 当前stage中所有任务运行的明细信息，是与Event Timeline中的信息对应的文字展示（可以点击某个task查看具体的任务日志）。 </li></ul><h4 id="Environment"><a href="#Environment" class="headerlink" title="Environment"></a>Environment</h4><p>Environment选项卡提供有关Spark应用程序（或SparkContext）中使用的各种属性和环境变量的信息。用户可以通过这个选项卡得到非常有用的各种Spark属性信息，而不用去翻找属性配置文件。</p><h4 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h4><p>Executors选项卡提供了关于内存、CPU核和其他被Executors使用的资源的信息。这些信息在Executor级别和汇总级别都可以获取到。一方面通过它可以看出来每个excutor是否发生了数据倾斜，另一方面可以具体分析目前的应用是否产生了大量的shuffle，是否可以通过数据的本地性或者减小数据的传输来减少shuffle的数据量。</p><ul><li>Summary: 该application运行过程中使用Executor的统计信息。</li><li>Executors: 每个Excutor的详细信息（包含driver），可以点击查看某个Executor中任务运行的详细日志。 </li></ul><h4 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h4><p>SQL选项卡（只有执行了spark SQL查询才会有SQL选项卡）可以查看SQL执行计划的细节，它提供了SQL查询的DAG以及显示Spark如何优化已执行的SQL查询的查询计划。 </p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java利用Log4J输出日志文件</title>
      <link href="/2019/08/04/2019-08-04-Java%E5%88%A9%E7%94%A8Log4J%E8%BE%93%E5%87%BA%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6/"/>
      <url>/2019/08/04/2019-08-04-Java%E5%88%A9%E7%94%A8Log4J%E8%BE%93%E5%87%BA%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>学习Java Log4J日志文件<br><a id="more"></a> <!-- 摘要 --><br>Log4j是Apache开源的日志组件，可以通过maven进行jar包导入，也可以从官网上下最新的jar包。</p><h3 id="log4j设置"><a href="#log4j设置" class="headerlink" title="log4j设置"></a>log4j设置</h3><p>在src统计目录创建并设置log4j.properties进行设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#设置日志输出等级为debug，低于debug就不会输出了</span><br><span class="line">#设置日志输出到两个地方stdout,和R</span><br><span class="line">log4j.rootLogger=debug, stdout, R</span><br><span class="line"></span><br><span class="line">#输出信息到控制台stdout，并设置输出格式为PatternLayout</span><br><span class="line">log4j.appender.stdout=org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.stdout.layout=org.apache.log4j.PatternLayout</span><br><span class="line"> </span><br><span class="line"># Pattern to output the caller&apos;s file name and line number.</span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern=%5p [%t] (%F:%L) - %m%n</span><br><span class="line"> </span><br><span class="line">#输出信息到第二个地方R，文件名为 project_root/example.log ，文件最大为100K，最多滚动5个文件</span><br><span class="line">log4j.appender.R=org.apache.log4j.RollingFileAppender</span><br><span class="line">log4j.appender.R.File=example.log</span><br><span class="line">log4j.appender.R.MaxFileSize=100KB</span><br><span class="line">log4j.appender.R.MaxBackupIndex=5</span><br><span class="line">log4j.appender.R.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.R.layout.ConversionPattern=%p %t %c - %m%n</span><br></pre></td></tr></table></figure></p><h3 id="log4j-输出格式"><a href="#log4j-输出格式" class="headerlink" title="log4j 输出格式"></a>log4j 输出格式</h3><ul><li>%c 输出日志信息所属的类的全名</li><li>%d 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式,比如：%d{yyy-MM-dd HH:mm:ss }，输出类似：2002-10-18- 22：10：28</li><li>%f 输出日志信息所属的类的类名</li><li>%l 输出日志事件的发生位置，即输出日志信息的语句处于它所在的类的第几行</li><li>%m 输出代码中指定的信息，如log(message)中的message</li><li>%n 输出一个回车换行符，Windows平台为“rn”，Unix平台为“n”</li><li>%p 输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL。如果是调用debug()输出的，则为DEBUG，依此类推</li><li>%r 输出自应用启动到输出该日志信息所耗费的毫秒数</li><li>%t 输出产生该日志事件的线程名</li></ul><p>上述<code>%5p [%t] (%F:%L) - %m%n</code> 为宽度为5的优先输出级 [线程名] （文件名：行号）- message信息 \r\n</p><p><img src="/images/2019-08-04-Java利用Log4J输出日志文件/log4j输出信息.png" alt="log4j输出信息"></p><h3 id="使用log4j-xml格式进行配置"><a href="#使用log4j-xml格式进行配置" class="headerlink" title="使用log4j.xml格式进行配置"></a>使用log4j.xml格式进行配置</h3><p>在src下配置log4j.xml文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE log4j:configuration PUBLIC &quot;-//log4j/log4j Configuration//EN&quot; &quot;log4j.dtd&quot;&gt;</span><br><span class="line">  </span><br><span class="line">&lt;log4j:configuration xmlns:log4j=&quot;http://jakarta.apache.org/log4j/&quot;&gt;</span><br><span class="line">      </span><br><span class="line">    &lt;appender name=&quot;STDOUT&quot; class=&quot;org.apache.log4j.ConsoleAppender&quot;&gt;</span><br><span class="line">       &lt;layout class=&quot;org.apache.log4j.PatternLayout&quot;&gt;</span><br><span class="line">          &lt;param name=&quot;ConversionPattern&quot; value=&quot;%d %-5p %c.%M:%L - %m%n&quot;/&gt;</span><br><span class="line">       &lt;/layout&gt;</span><br><span class="line">    &lt;/appender&gt;</span><br><span class="line">   </span><br><span class="line">    &lt;!-- specify the logging level for loggers from other libraries --&gt;</span><br><span class="line">    &lt;logger name=&quot;com.opensymphony&quot;&gt;</span><br><span class="line">        &lt;level value=&quot;ERROR&quot; /&gt;</span><br><span class="line">    &lt;/logger&gt;</span><br><span class="line">  </span><br><span class="line">    &lt;logger name=&quot;org.apache&quot;&gt;</span><br><span class="line">         &lt;level value=&quot;ERROR&quot; /&gt;</span><br><span class="line">    &lt;/logger&gt;</span><br><span class="line">    &lt;logger name=&quot;org.hibernate&quot;&gt;</span><br><span class="line">         &lt;level value=&quot;ERROR&quot; /&gt;</span><br><span class="line">    &lt;/logger&gt;</span><br><span class="line">    </span><br><span class="line">   &lt;!-- for all other loggers log only debug and above log messages --&gt;</span><br><span class="line">     &lt;root&gt;</span><br><span class="line">        &lt;priority value=&quot;ERROR&quot;/&gt;</span><br><span class="line">        &lt;appender-ref ref=&quot;STDOUT&quot; /&gt;</span><br><span class="line">     &lt;/root&gt;</span><br><span class="line">      </span><br><span class="line">&lt;/log4j:configuration&gt;</span><br></pre></td></tr></table></figure></p><p>注意这个log4j.xml需要放在project根目录也就是和src文件夹同级，才能生效。不然会出现WARN警告。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java反射机制</title>
      <link href="/2019/08/03/2019-08-03-Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/08/03/2019-08-03-Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>学习Java反射机制<br><a id="more"></a> <!-- 摘要 --></p><h3 id="Java的类对象"><a href="#Java的类对象" class="headerlink" title="Java的类对象"></a>Java的类对象</h3><p><strong>类对象</strong>：所有定义的类，都有一个对应的类对象。这个类对象用于提供类本身的信息，比如有几种构造方法，有多少字段属性，有多少普通方法。</p><p>获取类对象的方法有：</p><ul><li>Class.forName(要获取的类名称)</li><li>类名称.class</li><li>new 类构造函数().getClass()<br>在一个JVM中，一个类只会有一个类对象存在，所以以上三种获取到的类对象都是一样的。</li></ul><p>在获取类对象的时候，会导致类属性被初始化，即类中所有属性都会运行。</p><h3 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h3><p>与传统的通过new来创建对象实例不同，<strong>反射机制</strong>，会首先拿到要创建的类的<strong>类对象</strong>，然后通过类对象获取”构造对象“。在通过构造对象创造对象。</p><h4 id="通过constructor创造对象"><a href="#通过constructor创造对象" class="headerlink" title="通过constructor创造对象"></a>通过constructor创造对象</h4><ul><li>Class pClass = Class.forName(类名)</li><li>Constructor constructor = pClass.getConstructor();</li><li>Hero hero = (Hero) constructor.newInstance();</li></ul><h4 id="通过类对象获取类字段"><a href="#通过类对象获取类字段" class="headerlink" title="通过类对象获取类字段"></a>通过类对象获取类字段</h4><ul><li>getField(name) 只能获取public，从父类继承得来的字段</li><li>getDeclaredField(name) 可以获取本类的所有字段，包括private，但不能获取继承字段。注意，能够获取private字段但并不能修改private字段，除非加上setAccessible(true)</li></ul><h4 id="通过反射机制调用函数"><a href="#通过反射机制调用函数" class="headerlink" title="通过反射机制调用函数"></a>通过反射机制调用函数</h4><ul><li><code>Method method = object.getClass().getMethod(methodName, Args.getClass())</code></li><li><code>method.invoke(object, args)</code><br>注意getMethod中args.getClass必须是函数中定义的形式，如果涉及到子类父类继承的话不能自动探索传入参数的类型。</li></ul><p>Tips:<br>假设现在有<br>ADHero h1 继承自父类Hero<br>那么<br>Hero hero = (Hero) h1;<br>这个时候hero.getClass()仍然会返回ADHero。<br>但是将h1传一个接收参数为Hero的函数的时候时候，就自动向上转换成了父类。</p><h4 id="反射机制有什么用"><a href="#反射机制有什么用" class="headerlink" title="反射机制有什么用"></a>反射机制有什么用</h4><p>在使用Spring框架的时候如果要切换两个业务之间的代码，不需要整个修改所有的代码，只需要将配置文件进行修改就可以实现两个业务代码之间的切换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">package reflection;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author shaoguoliang</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class TestReflection &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        //传统方式创建</span><br><span class="line">        Hero hero1 = new Hero();</span><br><span class="line">        hero1.name = &quot;GS&quot;;</span><br><span class="line">        System.out.println(hero1);</span><br><span class="line">            </span><br><span class="line">        //通过反射机制创建</span><br><span class="line">        try &#123;</span><br><span class="line">            String className = &quot;reflection.Hero&quot;;</span><br><span class="line">            //获取类对象</span><br><span class="line">            Class pClass = Class.forName(className);</span><br><span class="line">            //构造器</span><br><span class="line">            Constructor constructor = pClass.getConstructor();</span><br><span class="line">            //通过构造器实例化</span><br><span class="line">            Hero hero2 = (Hero) constructor.newInstance();</span><br><span class="line">            hero2.name = &quot;GS2&quot;;</span><br><span class="line">            System.out.println(hero2);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            // TODO: handle exception</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        //通过反射机制修改hero.name</span><br><span class="line">        try &#123;</span><br><span class="line">            Field f1 = hero1.getClass().getDeclaredField(&quot;name&quot;);</span><br><span class="line">            f1.set(hero1, &quot;changedGS&quot;);</span><br><span class="line">            System.out.println(hero1.name);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            // TODO: handle exception</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        //通过反射机制调用类函数</span><br><span class="line">        try &#123;</span><br><span class="line">            Method method = hero1.getClass().getMethod(&quot;setName&quot;, String.class);</span><br><span class="line">            method.invoke(hero1, &quot;sgl&quot;);</span><br><span class="line">            System.out.println(hero1.name);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            // TODO: handle exception</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java网络编程基础</title>
      <link href="/2019/08/02/2019-08-02-Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/08/02/2019-08-02-Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<a id="more"></a> <!-- 摘要 --><h3 id="两台计算机连接通信"><a href="#两台计算机连接通信" class="headerlink" title="两台计算机连接通信"></a>两台计算机连接通信</h3><p>两台计算机进行连接，总有一台服务器，一台客户端。<br>服务器和客户端之间的通信通过<strong>端口</strong>进行。<br>例如：<br>ip地址是 192.168.1.100的服务器通过端口 8080<br>与ip地址是192.168.1.189的客户端 的1087端口通信</p><p>获取本机ip地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package socket;</span><br><span class="line"> </span><br><span class="line">import java.net.InetAddress;</span><br><span class="line">import java.net.UnknownHostException;</span><br><span class="line"> </span><br><span class="line">public class TestSocket &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws UnknownHostException &#123;</span><br><span class="line">        InetAddress host = InetAddress.getLocalHost();</span><br><span class="line">        String ip =host.getHostAddress();</span><br><span class="line">        System.out.println(&quot;本机ip地址：&quot; + ip);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Socket进行网络编程"><a href="#Socket进行网络编程" class="headerlink" title="Socket进行网络编程"></a>Socket进行网络编程</h3><h4 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h4><p>Server端：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shaoguoliang</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">           ServerSocket ss = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>); <span class="comment">//服务器打开8888端口</span></span><br><span class="line">           System.out.println(<span class="string">"The Server is monitoring the port 8888"</span>);</span><br><span class="line">           </span><br><span class="line">           Socket socket = ss.accept(); <span class="comment">//等待8888端口接收连接请求</span></span><br><span class="line">           System.out.println(<span class="string">"There is a Connection coming."</span>);</span><br><span class="line">           </span><br><span class="line">           socket.close();</span><br><span class="line">           ss.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">           <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">           e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Client端<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package socket;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.Socket;</span><br><span class="line">import java.net.UnknownHostException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author shaoguoliang</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">           Socket socket = new Socket(&quot;127.0.0.1&quot;, 8888);</span><br><span class="line">           System.out.println(socket);</span><br><span class="line">           socket.close();</span><br><span class="line">        &#125; catch (UnknownHostException e) &#123;</span><br><span class="line">           // TODO: handle exception</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e)&#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Tips:</p><ul><li>运行分别运行两个java程序，先开Server，再开Client</li><li>java命令运行class文件，对于含有package的原文件，需要在存放package的根目录执行运行。<code>java socket.Server</code></li></ul><h4 id="传输数据流"><a href="#传输数据流" class="headerlink" title="传输数据流"></a>传输数据流</h4><p>Client使用Scanner读取控制台的输入，然后传送一条数据到Server端。</p><p>Server端，用DataInputStream来包裹InputStream：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package socket;</span><br><span class="line"></span><br><span class="line">import java.io.DataInputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.net.ServerSocket;</span><br><span class="line">import java.net.Socket;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author shaoguoliang</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Server &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">           ServerSocket ss = new ServerSocket(8888); //服务器打开8888端口</span><br><span class="line">           System.out.println(&quot;The Server is monitoring the port 8888&quot;);</span><br><span class="line">           </span><br><span class="line">           Socket socket = ss.accept();</span><br><span class="line">           System.out.println(&quot;There is a Connection coming.&quot;);</span><br><span class="line">           </span><br><span class="line">           InputStream is = socket.getInputStream(); //接收inputstream</span><br><span class="line">           </span><br><span class="line">           DataInputStream dis = new DataInputStream(is);</span><br><span class="line">           </span><br><span class="line">           String msg = dis.readUTF();</span><br><span class="line">           System.out.println(msg);</span><br><span class="line">           </span><br><span class="line">           dis.close();</span><br><span class="line">           socket.close();</span><br><span class="line">           ss.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">           // TODO: handle exception</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Client端，使用Scanner来读取控制台的输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package socket;</span><br><span class="line"></span><br><span class="line">import java.io.DataOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.OutputStream;</span><br><span class="line">import java.net.Socket;</span><br><span class="line">import java.net.UnknownHostException;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author shaoguoliang</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">           Socket socket = new Socket(&quot;127.0.0.1&quot;, 8888);</span><br><span class="line">           System.out.println(socket);</span><br><span class="line">           </span><br><span class="line">           OutputStream os = socket.getOutputStream();</span><br><span class="line">           DataOutputStream dos = new DataOutputStream(os);</span><br><span class="line">           </span><br><span class="line">           Scanner sc = new Scanner(System.in);</span><br><span class="line">           String str = sc.next();</span><br><span class="line">           dos.writeUTF(str);</span><br><span class="line">           </span><br><span class="line">           dos.close();</span><br><span class="line">           os.close();</span><br><span class="line">           socket.close();</span><br><span class="line">        &#125; catch (UnknownHostException e) &#123;</span><br><span class="line">           // TODO: handle exception</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e)&#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="实现服务器与客户端双重联系"><a href="#实现服务器与客户端双重联系" class="headerlink" title="实现服务器与客户端双重联系"></a>实现服务器与客户端双重联系</h4><p>异步通信，要开启两个线程，一发一收。</p><p>读线程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">package socket;</span><br><span class="line"></span><br><span class="line">import java.io.DataInputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.net.Socket;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author shaoguoliang</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class ReadRunable implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">   private Socket socket;</span><br><span class="line">   private String orin;</span><br><span class="line">   public boolean connection = false;</span><br><span class="line">   </span><br><span class="line">   /**</span><br><span class="line">    * </span><br><span class="line">    */</span><br><span class="line">   public ReadRunable(Socket socket, String orin, boolean connection) &#123;</span><br><span class="line">        // TODO Auto-generated constructor stub</span><br><span class="line">        this.socket = socket;</span><br><span class="line">        this.orin = orin;</span><br><span class="line">        this.connection = connection;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   /* (non-Javadoc)</span><br><span class="line">    * @see java.lang.Runnable#run()</span><br><span class="line">    */</span><br><span class="line">   @Override</span><br><span class="line">   public void run() &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        try &#123;</span><br><span class="line">        while(connection)&#123;</span><br><span class="line">           InputStream is = socket.getInputStream();</span><br><span class="line">           DataInputStream dis = new DataInputStream(is);</span><br><span class="line">           System.out.print(orin + &quot;:\r\n&quot; + dis.readUTF());</span><br><span class="line">        &#125;</span><br><span class="line">        socket.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">           // TODO: handle exception</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>发送线程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">package socket;</span><br><span class="line"></span><br><span class="line">import java.io.DataOutputStream;</span><br><span class="line">import java.io.OutputStream;</span><br><span class="line">import java.net.Socket;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author shaoguoliang</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class SendRunable implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">    private Socket socket;</span><br><span class="line">    public Scanner scanner;</span><br><span class="line">    public boolean connection = false;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * </span><br><span class="line">     */</span><br><span class="line">    public SendRunable(Socket socket, Scanner scanner, boolean connection) &#123;</span><br><span class="line">    // TODO Auto-generated constructor stub</span><br><span class="line">    this.socket = socket;</span><br><span class="line">    this.scanner = scanner;</span><br><span class="line">    this.connection = connection;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /* (non-Javadoc)</span><br><span class="line">     * @see java.lang.Runnable#run()</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">    // TODO Auto-generated method stub</span><br><span class="line">    try &#123;</span><br><span class="line">    while(connection)&#123;</span><br><span class="line">    OutputStream os = socket.getOutputStream();</span><br><span class="line">    DataOutputStream dos = new DataOutputStream(os);</span><br><span class="line">    String msg = scanner.next();</span><br><span class="line">    dos.writeUTF(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    socket.close();</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">    // TODO: handle exception</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Client端：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package socket;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.Socket;</span><br><span class="line">import java.net.UnknownHostException;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author shaoguoliang</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class ClientContinue &#123;</span><br><span class="line">    public static void main(String[] args) throws UnknownHostException, IOException&#123;</span><br><span class="line">    Socket socket = new Socket(&quot;127.0.0.1&quot;, 8888); //必须handle exception</span><br><span class="line">    boolean connection = (socket != null);</span><br><span class="line">    if(connection)&#123;</span><br><span class="line">    System.out.println(&quot;The connection is successful&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    Scanner scanner = new Scanner(System.in);</span><br><span class="line">    </span><br><span class="line">    //创造线程，读线程和写线程</span><br><span class="line">    Runnable readRunnable = new ReadRunable(socket, &quot;Server&quot;, connection);</span><br><span class="line">    Runnable sendRunnable = new SendRunable(socket, scanner, connection);</span><br><span class="line">    </span><br><span class="line">    //开启线程</span><br><span class="line">    new Thread(readRunnable).start();</span><br><span class="line">    new Thread(sendRunnable).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Server端：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package socket;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.ServerSocket;</span><br><span class="line">import java.net.Socket;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author shaoguoliang</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class ServerContinue &#123;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) throws IOException, InterruptedException&#123;</span><br><span class="line">    ServerSocket ss = new ServerSocket(8888); //服务器监听端口8888</span><br><span class="line">    System.out.println(&quot;Server is monitoring Port 8888&quot;);</span><br><span class="line">    </span><br><span class="line">    Socket socket = ss.accept(); //接收socket</span><br><span class="line">    boolean connection = (socket!=null);</span><br><span class="line">    Scanner scanner = new Scanner(System.in);</span><br><span class="line">    Runnable readRunnable = new ReadRunable(socket, &quot;Client&quot;, connection);</span><br><span class="line">    Runnable sendRunnable = new SendRunable(socket, scanner, connection);</span><br><span class="line">    </span><br><span class="line">    new Thread(readRunnable).start();</span><br><span class="line">    new Thread(sendRunnable).start();</span><br><span class="line">    </span><br><span class="line">    while(Thread.activeCount() &gt; 1)&#123;</span><br><span class="line">    Thread.sleep(1000);</span><br><span class="line">    &#125;</span><br><span class="line">    ss.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scala语言学习汇总</title>
      <link href="/2019/07/31/2019-07-31-Scala%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB/"/>
      <url>/2019/07/31/2019-07-31-Scala%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<p>参考<a href="http://dblab.xmu.edu.cn/blog/spark/" target="_blank" rel="noopener">http://dblab.xmu.edu.cn/blog/spark/</a> 林子雨老师的Spark入门教程中Scala语言的部分。</p><a id="more"></a> <!-- 摘要 --><h2 id="为什么使用Scala语言"><a href="#为什么使用Scala语言" class="headerlink" title="为什么使用Scala语言"></a>为什么使用Scala语言</h2><ul><li>Scala是多范式编程语言，集成了面向对象和函数式语言的特性。运行与JVM虚拟机上，并兼容现有的Java程序。Scala代码可以调用Java方法，访问Java字段，集成Java类和实现Java接口。<strong>Scala是一门纯粹的面向对象编程语言</strong>。</li><li>Scala具备<strong>强大的并发性</strong>，支持函数式编程，可以更好地支持分布式系统</li><li>Scala语法简介，能够提供优雅的API</li><li>Scala兼容Java，运行速度快，且能够融合到Hadoop生态圈</li><li>Scala相对Java支持交互编程，而Java必须要编译才能运行。</li></ul><h2 id="Scala安装"><a href="#Scala安装" class="headerlink" title="Scala安装"></a>Scala安装</h2><p>Scala需要运行在JVM上，因此必须要安装Java JDK。</p><h3 id="在macOS下安装"><a href="#在macOS下安装" class="headerlink" title="在macOS下安装"></a>在macOS下安装</h3><p><code>brew install scala</code> 就可以直接安装scala</p><h3 id="Linux下安装"><a href="#Linux下安装" class="headerlink" title="Linux下安装"></a>Linux下安装</h3><ul><li>在<a href="https://www.scala-lang.org/download/" target="_blank" rel="noopener">scala官网</a>上下载scala安装包</li><li>tar 解压到安装目录 <code>tar xvzf scala.tgz -C dest_dir</code></li><li>将scala命令添加到环境变量(可以放在/etc/profile)中 <code>export PATH=$PATH:/usr/local/scala/bin</code></li><li>在命令行中检查scala是否能找到该命令</li></ul><h2 id="Scala编程"><a href="#Scala编程" class="headerlink" title="Scala编程"></a>Scala编程</h2><h3 id="Scala与Java编程的区别"><a href="#Scala与Java编程的区别" class="headerlink" title="Scala与Java编程的区别"></a>Scala与Java编程的区别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">object HelloWorld&#123;</span><br><span class="line">    def main(args: Array[String])&#123;</span><br><span class="line">        println(&quot;Hello World!&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（1）Scala程序中同样要定义程序入口main()函数。但与Java不同的是，在Java中，main函数必须是静态函数 <code>public static void main(String[] args)</code>，而Scala中必须使用对象方法。<br>（2）在Scala中对象的命名不一定要与文件名一致，但为了统一，还是建议命名为<code>HelloWorld.scala</code>。<br>（3）Scala语句结束没有<code>;</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ scala HelloWorld.scala //编译Scala文件</span><br><span class="line">$ scala -classpath . HelloWorld //执行生成的HelloWorld对象名称</span><br></pre></td></tr></table></figure><h2 id="Scala语法-Scala-2-13-0"><a href="#Scala语法-Scala-2-13-0" class="headerlink" title="Scala语法(Scala 2.13.0)"></a>Scala语法(Scala 2.13.0)</h2><h3 id="变量与声明值"><a href="#变量与声明值" class="headerlink" title="变量与声明值"></a>变量与声明值</h3><p>scala有两种类型的变量：</p><ul><li><strong>val</strong>：不可变，在生命是就必须初始化，而且初始化以后就不能再赋值</li><li><strong>var</strong>：可变的，声明的时候需要进行初始化，初始化以后还可以再次进行赋值</li></ul><p>Scala是自动推断变量的类型。也可以显式声明变量的类型。在每个程序中，scala都会自动添加<code>java.lang._</code>的引用，这样就在所有原文件中引入了java.lang包内的所有东西。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val myStr = &quot;HelloWorld!&quot;</span><br><span class="line">val myStr2 : String = &quot;HelloWorld!&quot;</span><br></pre></td></tr></table></figure></p><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>Byte，Char，Short，Int，Long，Float，Double和Bollean。<br>注意在Scala中，这些类型都是Class，并且都是scala包的成员。</p><p><strong>在Scala中没有提供++或—的操作符</strong>，当需要递增或递减时，只能使用<code>i += 1</code></p><p>方法：</p><ul><li><code>a 方法 b</code></li><li><code>a.方法(b)</code></li></ul><h3 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h3><p>在执行for循环的时候，经常会用到数值序列，可以用Range来实现。Range可以支持创建不同数据类型的数值序列，包括Int，Long，Float，Double，Char，BigInt和BigDecimal等。</p><p>(1) 创建从1到5的数值序列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; 1 to 5</span><br><span class="line">res1: scala.collection.immutable.Range.Inclusive = Range 1 to 5</span><br><span class="line"></span><br><span class="line">scala&gt; 1.to(5)</span><br><span class="line">res2: scala.collection.immutable.Range.Inclusive = Range 1 to 5</span><br></pre></td></tr></table></figure></p><p>(2) 创建从1到5的数值序列，不包含区间终点5， 步长为1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; 1 until 5</span><br><span class="line">res3: scala.collection.immutable.Range = Range 1 until 5</span><br></pre></td></tr></table></figure></p><p>(3) 步长为2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; 1 to 10 by 2</span><br><span class="line">res6: scala.collection.immutable.Range = inexact Range 1 to 10 by 2</span><br></pre></td></tr></table></figure></p><p>同样上述也可以创建为float类型</p><h3 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h3><p>(1) 写入文本文件，执行后会在<code>~/</code>下建立output.txt文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; import java.io.PrintWriter</span><br><span class="line">import java.io.PrintWriter</span><br><span class="line"></span><br><span class="line">scala&gt; val out = new PrintWriter(&quot;output.txt&quot;)</span><br><span class="line">out: java.io.PrintWriter = java.io.PrintWriter@52035328</span><br><span class="line"></span><br><span class="line">scala&gt; for(i &lt;- 1 to 5) out.println(i)</span><br><span class="line"></span><br><span class="line">scala&gt; out.close()</span><br></pre></td></tr></table></figure></p><p>(2) 读取文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; import scala.io.Source</span><br><span class="line">import scala.io.Source</span><br><span class="line"></span><br><span class="line">scala&gt; val inputFile = Source.fromFile(&quot;output.txt&quot;)</span><br><span class="line">inputFile: scala.io.BufferedSource = &lt;iterator&gt;</span><br><span class="line"></span><br><span class="line">scala&gt; val lines = inputFile.getLines</span><br><span class="line">lines: Iterator[String] = &lt;iterator&gt;</span><br><span class="line"></span><br><span class="line">scala&gt; for(line &lt;- lines) println(line)</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure></p><h3 id="控制结构与Java语言相同"><a href="#控制结构与Java语言相同" class="headerlink" title="控制结构与Java语言相同"></a>控制结构与Java语言相同</h3><ul><li>if</li><li>while</li><li>for(变量&lt;-表达式) 语句块</li></ul><p><code>变量&lt;-表达式</code>被称为 <em>生成器（generator）</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for(i &lt;- 1 to 5 if i % 2 == 0) println(i)</span><br><span class="line">for(i &lt;- 1 to 5; j &lt;- 1 to 3) println(i*j)</span><br></pre></td></tr></table></figure></p><p>for还具有推导式。有时候需要对生成器过滤的结构进行进一步处理，我们可以使用yield关键字，对过滤后的结果构建一个<strong>集合</strong>.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for(i &lt;- 1 to 5 if i % 2==0) yield i</span><br></pre></td></tr></table></figure></p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val intValueArr = new Array[Int](3) //声明一个长度为3的整形数组，每个数组元素初始化为0</span><br><span class="line">intValueArr(0) = 12</span><br><span class="line">val intValueArr = Array(12, 45, 33) //简洁初始化数组</span><br></pre></td></tr></table></figure><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val intList = List(1,2,3)</span><br><span class="line">intList: List[Int] = List(1, 2, 3)</span><br><span class="line"></span><br><span class="line">scala&gt; intList.head</span><br><span class="line">res10: Int = 1</span><br><span class="line"></span><br><span class="line">scala&gt; intList.tail</span><br><span class="line">res11: List[Int] = List(2, 3)</span><br><span class="line"></span><br><span class="line">scala&gt; 0::intList //使用::在列表的头部增加新的元素，得到一个新的列表。注意::是右结合的</span><br><span class="line">res12: List[Int] = List(0, 1, 2, 3)</span><br><span class="line"></span><br><span class="line">scala&gt; intList.sum</span><br><span class="line">res16: Int = 6</span><br></pre></td></tr></table></figure><h4 id="元组。"><a href="#元组。" class="headerlink" title="元组。"></a>元组。</h4><p>元组是不同类型的值的聚集。列表中的每个元素必须是相同类型。而元组可以包含不同类型的元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val tuple = (&quot;BigData&quot;, 2015, 07, 1.2)</span><br><span class="line">tuple: (String, Int, Int, Double) = (BigData,2015,7,1.2)</span><br><span class="line"></span><br><span class="line">scala&gt; tuple._1 //访问第一个元素</span><br><span class="line">res17: String = BigData</span><br></pre></td></tr></table></figure></p><h4 id="集合-Set。"><a href="#集合-Set。" class="headerlink" title="集合 Set。"></a>集合 Set。</h4><p>集合是不重复元素的集合。列表中的元素是按照插入的先后顺序来组织的，但集合中不会记录元素的插入顺序，而是以hash方法对元素的值进行组织。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val set = Set(&quot;a&quot;, &quot;b&quot;)</span><br><span class="line">set: scala.collection.immutable.Set[String] = Set(a, b)</span><br></pre></td></tr></table></figure></p><h4 id="映射-Map"><a href="#映射-Map" class="headerlink" title="映射 Map"></a>映射 Map</h4><p>key-&gt;value键值对映射<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val university = Map(&quot;XMU&quot; -&gt; &quot;Xiamen University&quot;)</span><br><span class="line">university: scala.collection.immutable.Map[String,String] = Map(XMU -&gt; Xiamen University)</span><br><span class="line"></span><br><span class="line">scala&gt; university(&quot;XMU&quot;)</span><br><span class="line">res19: String = Xiamen University</span><br></pre></td></tr></table></figure></p><p>上述定义的Map是无法更新映射中的元素，也无法增加新的元素。如果需要更新增加元素，需要定义一个可变的映射。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val university1 = Map(&quot;XMU&quot;-&gt;&quot;Xiamen University&quot;);</span><br><span class="line">university1: scala.collection.mutable.Map[String,String] = HashMap(XMU -&gt; Xiamen University)</span><br><span class="line"></span><br><span class="line">scala&gt; university1 += (&quot;THU&quot; -&gt; &quot;Tsinghua University&quot;)</span><br><span class="line">res22: university1.type = HashMap(THU -&gt; Tsinghua University, XMU -&gt; Xiamen University)</span><br></pre></td></tr></table></figure></p><p>循环遍历映射，基本格式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for ((k, v) &lt;- map) 语句块</span><br></pre></td></tr></table></figure></p><h4 id="迭代器-Iterator"><a href="#迭代器-Iterator" class="headerlink" title="迭代器 Iterator"></a>迭代器 Iterator</h4><p>提供一种访问集合的方法。迭代器包含两个基本操作：next和hasNext。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val iter = Iterator(&quot;Hadoop&quot;, &quot;Spark&quot;, &quot;Scala&quot;)</span><br><span class="line">iter: Iterator[String] = &lt;iterator&gt;</span><br><span class="line"></span><br><span class="line">scala&gt; while(iter.hasNext)</span><br><span class="line">     | println(iter.next())</span><br><span class="line">Hadoop</span><br><span class="line">Spark</span><br><span class="line">Scala</span><br></pre></td></tr></table></figure></p><h4 id="类-class-与Java的类相同"><a href="#类-class-与Java的类相同" class="headerlink" title="类 class 与Java的类相同"></a>类 class 与Java的类相同</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Counter&#123;</span><br><span class="line">    private var value = 0;</span><br><span class="line">    def increment(): Unit = &#123;value += 1&#125;</span><br><span class="line">    def current(): Int = &#123;value&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val myCounter = new Counter;</span><br><span class="line">myCounter.increment();</span><br></pre></td></tr></table></figure><p>在类方法的定义中使用def，上述Unit为返回值类型。在Scala中没有返回值就用Unit(Java中的void)。方法的返回值不需要return语句。方法里边最后一个表达式的值就是方法的返回值。</p><p>Scala类的主构造器。Scala的主构造器与Java的构造函数有明显不同，Scala的主构造器是整个类体，需要在类名称后边罗列出构造器所需的所有参数，这些参数被编译成字段，字段的值就是创建对象时传入的参数的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Counter(val name:String, val mode:Int)&#123;</span><br><span class="line">    private var value = 0;</span><br><span class="line">    def increment(step:Int):Unit = &#123;value += step&#125;</span><br><span class="line">    def current():Int = &#123;value&#125;</span><br><span class="line">    def info():Unit = &#123;printf(&quot;Name:%s and mode is %d\n&quot;, name, mode)&#125;</span><br><span class="line">&#125;</span><br><span class="line">object MyCounter&#123;</span><br><span class="line">    def main(args:Array[String])&#123;</span><br><span class="line">        val myCounter = new Counter(&quot;Timer&quot;, 2);</span><br><span class="line">        myCounter.info //显示计数器信息</span><br><span class="line">        myCounter.increment(2) //添加步长</span><br><span class="line">        printf(&quot;Current Value is: %d\n&quot;, myCounter.current) //显示计数器当前值  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="对象-object"><a href="#对象-object" class="headerlink" title="对象 object"></a>对象 object</h4><p>Scala没有提供Java的静态方法或静态字段，但是可以采用object关键字实现单例对象，具备和Java静态方法同样的功能。</p><ul><li><p>单例对象，跟类定义很相似，只是用object来定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">object Person&#123;</span><br><span class="line">    private var lastId = 0 //一个人的身份编号</span><br><span class="line">    def newPersonId() = &#123;</span><br><span class="line">        lastId += 1</span><br><span class="line">        lastId</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>伴生对象，在Java中，我们经常需要用到同时包含实例方法和静态方法的类，在Scala中可以通过伴生对象来实现。 <em>当单例对象与某个类具有相同的名称时</em> ，它被称为这个类的“伴生对象”。类和它的伴生对象必须存在同一个文件中，而且可以相互访问私有成员（字段和方法）。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">    private val id = Person.newPersonId() //调用伴生对象的方法</span><br><span class="line">    private var name = &quot;&quot;</span><br><span class="line">    def this(name:String)&#123; //第一辅助构造器</span><br><span class="line">        this() //主构造器</span><br><span class="line">        this.name = name //辅助构造器构造类字段</span><br><span class="line">    &#125;</span><br><span class="line">    def info()&#123;</span><br><span class="line">        printf(&quot;The id of %s is %d.\n&quot;, name, id)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">object Person&#123;</span><br><span class="line">    private var lastId = 0</span><br><span class="line">    private def newPersonId() = &#123; //它承担了一个相当于Java中static方法的任务</span><br><span class="line">        lastId += 1</span><br><span class="line">        lastId</span><br><span class="line">    &#125;</span><br><span class="line">    def main(args:Array[String])&#123;</span><br><span class="line">        val person1 = new Person(&quot;Ziyu&quot;)</span><br><span class="line">        val person2 = new Person(&quot;Minxing&quot;)</span><br><span class="line">        person1.info()</span><br><span class="line">        person2.info()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>应用程序对象。每个scala应用程序都必须从一个对象的main方法开始。<br>  （1）如果代码中没有定义类，只有单例对象，那么可以不用编译或者在交互shell中直接用scala命令运行得到结果<br>  （2）先用scalac命令对代码进行编译，然后用scala命令进行运行。</p></li><li><p>apple方法和update方法。在scala中，用括号传递给变量（或对象）一个或多个参数时，scala会把他们转换成apply方法的调用；当对带有括号并包括一到若干参数的对象进行赋值时，编译器将调用对象的update方法。</p></li></ul><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>scala中的继承与Java的不同：</p><ul><li>重写一个非抽象方法必须使用override修饰符</li><li>只有主构造器可以调用超类的主构造器</li><li>在子类中重写超类的抽象方法时，不需要使用overrider关键字</li><li>可以重写超类中的字段</li></ul><p>Scala与Java一样不允许从多个超类继承。</p><p><em>抽象类</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">abstract class Car&#123;</span><br><span class="line">    val carBradn:String</span><br><span class="line">    def info()</span><br><span class="line">    def greeting()&#123;</span><br><span class="line">        println(&quot;Welcome to my car!&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>要点：</p><ul><li>定义一个抽象类，需要使用关键字abstract</li><li>定义一个抽象类的抽象方法，也不需要关键字abstract，只要把方法体空着，不写方法体就可以了（而在Java中，抽象方法时必须用abstract修饰的）</li><li>抽象类中定义的字段，只要没有给出初始化值，就表示是一个抽象字段，但是抽象字段必须要声明类型，不能省略类型否则会编译报错。</li></ul><p><em>继承类</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class BMWCar extends Car&#123;</span><br><span class="line">    override val carBrand = &quot;BMW&quot; //重写抽象字段必须加override</span><br><span class="line">    override def info()&#123;</span><br><span class="line">        printf(&quot;This is a %s car. It is on sale.&quot;, carBrand)</span><br><span class="line">    &#125; //重写超类抽象方法可以不用加override，加了也不会报错</span><br><span class="line">    overrider def greeting()&#123;</span><br><span class="line">        println(&quot;Welcome to my BMW car!&quot;)</span><br><span class="line">    &#125; //重写超类非抽象方法必须加override</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="特质-trait-对应于Java的接口"><a href="#特质-trait-对应于Java的接口" class="headerlink" title="特质 trait 对应于Java的接口"></a>特质 trait 对应于Java的接口</h4><p>scala的trait不仅实现了接口的功能，还具备了其他的特性。scala的trait是代码重用的基本单元，可以同时拥有抽象方法和具体方法。与Java一样，一个类只能继承自一个超类，却可以实现多个trait。</p><p>跟Java的接口Interface一样，trait中的字段和方法都是默认抽象并且是public。但使用trait仍然是extends或者with。第一个实现trait用extends，之后的可以反复使用with关键字混入更多trait<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">trait CarId&#123;</span><br><span class="line">    var id:Int</span><br><span class="line">    def currentId():Int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trait CarGreeting&#123;</span><br><span class="line">    def greeting(msg:String) &#123;println(msg)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BMWCarId extends CarId with CarGreeting&#123;</span><br><span class="line">    override var id = 20000</span><br><span class="line">    def currentId():Int = &#123;id +=1; id&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>trait中除了抽象字段和抽象方法，也可以包含具体实现，也就是说trait中的字段和方法不一定要是抽象的。</p><h4 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h4><p><em>简单匹配</em><br>Java中有switch-case语句，但只能按顺序匹配简单的数据类型和表达式。在Scala中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">val colorNum = 1</span><br><span class="line">val colorStr = colorNum match&#123;</span><br><span class="line">    case 1 =&gt; &quot;red&quot;</span><br><span class="line">    case 2 =&gt; &quot;green&quot;</span><br><span class="line">    case 3 =&gt; &quot;yellow&quot;</span><br><span class="line">    case _ =&gt; &quot;Not Allowed&quot;</span><br><span class="line">    //也可以使用</span><br><span class="line">    case unexpected =&gt; unexpected + &quot;is Not Allowed&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>类型匹配</em><br>scala可以对表达式的类型进行匹配<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for(elem &lt;- List(9, 12.3, &quot;Spark&quot;, &quot;Hadoop&quot;, &quot;Hello&quot;))&#123;</span><br><span class="line">    val str = elem match&#123;</span><br><span class="line">        case i:Int =&gt; i + &quot;is an int value&quot;</span><br><span class="line">        case d:Double =&gt; d + &quot;is a double value&quot;</span><br><span class="line">        case &quot;Spark&quot; =&gt; &quot;Spark is found&quot;</span><br><span class="line">        case s:String =&gt; s + &quot;is a string value&quot;</span><br><span class="line">        case _ =&gt; &quot;This is an unexpected value&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>守卫guard语句</em><br>可以在模式匹配中添加一些必要的处理逻辑。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for(elem &lt;- List(1,2,3,4))&#123;</span><br><span class="line">    elem match&#123;</span><br><span class="line">        case_ if(elem%2 == 0) =&gt; println(elem + &quot;is even.&quot;)</span><br><span class="line">        case_ =&gt; println(elem + &quot;is odd.&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>for表达式中的模式</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for((k, v) &lt;- 映射) 语句块</span><br></pre></td></tr></table></figure></p><p><em>case类的匹配</em><br>case类是一种特殊的类，经过优化被用于模式匹配<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">case class Car(brand:String, price:Int) //case类,主构造器</span><br><span class="line">val myBMWCar = new Car(&quot;BMW&quot;, 1200000)</span><br><span class="line">for (car &lt;- List(myBMWCar))&#123;</span><br><span class="line">    car match&#123;</span><br><span class="line">        case Car(&quot;BMW&quot;, 1200000) =&gt; println(&quot;Hello, BMW!&quot;)</span><br><span class="line">        case Car(brand, price) =&gt; println(&quot;Brand:&quot; + brand + &quot;, Price:&quot; + price + &quot;, do you want it?&quot; )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>Option类型</em><br>Option类型用case类来表示可能存在、也可能不存在的值。对于每种语言来说，都会有一个关键字来表示一个对象引用的是“无”，在Java中使用的是null。Scala融合了函数式编程风格，当预计变量或函数返回值可能不会引用任何值的时候，建议使用Option类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; var myMap = Map(&quot;hadoop&quot;-&gt;5, &quot;spark&quot;-&gt;4, &quot;car&quot;-&gt;3)</span><br><span class="line">myMap: scala.collection.immutable.Map[String,Int] = Map(hadoop -&gt; 5, spark -&gt; 4, car -&gt; 3)</span><br><span class="line"></span><br><span class="line">scala&gt; myMap.get(&quot;hadoop&quot;)</span><br><span class="line">res1: Option[Int] = Some(5)</span><br><span class="line"></span><br><span class="line">scala&gt; myMap.get(&quot;hive&quot;)</span><br><span class="line">res2: Option[Int] = None</span><br><span class="line"></span><br><span class="line">val found = myMap.get(&quot;hadoop&quot;)</span><br><span class="line">found.get //返回Some中的数据</span><br><span class="line"></span><br><span class="line">val found = myMap.get(&quot;hive&quot;)</span><br><span class="line">found.getOrElse(&quot;Not Found&quot;) //会返回字符串</span><br></pre></td></tr></table></figure></p><h3 id="函数编程"><a href="#函数编程" class="headerlink" title="函数编程"></a>函数编程</h3><p>函数式编程可以较好的满足分布式并行编程的需求（函数式编程的一个重要特性就是值不可变性，这对于编写可扩展的并发程序可以带来巨大好处，因为它避免了对公共的可变状态进行同步访问控制的复杂问题）。<br>函数字面量可以体现函数式编程的核心理念。字面量包括整数字面量，浮点数字面量，布尔型字面量，字符字面量，字符串字面量，符号字面量，函数字面量和元组字面量。</p><p><strong>函数字面量</strong> ：在函数式编程中，函数可以像任何其他数据类型一样被传递和操作，也就是说函数的使用方式和其他数据类型的使用方式完全一致。由此就区分开了函数的“类型”和函数的“值”两个概念，而函数的“值”，就是“函数字面量”。</p><p>传统函数<br><code>def counter(value:Int):Int = {value += 1}</code><br>上面这个传统函数的 <em>类型</em> 为<br><code>(Int) =&gt; Int</code><br>上面这个函数的 <em>值</em> 为<br><code>(value) =&gt; {value += 1}</code><br>那么我们可以按照如下方式定义上述传统函数<br><code>val counter: (Int)=&gt;Int = {(value) =&gt; value+=1}</code><br>这与scala中定义变量字面量的方式是一致的：<br><code>val num: Int = 5</code></p><p><strong>匿名函数</strong>：我们不需要给每个函数命名<br><code>(num:Int) =&gt; num*2</code><br>这种匿名函数的表达方式为’lambda表达式‘。<br><code>(参数) =&gt; 表达式</code><br>在lambda表达式中，至少需要在一处表明参数的类型，才可以推断参数类型</p><p><strong>闭包</strong>：闭包是一个比较特殊的函数。反应一个从开放到封闭的过程。对于普通函数而言，函数中只会应用函数中定义的变量，不会引入函数外部的变量。而闭包会引用函数外部的变量。<br><code>val addMore = (x:Int) =&gt; x+more</code><br>在这个函数定义中，引用了变量more。而more并没有在函数中定义，是一个函数外部的变量。如果现在去执行这条语句，编译器会因为more是一个自由变量还没有绑定值而报错。此时函数是开放的。因为为了使该lambda函数得到正常结果，必须在函数外部给出more的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var more = 1</span><br><span class="line">val addMore = (x:Int) =&gt; x+more</span><br></pre></td></tr></table></figure></p><p>在给定more具体数值1之后，lambda表达式中的more变量也就绑定了具体的值1，不再是自由变量。这个lambda函数也就从开放状态转成了封闭状态。每次addMore函数被调用时都会创建一个新闭包，每个闭包都会访问闭包创建时活跃的more变量。</p><p><strong>高阶函数</strong><br>一个接受其他函数作为参数或者返回一个函数的函数就是高阶函数<br>例如，有一个函数对给定两个数区间内的所有整数求和：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def sumInts(a:Int, b:Int):Int = &#123;</span><br><span class="line">    if(a &gt; b) 0 else a+sumInts(a+1, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>重新设计该函数的实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//定义一个新的函数sum，以函数f为参数</span><br><span class="line">def sum(f:Int =&gt; Int, a:Int, b:Int):Int = &#123;</span><br><span class="line">    if(a&gt;b) 0 else f(a) + sum(f, a+1, b)</span><br><span class="line">&#125;</span><br><span class="line">//定义一个新的函数self,该函数出入一个整数x，然后直接输出x本身</span><br><span class="line">def self(x:Int): Int = x</span><br><span class="line">//重新定义sumInts函数</span><br><span class="line">def sumInts(a:Int, b:Int): Int = sum(self, a, b)</span><br></pre></td></tr></table></figure></p><p>这其中sum函数的类型是<code>(Int=&gt;Int, Int, Int) =&gt; Int</code> 接受了一个函数作为参数，因此是一个高阶函数。</p><p>高阶函数可以实现对同样的字段通过控制传入函数f来进行不同操作的类似操作，简化编写逻辑。</p><p><strong>占位符语法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val numList = List(-3, -5, 1, 6, 9)</span><br><span class="line">numList: List[Int] = List(-3, -5, 1, 6, 9)</span><br><span class="line"></span><br><span class="line">scala&gt; numList.filter(x =&gt; x&gt;0)</span><br><span class="line">res10: List[Int] = List(1, 6, 9)</span><br><span class="line"></span><br><span class="line">scala&gt; numList.filter(_ &gt;0)</span><br><span class="line">res11: List[Int] = List(1, 6, 9)</span><br></pre></td></tr></table></figure></p><p>可以看出<code>x =&gt; x&gt;0</code>与<code>_ &gt; 0</code>这两个函数字面量是等价的。当采用下划线表示方法时，对于列表numList中的每个元素都会依次传入用来替换下划线。</p><h3 id="函数式编程中针对集合的操作"><a href="#函数式编程中针对集合的操作" class="headerlink" title="函数式编程中针对集合的操作"></a>函数式编程中针对集合的操作</h3><h4 id="列表的遍历"><a href="#列表的遍历" class="headerlink" title="列表的遍历"></a>列表的遍历</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val list = List(1,2,3,4,5)</span><br><span class="line">for(elem &lt;- list) println(elem)</span><br></pre></td></tr></table></figure><p>或者使用foreach进行遍历<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.foreach(elem =&gt; println(elem))</span><br></pre></td></tr></table></figure></p><h4 id="映射的遍历"><a href="#映射的遍历" class="headerlink" title="映射的遍历"></a>映射的遍历</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for((k, v) &lt;- 映射) 语句块</span><br></pre></td></tr></table></figure><h4 id="map操作和flatMap操作"><a href="#map操作和flatMap操作" class="headerlink" title="map操作和flatMap操作"></a>map操作和flatMap操作</h4><p>map操作是针对集合的典型变换操作，它将 <em>某个函数</em> 应用到集合中的 <em>每个元素</em> ，并产生一个 <em>结果集合</em> 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val books = List(&quot;Hadoop&quot;, &quot;Hive&quot;, &quot;HDFS&quot;)</span><br><span class="line">books.map(s =&gt; s.toUpperCase)</span><br></pre></td></tr></table></figure></p><p>对所有的s，都执行s.toUpperCase操作</p><p>flatMap是对map的一种扩展。在flatMap中，我们会传入一个函数，该函数对每个输入都会返回 <em>一个集合</em> ，然后flatMap会把生成的多个集合“拍扁”成为一个集合。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val list = List(&quot;Hadoop&quot;, &quot;Spark&quot;)</span><br><span class="line">list: List[String] = List(Hadoop, Spark)</span><br><span class="line"></span><br><span class="line">scala&gt; list.flatMap(s =&gt; s.toUpperCase)</span><br><span class="line">res15: List[Char] = List(H, A, D, O, O, P, S, P, A, R, K)</span><br></pre></td></tr></table></figure><h4 id="filter操作"><a href="#filter操作" class="headerlink" title="filter操作"></a>filter操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val university = Map(&quot;XMU&quot; -&gt; &quot;Xiamen University&quot;, &quot;THU&quot; -&gt; &quot;Tsinghua University&quot;)</span><br><span class="line">val universityOfXiamen = university filter&#123;kv =&gt; kv._2 contains &quot;Xiamen&quot;&#125;</span><br></pre></td></tr></table></figure><h4 id="Reduce操作"><a href="#Reduce操作" class="headerlink" title="Reduce操作"></a>Reduce操作</h4><p>在Scala中，使用reduce对集合中的元素进行规约，他是一个二元操作。<br>reduce包含reduceLeft和reduceRight两种操作，前者从集合的头部开始操作，后者从集合的尾部开始操作。默认reduce操作是reduceLeft<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val list = List(1,2,3,4,5)</span><br><span class="line">list.reduceLeft( _ + _ ) //从列表头部开始，对两两元素进行求和操作，下划线是占位符用来获取当前的两个元素。</span><br><span class="line">list.reduceRight( _ - _ )</span><br></pre></td></tr></table></figure></p><h4 id="fold操作"><a href="#fold操作" class="headerlink" title="fold操作"></a>fold操作</h4><p>fold操作与reduce操作比较类似。fold操作需要从一个初始的”种子“值开始，并以该值作为上下文，处理集合中的每一个元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val list = List(1,2,3,4,5)</span><br><span class="line">list.fold(10)(_*_)</span><br></pre></td></tr></table></figure></p><p>fold需要提供一个初始值，首先第一个操作时初始值与第一个遍历参数进行计算。同样提供了foldLeft和foldRight操作，默认fold操作时从左到右。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Scala </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark SQL， RDD 与 DataFrame</title>
      <link href="/2019/07/30/2019-07-30-SparkSQL/"/>
      <url>/2019/07/30/2019-07-30-SparkSQL/</url>
      
        <content type="html"><![CDATA[<p>参考<a href="https://blog.csdn.net/lovehuangjiaju/article/details/48661847" target="_blank" rel="noopener">https://blog.csdn.net/lovehuangjiaju/article/details/48661847</a></p><a id="more"></a> <!-- 摘要 --><h3 id="Spark-SQL简介"><a href="#Spark-SQL简介" class="headerlink" title="Spark SQL简介"></a>Spark SQL简介</h3><p>Spark SQL是Spark的五大核心模块之一，用于在Spark平台上处理结构化数据，利用Spark构建大数据平台上的数据仓库具有如下特点：</p><ul><li>能够无缝将SQL语句继承到Spark应用程序当中</li><li>提供统一的数据访问方式（包括Hive，Avro，Parquet，ORC，JSON，和JDBC）</li><li>兼容Hive</li><li>可采用JDBC或ODBC连接</li></ul><h3 id="Spark-SQL运行框架"><a href="#Spark-SQL运行框架" class="headerlink" title="Spark SQL运行框架"></a>Spark SQL运行框架</h3><h4 id="传统的关系型数据库"><a href="#传统的关系型数据库" class="headerlink" title="传统的关系型数据库"></a>传统的关系型数据库</h4><p>当我们提交一个简单的查询语句：<br><code>SELECT a1,a2,a3 FROM tableA Where condition</code></p><p><img src="/images/2019-07-30-SparkSQL/traditional_DB_process.png" alt="traditional_DB_process"></p><p>该语句是有Projection(a1, a2, a3), Data Source(tableA), Filter(condition) 组成，分别对应sql查询过程中的Result，Data Source，Operation。实际上就是按照Result-&gt;Data Source-&gt;Operation的次序来描述的。在SQL实际运行过程中，一般数据库会先通过SQL query来解析语句中的关键词，然后按照Operation-&gt;Data Source-&gt;Result的次序来执行。</p><p>所有的这些操作都和Tree有关，在数据库Parse（解析）一个SQL语句的时候，会将SQL语句转换成一个树形结构（Tree）来进行处理。</p><h4 id="Spark-SQL的Tree和Rule"><a href="#Spark-SQL的Tree和Rule" class="headerlink" title="Spark SQL的Tree和Rule"></a>Spark SQL的Tree和Rule</h4><p>Spark SQL对SQL语句的处理和关系型数据库对SQL语句的处理采用类似的方法，先对SQL语句进行解析（Parse），然后形成一个Tree，在后续的绑定、优化等处理过程中都是对Tree进行操作，而操作的方法次用Rule，通过模式匹配对不同类型的节点采用不同的操作。</p><h3 id="Data-Frame"><a href="#Data-Frame" class="headerlink" title="Data Frame"></a>Data Frame</h3><p>在Spark中，DataFrame是一种以RDD为基础的分布式数据集，DataFrame带有schema元信息，即DataFrame所表示的表数据集的每一列都带有名称和类型，它对于数据的内部结构具有很强的描述能力。因此Spark SQL可以对藏于DataFrame背后的数据源以及作用于DataFrame之上的变换进行针对性的优化，最终达到大幅提升运行时效率。</p><p>Data Frame具有如下特点：<br>（1）单机KB级到集群PB级的数据处理<br>（2）支持多种数据格式和存储系统<br>（3）通过Spark SQL Catalyst优化器可以进行高效的代码生成和优化<br>（4）提供Python，Java，Scala语言的API</p><h4 id="Data-Frame-与-RDD-的区别"><a href="#Data-Frame-与-RDD-的区别" class="headerlink" title="Data Frame 与 RDD 的区别"></a>Data Frame 与 RDD 的区别</h4><p><img src="http://dblab.xmu.edu.cn/blog/wp-content/uploads/2016/11/DataFrame-RDD.jpg" alt="DataFrame与RDD的区别"><br>RDD是分布式的Java对象集合。比如RDD[Person]是以RDD为类型参数，但是，Person类的内部结构对RDD而言是不可知的。DataFrame是Java以RDD为基础的分布式数据集，也就是分布式的Row对象的集合（每个Row对象代表一行记录），提供了详细的结构信息，也就是我们经常说的模式（schema），Spark SQL可以清楚地知道该数据集中包含哪些列、每列的名称和类型。</p><p>和RDD一样，DataFrame的各种变换操作也采用惰性机制，只是记录了各种转换的逻辑转换路线图（是一个DAG图），不会发生真正的计算，这个DAG图相当于一个逻辑查询计划，最终，会被翻译成物理查询计划，生成RDD DAG，按照之前介绍的RDD DAG的执行方式去完成最终的计算得到结果。</p><h3 id="从RDD转化成DataFrame"><a href="#从RDD转化成DataFrame" class="headerlink" title="从RDD转化成DataFrame"></a>从RDD转化成DataFrame</h3><p>Spark提供了两种模式从RDD转化为DataFrame</p><ol><li><p>利用反射机制来推断包含特定类型对象的RDD的schema，适用于对已知数据类型的转换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from pyspark.shell import sc, spark</span><br><span class="line">from pyspark.sql.types import Row</span><br><span class="line"></span><br><span class="line">peopleRDD = sc.textFile(&quot;file:///usr/local/spark-2.4.3-bin-hadoop2.7/examples/src/main/resources/people.txt&quot;)</span><br><span class="line"></span><br><span class="line">peopleDF = peopleRDD.map(lambda line: line.split(&apos;,&apos;)).map(lambda x: Row(x[0], x[1])).toDF()</span><br><span class="line"></span><br><span class="line">peopleDF.createOrReplaceTempView(&quot;people&quot;)</span><br><span class="line"></span><br><span class="line">results = spark.sql(&quot;select * from people&quot;)</span><br><span class="line"></span><br><span class="line">personsDF = results.rdd.map(lambda x: &quot;name: &quot; + x[0] + &quot;, age:&quot; + x[1]).foreach(print)</span><br></pre></td></tr></table></figure></li><li><p>使用编程接口，构造一个schema将其应用在已知的RDD上</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">from pyspark.shell import sc, spark</span><br><span class="line">from pyspark.sql.types import Row</span><br><span class="line">from pyspark.sql.types import StructType</span><br><span class="line">from pyspark.sql.types import StructField</span><br><span class="line">from pyspark.sql.types import StringType</span><br><span class="line"></span><br><span class="line">peopleRDD = sc.textFile(&quot;file:///usr/local/spark-2.4.3-bin-hadoop2.7/examples/src/main/resources/people.txt&quot;)</span><br><span class="line"></span><br><span class="line"># 根据字符串模式设置schema格式</span><br><span class="line">schemaString = &quot;name age&quot;</span><br><span class="line">fields = list(map(lambda fieldName: StructField(fieldName, StringType(), nullable=True), schemaString.split(&quot; &quot;)))</span><br><span class="line">schema = StructType(fields)</span><br><span class="line"># schema中描述了模式信息，包含两个字段name 和 age</span><br><span class="line"></span><br><span class="line">rowRDD  = peopleRDD.map(lambda line: line.split(&apos;,&apos;)).map(lambda x: Row(x[0], x[1]))</span><br><span class="line"></span><br><span class="line">peopleDF = spark.createDataFrame(rowRDD, schema)</span><br><span class="line"></span><br><span class="line"># 必须注册为临时表才能进行显示</span><br><span class="line">peopleDF.createOrReplaceTempView(&quot;people&quot;)</span><br><span class="line"></span><br><span class="line">results = spark.sql(&quot;select * from people&quot;)</span><br><span class="line"></span><br><span class="line">results.rdd.map(lambda x: &quot;Name:&quot; + x[0] + &quot;, Age: &quot; + x[1]).foreach(print)</span><br></pre></td></tr></table></figure><h3 id="将RDD保存为文件"><a href="#将RDD保存为文件" class="headerlink" title="将RDD保存为文件"></a>将RDD保存为文件</h3><ol><li><p>第一种方法read.format和write.format。write.format()支持输出 json,parquet, jdbc, orc, libsvm, csv, text等格式文件。如果要输出文本文件，可以采用write.format(“text”)，但是，需要注意，只有select()中只存在一个列时，才允许保存成文本文件，如果存在两个列，比如select(“name”, “age”)，就不能保存成文本文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; peopleDF = spark.read.format(&quot;json&quot;).load(&quot;file:///usr/local/spark/examples/src/main/resources/people.json&quot;)</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; peopleDF.select(&quot;name&quot;, &quot;age&quot;).write.format(&quot;csv&quot;).save(&quot;file:///usr/local/spark/mycode/newpeople.csv&quot;)</span><br></pre></td></tr></table></figure></li><li><p>第二种方法 rdd.saveAsTextFile</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; peopleDF = spark.read.format(&quot;json&quot;).load(&quot;file:///usr/local/spark/examples/src/main/resources/people.json&quot;</span><br><span class="line">&gt;&gt;&gt; peopleDF.rdd.saveAsTextFile(&quot;file:///usr/local/spark/mycode/newpeople.txt&quot;)</span><br></pre></td></tr></table></figure></li></ol><h3 id="通过JDBC连接数据库-，-DataFrame"><a href="#通过JDBC连接数据库-，-DataFrame" class="headerlink" title="通过JDBC连接数据库 ， DataFrame"></a>通过JDBC连接数据库 ， DataFrame</h3><h4 id="建立一个Mysql关系型数据库"><a href="#建立一个Mysql关系型数据库" class="headerlink" title="建立一个Mysql关系型数据库"></a>建立一个Mysql关系型数据库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">drop database if exists spark;</span><br><span class="line">create database spark;</span><br><span class="line">use spark;</span><br><span class="line"></span><br><span class="line">create table student(</span><br><span class="line">id int(4) auto_increment,</span><br><span class="line">    name char(20),</span><br><span class="line">    gender char(4),</span><br><span class="line">    age int(4),</span><br><span class="line">    primary key(id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">insert into student values(1, &apos;Xu Nan&apos;, &apos;F&apos;, 24);</span><br><span class="line">insert into student values(2, &apos;Xue Huan&apos;, &apos;M&apos;, 19);</span><br><span class="line"></span><br><span class="line">select * from student</span><br></pre></td></tr></table></figure><h4 id="下载JDBC驱动"><a href="#下载JDBC驱动" class="headerlink" title="下载JDBC驱动"></a>下载JDBC驱动</h4><ol><li><p>在启动pyspark的同时加载JDBC驱动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyspark --jars //usr/local/spark-2.4.3-bin-hadoop2.7/jars/mysql-connector-java-8.0.16.jar --driver-class-path //usr/local/spark-2.4.3-bin-hadoop2.7/jars/mysql-connector-java-8.0.16.jar</span><br></pre></td></tr></table></figure></li><li><p>通过jdbc来读取数据<br>依然是通过read.format进行读取，每一个option对应jdbc读取的配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; jdbcDF = spark.read.format(&quot;jdbc&quot;).option(&quot;url&quot;, &quot;jdbc:mysql://localhost:3306/spark&quot;).option(&quot;driver&quot;, &quot;com.mysql.jdbc.Driver&quot;).option(&quot;dbtable&quot;, &quot;student&quot;).option(&quot;user&quot;, &quot;root&quot;).option(&quot;password&quot;, &quot;shaoguoliang&quot;).load()</span><br><span class="line">Loading class `com.mysql.jdbc.Driver&apos;. This is deprecated. The new driver class is `com.mysql.cj.jdbc.Driver&apos;. The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary.</span><br><span class="line">&gt;&gt;&gt; jdbcDF.show()</span><br><span class="line">+---+--------+------+---+</span><br><span class="line">| id|    name|gender|age|</span><br><span class="line">+---+--------+------+---+</span><br><span class="line">|  1|  Xu Nan|     F| 24|</span><br><span class="line">|  2|Xue Huan|     M| 19|</span><br><span class="line">+---+--------+------+---+</span><br></pre></td></tr></table></figure></li><li><p>通过jdbc来写数据库</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pyspark.shell <span class="keyword">import</span> spark</span><br><span class="line"><span class="keyword">from</span> pyspark.sql.types <span class="keyword">import</span> Row</span><br><span class="line"><span class="keyword">from</span> pyspark.sql.types <span class="keyword">import</span> StructType</span><br><span class="line"><span class="keyword">from</span> pyspark.sql.types <span class="keyword">import</span> StructField</span><br><span class="line"><span class="keyword">from</span> pyspark.sql.types <span class="keyword">import</span> StringType</span><br><span class="line"><span class="keyword">from</span> pyspark.sql.types <span class="keyword">import</span> IntegerType</span><br><span class="line"></span><br><span class="line">studentRDD = spark.sparkContext.parallelize([<span class="string">"3 RongCheng F 25"</span>, <span class="string">"4 GuangXing M 20"</span>]).map(<span class="keyword">lambda</span> line: line.split(<span class="string">" "</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">schema = StructType([StructField(<span class="string">"name"</span>, StringType(), nullable=<span class="literal">True</span>), StructField(<span class="string">"gender"</span>, StringType(), nullable=<span class="literal">True</span>),</span><br><span class="line">                     StructField(<span class="string">"age"</span>, IntegerType(), nullable = <span class="literal">True</span>) ])</span><br><span class="line"></span><br><span class="line">rowRDD = studentRDD.map(<span class="keyword">lambda</span> x: Row(x[<span class="number">1</span>].strip(), x[<span class="number">2</span>].strip(), int(x[<span class="number">3</span>].strip())))</span><br><span class="line"></span><br><span class="line">studentDF = spark.createDataFrame(rowRDD, schema)</span><br><span class="line"></span><br><span class="line">prop = &#123;&#125;</span><br><span class="line">prop[<span class="string">"user"</span>] = <span class="string">"root"</span></span><br><span class="line">prop[<span class="string">"password"</span>] = <span class="string">"shaoguoliang"</span></span><br><span class="line">prop[<span class="string">"driver"</span>] = <span class="string">"com.mysql.jdbc.Driver"</span></span><br><span class="line">studentDF.write.jdbc(<span class="string">"jdbc:mysql://localhost:3306/spark"</span>, <span class="string">"student"</span>, <span class="string">"append"</span>, prop)</span><br><span class="line"></span><br><span class="line">jdbcDF = spark.read.format(<span class="string">"jdbc"</span>).option(<span class="string">"url"</span>, <span class="string">"jdbc:mysql://localhost:3306/spark"</span>).option(<span class="string">"user"</span>, <span class="string">"root"</span>)\</span><br><span class="line">    .option(<span class="string">"password"</span>, <span class="string">"shaoguoliang"</span>).option(<span class="string">"dbtable"</span>, <span class="string">"student"</span>).load()</span><br><span class="line">jdbcDF.show()</span><br></pre></td></tr></table></figure><h3 id="与Hive的连接"><a href="#与Hive的连接" class="headerlink" title="与Hive的连接"></a>与Hive的连接</h3><ol><li>测试安装的spark版本是否支持hive<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">命令行pyspark</span><br><span class="line">from pyspark.sql import HiveContext</span><br><span class="line">或者scala命令行 spark-shell</span><br><span class="line">import org.apache.spark.sql.hive.HiveContext</span><br></pre></td></tr></table></figure></li></ol><p>如果成功导入包，说明支持</p><ol><li>在Hive中创建数据库和表</li></ol><ul><li>启动mysql</li><li>启动hadoop，<code>start-all.sh</code> (启动成功的标志是在jps命令下能够看到Master和DataNode进行)</li><li>启动hive，<code>$HIVE_HOME/bin/hive</code> (启动成功标志是看到了 <code>hive&gt;</code>命令行)</li><li>成功启动mysql， hadoop， hive后，进入hive，创建一个新的数据库sparktest并创建一个数据表student，并记录两条数据<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS 学习第三篇</title>
      <link href="/2019/07/29/2019-07-29-ROS_learning_3/"/>
      <url>/2019/07/29/2019-07-29-ROS_learning_3/</url>
      
        <content type="html"><![CDATA[<p>ROS 学习笔记第三篇。参考<a href="https://rsl.ethz.ch/education-students/lectures/ros.html" target="_blank" rel="noopener">https://rsl.ethz.ch/education-students/lectures/ros.html</a> ROS教程</p><a id="more"></a> <!-- 摘要 --><h3 id="1-TF-Transformation-System"><a href="#1-TF-Transformation-System" class="headerlink" title="1. TF Transformation System"></a>1. TF Transformation System</h3><ul><li>tool for keeping track of coordinate frames over time</li><li>maintains relationship between coordinate frames in a tree structure buffered in time</li><li>lets the user transform points, vector, etc. between coordinate frames at desired time</li><li>implemented as publisher/subscriber model on the topics /tf and /tf_static</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tf2_msgs/TFMessage.msg</span><br><span class="line">可以通过</span><br><span class="line">rosmsg show TFMessage 来查找相关msg定义</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">rosmsg 解析： rosmsg show geometry_msg/Twist</span><br><span class="line">geometry_msgs/Vector3 linear</span><br><span class="line">  float64 x</span><br><span class="line">  float64 y</span><br><span class="line">  float64 z</span><br><span class="line">geometry_msgs/Vector3 angular</span><br><span class="line">  float64 x</span><br><span class="line">  float64 y</span><br><span class="line">  float64 z</span><br><span class="line"></span><br><span class="line">其中linear和angular都是复合域，即本质上是向量的关系，这个msg总共有6个参数，每3个编为一个向量进行组织。</span><br><span class="line">消息类型同样可以包含固定或可变长度的数组（常用[]来表示）</span><br></pre></td></tr></table></figure><h3 id="2-rqt-用户端口"><a href="#2-rqt-用户端口" class="headerlink" title="2. rqt 用户端口"></a>2. rqt 用户端口</h3><ul><li>User interface based on Qt</li><li>Custom interfaces can be setup</li><li>Lots of plugins exit</li><li>Simple to write own plugins</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">启动rqt：</span><br><span class="line">rosrun rqt_gui rqt_gui  或</span><br><span class="line">rqt</span><br></pre></td></tr></table></figure><h3 id="3-URDF-unified-robot-description-format"><a href="#3-URDF-unified-robot-description-format" class="headerlink" title="3.URDF unified robot description format"></a>3.URDF unified robot description format</h3><ul><li>defines an XML format for representing a robot model</li><li>URDF generation can be scripted with XACRO</li><li>the robot description is stored on the parameter server under <em>/robot_description</em></li></ul><h3 id="4-Simulation-Descriptions"><a href="#4-Simulation-Descriptions" class="headerlink" title="4. Simulation Descriptions"></a>4. Simulation Descriptions</h3><p>simulation description format (SDF)</p><ul><li>defines an XML format to describe: environments, objects, sensors, robots</li><li>sdf is the standard format for gazebo</li><li>gazebo converts a URDF to SDF automatically</li></ul><h3 id="5-ros-init"><a href="#5-ros-init" class="headerlink" title="5. ros:init()"></a>5. ros:init()</h3><p>这是ROS程序调用的第一个函数，用于对ROS程序的初始化。是在定义一个ROS node过程中进入main函数后第一个函数。<br>在创建ros::NodeHandle之前必须先对ROS程序进行初始化ros::init( argc, argv, string package_name, uint32_t options);</p><h3 id="6-ROS-创建-Subscriber-和-Publisher"><a href="#6-ROS-创建-Subscriber-和-Publisher" class="headerlink" title="6. ROS 创建 Subscriber 和 Publisher"></a>6. ROS 创建 Subscriber 和 Publisher</h3><p>Subscriber和Publisher都是ros::NodeHandle下定义的类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">首先，定义</span><br><span class="line">ros::NodeHandle nodeHandle_ = nodehandle; //从main函数中传入nodehandle</span><br><span class="line"></span><br><span class="line">ros::Subscriber sub_;</span><br><span class="line">ros::Publisher pub_;</span><br><span class="line">注意现在只是定义了类，但并没有与nodeHandle_产生联系</span><br><span class="line"></span><br><span class="line">sub_ = nodeHandle_.subscribe(topic, queue_size, &amp;callback_function, this);</span><br><span class="line">/*</span><br><span class="line">* 其中 topic为std::string</span><br><span class="line">* queue_size为int。queue_size取1到2，表示只对当前的状态感兴趣，因为数据较多就会溢出，</span><br><span class="line">* 只能保留当前最新的状态；queue_size = 0表示无限队列，同样会影响稳定性</span><br><span class="line">* 如果取值较大，则说明该topic的数据需要按顺序进行处理，不能舍弃。</span><br><span class="line">* callback_function一般为void无返回值类型</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">pub_ = nodeHandle_.advertise&lt;message_type&gt;(topic, queue_size);</span><br><span class="line">/*</span><br><span class="line">* 一定要注意message_type, 一定要符合include的message_type,</span><br><span class="line">* topic要也是std::string 一般会从yaml文件中获取</span><br><span class="line">* queue_size与上边一样，取queue_size = 0为无限队列，会影响稳定性</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>Subscriber自动监听topic，在callback函数中进行后续操作。<br>Publisher需要进行pub_.publish(msgs) 才能对外广播。</p><h3 id="7-汽车坐标系"><a href="#7-汽车坐标系" class="headerlink" title="7. 汽车坐标系"></a>7. 汽车坐标系</h3><p>汽车的前进方向为x轴，对应侧倾角，滚转角 roll；<br>指向汽车左侧方向为y轴，对应俯仰角，pitch；<br>指向汽车正上方为z轴，对应偏航角，yaw；</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS 学习第二篇</title>
      <link href="/2019/07/25/2019-07-25-ROS_learning_2/"/>
      <url>/2019/07/25/2019-07-25-ROS_learning_2/</url>
      
        <content type="html"><![CDATA[<p>ROS 学习笔记第二篇。参考<a href="https://rsl.ethz.ch/education-students/lectures/ros.html" target="_blank" rel="noopener">https://rsl.ethz.ch/education-students/lectures/ros.html</a> ROS教程</p><a id="more"></a> <!-- 摘要 --><h3 id="1-创建catkin-package"><a href="#1-创建catkin-package" class="headerlink" title="1. 创建catkin_package"></a>1. 创建catkin_package</h3><p>使用 catkin_create_pkg package_name {dependencies} 来创建一个package<br>这条命令会在当前文件夹下创建CMakelists.txt 和 package.xml 两个文件，其中package_name是相同的</p><p>在该项目中{dependencies} 为roscpp和sensor_msgs，建议在使用catkin_create_pkg的时候就将这两个dependencies加上，</p><p><strong>查看CMakeLists.txt</strong></p><ul><li>cmake_minimum_required</li><li>project(<em>project_name</em>)</li><li>find_package(catkin REQUIRED COMPONENTS … dependencies)</li><li>catkin_package(<em>INCLUDE_DIRS include</em>, <em>CATKIN_DEPENDS roscpp sensor_msgs</em> …)</li><li>include_directories( include ${catkin_INCLUDE_DIRS})</li><li>add_executable(${PROJECT_NAME} src/${PROJECT_NAME}_node.cpp src/TestControl.cpp}) //添加可执行文件的编译 </li><li>target_link_libraries(${PROJECT_NAME} ${catkin_LIBRARIES}) //这个一定不要忘掉了</li></ul><p><strong>package.xml</strong><br>这个主要检查几个dependencies是否<build></build></p><h3 id="2-package的基本组成-按重要顺序"><a href="#2-package的基本组成-按重要顺序" class="headerlink" title="2. package的基本组成(按重要顺序)"></a>2. package的基本组成(按重要顺序)</h3><ul><li>src 放置执行文件</li><li>include 放置头文件 （定义class）</li><li>config 放置参数文件 param.yaml</li><li>launch 放置launch文件</li><li>未完待续</li></ul><p>src中，主要放置node.cpp可执行文件，和class的定义文件。其中main函数在node.cpp中</p><h3 id="3-编译package"><a href="#3-编译package" class="headerlink" title="3. 编译package"></a>3. 编译package</h3><p>没有采用eclipse的编译方式，（可能在ide环境中进行编写代码会减少错误等）<br>在你建立的catkin_ws文档中，使用<br>ln -s source_dir target_dir<br>进行连接<br>在catkin_ws中进行<br>catkin build pakcage_name<br>来进行单个包的编译，根据编译后的报错信息来进行调试</p><p><strong>在每一次编译一个包之后都要对devel/setup.bash进行source更新</strong></p><h3 id="4-关于加载config-yaml中的parameter"><a href="#4-关于加载config-yaml中的parameter" class="headerlink" title="4. 关于加载config.yaml中的parameter"></a>4. 关于加载config.yaml中的parameter</h3><p>需要使用<br>ros::NodeHandle.getParam( string parameter_name_in_config, string parameter_name_defined_in_your_class)<br>需要对应parameter的名字，一次只能加载一个，所以需要在node class中添加读取config参数的定义函数</p><p>参考ros_package_template中的readParameters()</p><p>一般会将该函数定义为bool返回类型，来检查参数是否加载正确，如果不正确需要ROS_ERROR</p><h3 id="5-在launch文件中添加node"><a href="#5-在launch文件中添加node" class="headerlink" title="5. 在launch文件中添加node"></a>5. 在launch文件中添加node</h3><p><strong>roslaunch 不保证节点开始的顺序，因为没有办法从外部知道节点何时完全被初始化，因此所有的节点必须是稳健的，以便以任何顺序进行启动</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;node pkg=&quot;test&quot; name=&quot;test&quot; type=&quot;test&quot; output=&quot;screen&quot; launch-prefix=&quot;gnome-terminal --command&quot;&gt;</span><br><span class="line">    &lt;rosparam command=&quot;load&quot; file=&quot;$(find test)/config/config.yaml&quot;/&gt;</span><br><span class="line">&lt;/node&gt;</span><br></pre></td></tr></table></figure></p><p><strong>node标签</strong></p><ul><li>pkg=”mypackage” 节点包</li><li>type=”nodetype” 节点类型，必须具有一个相同名称的节点类型</li><li>name=”nodename” 节点基名称，注意name不能包含命名空间</li><li>args=”arg1 arg2 agr3” 传递参数到节点</li><li>machine=”machine name” 在指定机器上启动节点</li><li>output=”log|screen“ 只有两种选择，在log文件中或者在屏幕上的terminal显示</li><li>launch-prefix=”prefix argument“ 用于添加到节点中的启动命令、参数</li></ul><p><strong>元素</strong><br>可以在<node>标签下添加一下XML标签：</node></p><p><env>为节点设置的环境变量</env></p><p><remap>为节点设置的重新映射参数</remap></p><p><rosparam>将rosparam文件加载到此节点的~/local命令空间中</rosparam></p><p><param>在节点的~/local命名空间中设置一个参数</p><h3 id="6-launch-file-中添加其他launch文件，来同时激活多个node"><a href="#6-launch-file-中添加其他launch文件，来同时激活多个node" class="headerlink" title="6. launch file 中添加其他launch文件，来同时激活多个node"></a>6. launch file 中添加其他launch文件，来同时激活多个node</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;include file=&quot;$(find package_name)/launch/launch_file.launch&quot;&gt;</span><br><span class="line">    &lt;arg name=&quot;argname&quot; value=&quot;$(arg_defined_value)&quot;/&gt;</span><br><span class="line">&lt;/include&gt;</span><br></pre></td></tr></table></figure><p>launch file 标签group，定义命名空间ns。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">以下方法可以同时启动同一个node而不会产生冲突</span><br><span class="line">&lt;group ns=&quot;turtlesim1&quot; &gt;</span><br><span class="line">    &lt;node pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node&quot; name=&quot;sim&quot;&gt;</span><br><span class="line">&lt;/group&gt;</span><br><span class="line">&lt;group ns=&quot;turtlesim2&quot; &gt;</span><br><span class="line">    &lt;node pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node&quot; name=&quot;sim&quot;&gt;</span><br><span class="line">&lt;/group&gt;</span><br></pre></td></tr></table></figure></p><h3 id="7-使用rviz"><a href="#7-使用rviz" class="headerlink" title="7. 使用rviz"></a>7. 使用rviz</h3><p>rviz是ROS官方的一款3D可视化工具，几乎我们需要用到的所有机器人相关数据都可以在rviz中展现。<br>使用rosrun rviz rviz启动ROS系统中的rviz平台<br>也可以在launch文件中添加rviz node来启动rviz平台</p><node pkg="rviz" type="rviz" name="rviz"><p>rviz 主要包含以下几个部分：</p><ul><li>3D视图区，中间显示区</li><li>工具栏，顶部工具栏</li><li>显示项列表，用于显示当前选择的显示插件，可以配置每个插件的属性，位于左侧</li><li>视角设置区，可以选择多种观测视角，位于右侧</li><li>时间显示区，显示当前的系统时间和ROS时间</li></ul><p><strong>进行数据可视化的前提是要有数据</strong>。假设需要可视化的数据以对应的消息类型发布，我们在rviz中使用相应的插件订阅该消息即可实现显示。<br>在显示项列表中的add中添加需要显示的数据。添加完成后，rviz左侧的显示项列表会出现已经添加的显示插件。注意”Topic“属性，这个是用来声明该显示插件所订阅的数据来源，如果订阅成功，在中间的显示区应该会出现可视化后的数据。（注意有时候是因为数据点size不够大所以看不见）<br>如果显示有问题，检查属性区域的”Status“状态，status有四种状态：OK、Warning、Error和Disabled，如果显示的状态不是OK，那么需要查看错误信息，并详细检查数据发布是否正常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Tips：</span><br><span class="line">1. launch file 中，$() 而不是$&#123;&#125;</span><br></pre></td></tr></table></figure></node>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ Priority Queue的使用</title>
      <link href="/2019/07/25/2019-07-25-C++_priority_queue/"/>
      <url>/2019/07/25/2019-07-25-C++_priority_queue/</url>
      
        <content type="html"><![CDATA[<p>刷LeetCode中用到的Priority Queue使用</p><a id="more"></a> <!-- 摘要 --><h3 id="Priority-Queue-优先队列"><a href="#Priority-Queue-优先队列" class="headerlink" title="Priority Queue 优先队列"></a>Priority Queue 优先队列</h3><p><code>priority_queue</code>是包含在头文件<code>#include&lt;queue&gt;</code>中的，它与queue不同点就在于它会自动为queue内的元素进行排序。</p><p>priority_queue包含所有队列的特性，包括所有的基本操作，只是在这个基础上添加了一个内部排序，它的本质是一个堆实现的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">什么是堆？</span><br><span class="line"></span><br><span class="line">我们说的堆（heap）是程序员申请的内存空间。在C++中你可以理解为所有非常量的指针空间。和heap相对应的，还有栈stack，静态区static，常量区const，以及程序代码区。这些都是程序运行所需要申请的内存空间。</span><br><span class="line"></span><br><span class="line">heap堆与其他内存的主要差别是，heap是由程序员申请、释放和管理的，而不是由程序和系统自动分配和释放的，是动态的。另一个区别是其他区域都是有固定大小的，而heap的大小仅受内存和虚拟内存大小的限制。</span><br></pre></td></tr></table></figure><p>和队列基本操作相同：</p><ul><li>top() 访问对头元素</li><li>empty() 队列是否为空</li><li>size() 返回队列内元素个数</li><li>push() 插入元素到队尾，并排序</li><li>emplace() 原地构造一个元素并插入队列</li><li>pop() 弹出队头元素</li><li>swap() 交换内容</li></ul><h3 id="优先队列定义"><a href="#优先队列定义" class="headerlink" title="优先队列定义"></a>优先队列定义</h3><p><code>priority_queue&lt;Type, Container, Functional&gt;</code></p><ul><li>Type是数据类型</li><li>Container是容器类型，Container必须是用数组实现的容器，比如vector，dqueue等，但是不能用list。STL里默认用vector</li><li>Functional是比较的方式。</li></ul><p>当需要自定义的数据类型时才需要传入这三个参数。<br><strong>对于基本数据类型，排序默认大推顶</strong></p><ul><li><code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt;</code> 小推顶</li><li><code>priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt;</code> 大推顶</li></ul><h3 id="LeetCode例子"><a href="#LeetCode例子" class="headerlink" title="LeetCode例子"></a>LeetCode例子</h3><p>#215. Kth Largest element in an Array</p><p>Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p><p>Example 1:</p><p>Input: [3,2,1,5,6,4] and k = 2<br>Output: 5<br>Example 2:</p><p>Input: [3,2,3,1,2,4,5,5,6] and k = 4<br>Output: 4<br>Note:<br>You may assume k is always valid, 1 ≤ k ≤ array’s length.</p><p>题解：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; q; <span class="comment">//小推顶</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(q.size() &lt; k)&#123;</span><br><span class="line">                q.push(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; q.top())&#123;</span><br><span class="line">                    q.pop();</span><br><span class="line">                    q.push(nums[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> q.top();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP协议学习二：HTTP报文与Web服务器</title>
      <link href="/2019/07/24/2019-07-24-HTTP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0_HTTP%E6%8A%A5%E6%96%87/"/>
      <url>/2019/07/24/2019-07-24-HTTP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0_HTTP%E6%8A%A5%E6%96%87/</url>
      
        <content type="html"><![CDATA[<p>HTTP协议学习笔记。参考《图解HTTP协议》<br><a id="more"></a> <!-- 摘要 --></p><h3 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h3><p>用于HTTP协议交互的信息被称作HTTP报文。HTTP报文是由多行（CR+LF作为换行符）数据构成的字符串文本。HTTP报文可分为报文首部和报文主体两块。两者由最初出现的空行（CR+LF）来划分。并不一定要有报文主体。</p><p>请求报文首部结构：</p><ul><li>请求行：包含请求方法，请求URI和HTTP版本</li><li>请求首部字段：从客户端向服务器端发送请求报文时使用的首部。补充了求情的附加内容、客户端信息、响应内容相关优先级等信息。</li><li>通用首部字段</li><li>实体首部字段</li><li>其他：包含HTTP的RFC里未定义的首部（Cookie等）</li></ul><p>响应报文首部结构：</p><ul><li>状态行：包含表明响应结果的状态码，原因短语和HTTP版本</li><li>响应首部字段：从服务器端向客户端返回响应报文时使用的首部。补充了相应的附加内容，也会要求客户端附加额外的内容信息</li><li>通用首部字段</li><li>实体首部字段</li><li>其他</li></ul><ul><li><p>HTTP在传输数据时可以按照数据原貌直接传输，也可以在传输过程中通过编码提升传输速率。<br><strong>报文（message）</strong>是HTTP通信中的基本单位，由8位组字节流组成，通过HTTP通信传输<br><strong>实体（entity）</strong>作为请求或响应的有效载荷数据被传输，内容由实体首部和实体主题组成。通常报文主题等于实体主体，只有当传输中进行编码操作时，实体主题的内容发生变化才导致和报文主体产生差异。</p></li><li><p>在HTTP通信过程中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面。在传输大容量数据时，通过把数据分隔成多块，能够让浏览器逐步显示页面。把实体主题分块的功能成为<strong>分块传输编码</strong>。</p></li><li><p>HTTP协议中也采纳了多部分对象集合，发送一份报文主题内可还有多种类型实体。在HTTP报文中使用多部分对象集合时，需要在首部字段里加上Content-type，并使用boundary字符串来划分多部分对象集合指明的各类实体。</p></li><li><p>获取部分内容的<strong>范围请求</strong>。HTTP实现一种可恢复机制，指能从之前下载中断处恢复下载。要实现该功能需要制定下载的实体范围。</p></li><li><p><strong>内容协商</strong>返回最合适的内容。同一个Web网站有可能存在多份相同内容的页面，但语言不通。当浏览器的默认语言为英语或中文时，访问想用URI的Web页面会像是相应的语言页面。内容协商的类型： <em>服务器驱动协商</em>，<em>客户端驱动协商</em>， <em>透明协商</em> 。</p></li></ul><h3 id="返回结果的HTTP状态码"><a href="#返回结果的HTTP状态码" class="headerlink" title="返回结果的HTTP状态码"></a>返回结果的HTTP状态码</h3><p>状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求还是出现了错误。</p><p>状态码类别：</p><div class="table-container"><table><thead><tr><th></th><th>类别</th><th>原因短语</th></tr></thead><tbody><tr><td>1xx</td><td>Informational 信息性状态码</td><td>接收的请求正在处理</td></tr><tr><td>2xx</td><td>Success 成功状态码</td><td>请求正常处理完毕</td></tr><tr><td>3xx</td><td>Redirection 重定向状态码</td><td>需要进行附加操作以完成请求</td></tr><tr><td>4xx</td><td>Client Error 客户端错误状态码</td><td>服务器无法处理请求</td></tr><tr><td>5xx</td><td>Server Error 服务器错误状态吗</td><td>服务器处理请求出错</td></tr></tbody></table></div><p>举例：</p><p><code>200 OK</code> 表示客户端发来的请求在服务器端被正常处理了。<br><code>204 No Content</code> 该状态码代表服务器接受的请求已成功处理，但在返回的响应报文中不含实体的主体部分，也不允许返回任何实体主体。一般在只需要从客户端往服务器发送消息，而对客户端不需要发送新信息的情况下使用。<br><code>206 Partial Content</code> 表示客户端进行了范围请求，服务器成功执行了这部分GET请求。</p><p><code>301 Moved Permanently</code> 永久重定向。该状态码表示请求的资源已被分配了新的URI，以后应使用更新的URI。当请求URI执行资源路径的最后忘记添加斜杠如 <code>http://example.com/sample</code>，就会产生301状态码。如果用户保存成了书签，则自动更新书签。<br><code>302 Found</code> 临时重定向。该状态码表示请求的资源已被分配了新的URI，希望用户本次能够使用新的URI访问。如果用户保存了书签，302状态不会更新书签。<br><code>303 See Other</code> 该状态码表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源。303状态码明确表示客户端应采用GET方法获取资源。<br><code>304 Not Modified</code> 该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。304状态码返回时，不包含任何响应的主体部分。<br><code>307 Temporary Redirect</code> 临时重定向，与320 Found有相同含义。307会遵照浏览器标准，不会从POST变成GET。</p><p><code>400 Bad Request</code> 表示请求报文中存在语法错误。<br><code>401 Unauthorized</code> 该状态码表示发送的请求需要有通过HTTP认证的认证信息，如果之前已进行过1次请求，则表示用户认证失败。返回含有401的响应必须包含一个适用于被请求资源的www-authenticate首部用于质询（challenge）用户信息。当浏览器初次接收到401响应，会弹出认证用的对话窗口。<br><code>403 Forbidden</code> 该状态码表明对请求资源的访问被服务器拒绝了。服务器端没有必要给出拒绝的详细理由，但可以在实体主体部分对原因进行描述。<br><code>404 Not Found</code> 表明服务器上复发找到请求的资源，除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。</p><p><code>500 Internal Server Error</code> 表明服务器端在执行请求时发生了错误。<br><code>503 Service Unavailable</code> 表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</p><p>需要注意的是，不少返回的状态码相应都是错误的，但用户可能察觉不到这一点。比如Web应用程序内部发生错误，状态码已然返回200 OK。 </p><h3 id="Web服务器"><a href="#Web服务器" class="headerlink" title="Web服务器"></a>Web服务器</h3><p>一台Web服务器可搭建多个独立域名的Web网站，也可作为通信路径上的中转服务器提升传输效率。</p><p><strong>通信数据转发程序：代理、网关、隧道</strong><br><code>代理</code>是一种有转发功能的应用程序，接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端。代理不改变请求URI，会直接发送给前方持有资源的目标服务器。每次通过代理服务器转发请求或响应时，会追加写入Via首部信息。<br>使用代理服务器的理由有：利用缓存技术减少网络带宽的流量，组织内部针对特定网站的访问控制以获取访问日志为主要目的。代理有多重使用方法，按两种基准分类：一种是是否使用缓存，另一种是是否会修改报文。<br><code>网关</code>是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。在TCP/IP中，网关是连接两种不同通信协议的设备。在这里，网关能使通信线路上的服务器提供非HTTP服务。利用网关能提高通信的安全性。<br><code>隧道</code>隧道是在像个很远的客户端与服务器之间进行中转，并保持双方通信连接的应用程序。隧道可以按要求建立一条与其他服务器的通信线路，届时使用SSL等加密手段进行通信，隧道的目的是确保客户端能与服务器进行安全的通信。隧道本身不会去解析HTTP请求。</p><p><strong>保存资源的缓存</strong>：缓存是指代理服务器或客户端本地磁盘内保存的资源副本。利用缓存可减少对源服务器的访问，因此也就节省了通信流量和通信时间。可以避免多次从源服务器转发资源，客户端可就近从缓存服务器上获取资源。（镜像服务器）缓存服务器判定缓存过期后，会向源服务器确认资源的有效性。同时客户端也可以将资源缓存在浏览器中。浏览器缓存如果有效就不必再向服务器请求相同的资源了，可以直接从本地磁盘读取。</p><h3 id="HTTP首部"><a href="#HTTP首部" class="headerlink" title="HTTP首部"></a>HTTP首部</h3><p>首部字段结构<code>首部字段名：字段值</code>。字段值对应单个HTTP首部字段可以有多个值。</p><h4 id="通用首部字段"><a href="#通用首部字段" class="headerlink" title="通用首部字段"></a>通用首部字段</h4><div class="table-container"><table><thead><tr><th>首部字段名</th><th>解释</th><th>说明</th></tr></thead><tbody><tr><td>Cache-Control</td><td>控制缓存的行为</td><td></td></tr><tr><td>Connection</td><td>逐跳首部、连接的管理</td><td></td></tr><tr><td>Date</td><td>创建报文的日期时间</td><td></td></tr><tr><td>Pragama</td><td>报文指令</td><td></td></tr><tr><td>Trailer</td><td>报文末端的首部一览</td><td></td></tr><tr><td>Transfer-Encoding</td><td>指定报文主体的传输编码方式</td><td></td></tr><tr><td>Upgrade</td><td>升级为其他协议</td><td></td></tr><tr><td>Via</td><td>代理服务器的相关信息</td><td></td></tr><tr><td>Warning</td><td>错误通知</td></tr></tbody></table></div><h4 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h4><div class="table-container"><table><thead><tr><th>首部字段名</th><th>解释</th><th>说明</th></tr></thead><tbody><tr><td>Host</td><td>请求起源所在服务器</td><td></td></tr><tr><td>Accept</td><td>可处理的媒体类型</td><td></td></tr><tr><td>Accept-Charset</td><td>可接受的字符集</td><td></td></tr><tr><td>Accept-Encoding</td><td>可接受的内容编码</td><td></td></tr><tr><td>Accept-Language</td><td>可接受的自然语言</td></tr></tbody></table></div><h4 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a>响应首部字段</h4><div class="table-container"><table><thead><tr><th>首部字段名</th><th>解释</th><th>说明</th></tr></thead><tbody><tr><td>Accept-Ranges</td><td>可接受的字段范围</td><td></td></tr><tr><td>Location</td><td>零客户端重新定向到URI</td><td></td></tr><tr><td>Server</td><td>HTTP服务器的安装信息</td></tr></tbody></table></div><h4 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a>实体首部字段</h4><div class="table-container"><table><thead><tr><th>首部字段名</th><th>解释</th><th>说明</th></tr></thead><tbody><tr><td>Allow</td><td>资源可支持的HTTP方法</td><td></td></tr><tr><td>Content-Type</td><td>实体主体的类型</td><td></td></tr><tr><td>Content-Encoding</td><td>实体主体适用的编码方式</td><td></td></tr><tr><td>Content-Language</td><td>实体主体的自然语言</td><td></td></tr><tr><td>Content-Length</td><td>实体主题的字节数</td><td></td></tr><tr><td>Content-Range</td><td>实体主题的位置范围，一般用于发出部分请求时使用</td></tr></tbody></table></div><h3 id="HTTPS保证Web的安全"><a href="#HTTPS保证Web的安全" class="headerlink" title="HTTPS保证Web的安全"></a>HTTPS保证Web的安全</h3><p><strong>HTTP的缺点</strong>：</p><ul><li>通信使用明文（不加密），内容可能会被窃听</li><li>不验证通信方的身份，因此有可能遭遇伪装</li><li>无法证明报文的完整性，所以有可能已遭篡改</li></ul><p>HTTPS = HTTP + 加密 + 认证 + 完整性保护</p><p>HTTPS并非是应用层的一种新协议，只是HTTP通信接口部分用SSL和TLS协议替代而已。通常HTTP直接和TCP通信。当使用SSL时，就演变成了先和SSL通信，再由SSL和TCP通信。SSL通过对信息进行公开密钥加密方式实现安全传输。</p><p>公开密钥加密：发送方使用接收方公开密钥进行加密，接收方用自己的私有密钥进行解密。</p><p>HTTPS采用公开密钥和共享密钥的混合加密模式。首先用公开密钥传输后续传输的共享密钥，之后的传输使用共享密钥来提高效率。</p><p>当然，公开密钥加密方式无法证明公开密钥本身就是货真价实的公开密钥。为了解决上述问题，可以使用数字证书认证机构和其相关机关颁发的公开密钥证书 CA。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP协议学习一：什么是HTTP协议</title>
      <link href="/2019/07/23/2019-07-23-HTTP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/07/23/2019-07-23-HTTP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>HTTP协议学习笔记。参考《图解HTTP协议》<br><a id="more"></a> <!-- 摘要 --></p><h3 id="什么是HTTP协议"><a href="#什么是HTTP协议" class="headerlink" title="什么是HTTP协议"></a>什么是HTTP协议</h3><p>Web使用一种名为HTTP（HyperText Transfer Protocol）超文本传输协议作为规范，完成从客户端到服务器端等一系列运作流程。</p><p>他的网络基础是TCP/IP协议。通常使用的网络是在TCP/IP协议族的基础上运作的。而HTTP属于他内部的一个协议。与HTTP关系密切的协议：IP、TCP和DNS。</p><p>IP和TCP协议详情请参见 <a href="/2019/07/18/2019-07-18-TCP_IP计算机网络总结/" title="TCP/IP计算机网络总结">TCP/IP计算机网络总结</a>。</p><p><strong>DNS服务：</strong><br>DNS服务是和HTTP协议一样位于应用层的协议。它提供域名到IP地址之间的解析服务。计算机既可以被赋予IP地址，也可以被赋予主机名和域名。用户通常使用主机名或域名来访问对方的计算机，而不是直接通过IP地址访问。DNS协议通过提供域名查找IP地址服务。</p><p><strong>URI与URL：</strong><br>URI统一资源标识符。URI就是由某个协议方案表示的资源的定位标识符。协议方案是指访问资源所使用的协议类型名称。采用HTTP协议时，协议方案就是http。除此之外还有ftp，telnet，file等其他URI标准协议。</p><p>URL表示资源的地点（互联网上所处的位置）。可见URL是URI的一个子集。</p><p>URI格式：表示指定的URI，要使用涵盖全部必要信息的绝对URI，绝对URL以及相对URL。相对URL是指从浏览器中基本URI初指定的URL。</p><p><img src="/images/2019-07-23-HTTP协议学习/URI_format.png" alt="URI_format"></p><ul><li>登录信息（认证），指定用户名和密码作为从服务器端获取资源时必要的登录信息。（可选项）</li><li>服务器地址，使用绝对URI必须指定待访问的服务器地址。</li><li>服务器端口号，指定服务器连接的网络端口号。（也是可选项，若用户省略则自动使用默认端口号）</li><li>带层次的文件路径，指定服务器上的文件路径来定位特指的资源。</li><li>查询字符串，针对已指定的文件路径内的资源，可以使用查询字符串传入任意参数（可选项）</li><li>片段标识符，使用片段标识符通常可标记处已获取资源中的子资源。</li></ul><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>HTTP协议用于客户端和服务器之间的通信。请求访问资源的一端成为客户端，而提供资源响应的一段成为服务器端。</p><h4 id="客户端发送请求报文"><a href="#客户端发送请求报文" class="headerlink" title="客户端发送请求报文"></a>客户端发送请求报文</h4><p>请求报文示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /index.htm HTTP/1.1  #GET表示请求访问服务器的类型，成为方法；/index.htm指明请求访问的资源对象，也叫做请求URI。最后是HTTP版本号</span><br><span class="line">Host: hakr.jp</span><br></pre></td></tr></table></figure></p><p>请求报文是由请求方法，请求URI，协议版本，可选的请求首部字段和内容实体构成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#请求首部字段</span><br><span class="line">POST /form/entry HTTP/1.1</span><br><span class="line">Host: hackr.jp</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 16</span><br><span class="line">#内容实体字段</span><br><span class="line">name=ueno&amp;age=37</span><br></pre></td></tr></table></figure><h4 id="服务器返回处理结果"><a href="#服务器返回处理结果" class="headerlink" title="服务器返回处理结果"></a>服务器返回处理结果</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#返回处理结果首部</span><br><span class="line">HTTP/1.1 200 OK #200OK表示请求的处理结果状态码（status code）和原因短语（reason-phrase）</span><br><span class="line">Date: Tue, 10 Jul 2012 06:50:15 GMT #显示创建相应的日期时间</span><br><span class="line">Content-Length: 362</span><br><span class="line">Content-Type: text/html</span><br><span class="line"></span><br><span class="line">#处理结果内容实体</span><br><span class="line">&lt;html&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>响应报文由协议版本、状态码、原因短语、可选的响应首部字段以及实体主体构成。</p><h4 id="HTTP是不保存状态的协议"><a href="#HTTP是不保存状态的协议" class="headerlink" title="HTTP是不保存状态的协议"></a>HTTP是不保存状态的协议</h4><ul><li>HTTP协议自身不对请求和相应之间的通信状态进行保存。在HTTP这个级别，协议对发送过的请求或响应都不做持久化处理。这是为了快速处理大量事务。</li><li>Cookie技术。无状态协议经常使业务处理变得困难，比如用户登录购物网站，在页面跳转之间需要保证登录状态。这种情况下，网站为了掌握是谁送出的请求，需要保存用户的状态。</li></ul><h4 id="请求URI定位资源"><a href="#请求URI定位资源" class="headerlink" title="请求URI定位资源"></a>请求URI定位资源</h4><p>HTTP协议使用URI定位互联网上的资源。当客户端请求访问资源而发送请求时，URI需要将作为请求报文中的请求URI包含在内。</p><p>可以使用完整URI也可以使用在Host中写明网络域名和IP地址的方法指定URI。</p><h4 id="告知服务器意图的HTTP方法"><a href="#告知服务器意图的HTTP方法" class="headerlink" title="告知服务器意图的HTTP方法"></a>告知服务器意图的HTTP方法</h4><ul><li><code>GET</code> 获取资源。用来请求访问已被URI识别的资源。</li><li><code>POST</code> 传输实体主题。</li><li><code>PUT</code> 传输文件。像FTP协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存到请求URI指定的位置。</li><li><code>HEAD</code> 获取报文首部。与GET一样，但不返回报文主题部分。用于确认URI的有效性以及资源更新的日期时间等。</li><li><code>DELETE</code> 删除文件。与PUT相反</li><li><code>OPTIONS</code> 询问支持的方法。用来查询针对请求URI指定的资源支持的方法</li><li><code>TRACE</code> 让Web服务器端将之前的请求通信环回给客户端的方法。客户端通过TRACE方法可以查询发送出去的请求时怎样被加工修改、篡改的。这是因为，请求想要连接的源目标服务器可能会通过代理中转，TRACE方法就是用来确认连接过程中发生的一系列操作。</li><li><code>CONNECT</code> 要求用隧道协议连接代理。主要使用SSL和TSL协议把通信内容加密后经网络隧道传输。</li></ul><h4 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h4><ul><li>单次HTTP连接请求。</li></ul><p><img src="/images/2019-07-23-HTTP协议学习/HTTP_response.png" alt="HTTP_response"></p><p>出现问题，当资源中含有大量图片，这种每次请求都要建立TCP连接的方式就非常冗余。</p><ul><li><p><strong>持久连接</strong>。只要任意一段没有明确提出断开连接，则保持TCP连接状态。<strong>这也就是TCP断开问什么是四次挥手</strong><br>持久连接的好处在于减少了TCP重复连接和断开造成的额外开销，减轻了服务器端的负载。</p></li><li><p><strong>管线化</strong>。持久连接使得多数请求以pipelining方式发送成为可能。从前发送请求后需要等待并收到响应才能发送一个请求。管线化技术可以不用等待响应也可发送下一个请求。</p></li></ul><p>当请求一个包含10张图片的HTML页面时，与挨个连接相比，用持久连接可以让请求更快结束。而管线化可以比持久连接更快。</p><h4 id="使用Cookie的状态管理"><a href="#使用Cookie的状态管理" class="headerlink" title="使用Cookie的状态管理"></a>使用Cookie的状态管理</h4><p>HTTP是无状态协议，它不对之前发生过的请求和相应状态进行管理。也就是无法根据之前的状态进行本次的请求处理。</p><p>要求登录认证的Web页面本身无法进行状态的管理，那么每次跳转新页面就需要 <em>再次登录</em> 或者 <em>在每次请求报文中附加参数来管理登录状态</em> 。</p><p>Cookie是用过在请求和响应报文中写入Cookie信息来控制客户端的状态。Cookie会根据从服务器端发送的响应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去。服务器端发现客户端发送的Cookie后，会去检查是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS 学习第一篇</title>
      <link href="/2019/07/22/2019-07-22-ROS_learning_1/"/>
      <url>/2019/07/22/2019-07-22-ROS_learning_1/</url>
      
        <content type="html"><![CDATA[<p>ROS 学习笔记第一篇。参考<a href="https://rsl.ethz.ch/education-students/lectures/ros.html" target="_blank" rel="noopener">https://rsl.ethz.ch/education-students/lectures/ros.html</a> ROS教程<br><a id="more"></a> <!-- 摘要 --></p><h3 id="ROS"><a href="#ROS" class="headerlink" title="ROS"></a>ROS</h3><p>ROS = Robot Operating System</p><ol><li>Plumbing</li><li>Tools</li><li>Capabilities</li><li>Ecosystem</li></ol><p>Philosophy</p><ol><li>Peer to peer communication<br> Individual programs communicate over define API (ROS msgs, services, etc)</li><li>Distributed</li><li>Multi-Lingual<br> C++ Python, Matlab, Java</li><li>Light-Weight</li><li>Free and Open</li></ol><p>ROS就是一个分布式的信息交互操作系统，每个node通过将信息传递给相应的接收node从而进行相应的操作。</p><p>ROS master manages the msgs, start with <code>roscore</code><br>ROS nodes, single-purpose, individually compiled, organized in pakages<br>    rosrun package_name<br>    rosnode list<br>ROS Topics, node communicate over topics</p><p>尽量使用catkin build pakage_name<br>注意使用catkin build需要安装python_catkin_tools这个包<br>Whenever you build a new package, update your environment<br>source devel/setup.bash</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">linux 建立链接</span><br><span class="line">ln -s 源目录 目标目录</span><br><span class="line">参数s (symbolic) 建立软链接，并不会重新建立文件，只会建立一个同步链接</span><br><span class="line">如果没有-s则会建立硬链接，重新建立文件，</span><br><span class="line"></span><br><span class="line">注意无论是软链接还是硬链接，都会在两个文件目录中进行同步，修改一处就会修改另一处</span><br></pre></td></tr></table></figure><p>ROS launch is a tool for launching multiple nodes (as well as parameters). Are written in XML as *.launch files<br>Start a launch file from a package: &gt; roslaunch package_name file_name.launch<br>When launching, arguments can be set with &gt;roslaunch launch_file.launch arg_name:=value</p><h3 id="ROS-Topic"><a href="#ROS-Topic" class="headerlink" title="ROS Topic"></a>ROS Topic</h3><ul><li>rostopic list 可以查看所有的rostopic</li><li>rosmsg show可以查看当前rosmsg的格式是什么</li><li>利用rostopic在终端进行命令控制：<br><code>rostopic pub [parm] [topic] [type] [args]</code><br>例如：在husky_simulation中对cmd_vel 的geometry_msgs/Twist进行控制 （-r 10）表示以10hz的频率进行publish<br>rostopic pub -r 10 /cmd_vel /geometry_msgs/Twist — ‘[0.1, 0.0, 0.0]’ ‘[0.0., 0.0, 0.1]’<br>千万注意参数中的空格，输入参数的格式</li></ul><h3 id="环境配置问题"><a href="#环境配置问题" class="headerlink" title="环境配置问题"></a>环境配置问题</h3><ol><li>catkin build 需要安装python_catkin_tools (apt 安装)</li><li>进行catkin build ros_package_template 的时候发现如下错误：</li></ol><p>ImportError: “from catkin_pkg.package import parse_package” failed: No module named catkin_pkg.package<br>Make sure that you have installed “catkin_pkg”, it is up to date and on the PYTHONPATH.</p><p>这里提示找不到catkin_pkg。注意catkin_pkg有两种安装方式，回到用户根目录，使用pip进行安装。<br>pip install catkin_pkg</p><p>安装成功之后，编译成功</p><ol><li>如果觉得配置失败，可以使用catkin clean将生成的devel,build和logs目录删掉重新进行配置</li><li><p>在进行gazebo husky仿真的时候，出现no module called rospkg found.<br>这个仍然使用pip进行安装，pip install rospkg</p></li><li><p>使用gazebo进行仿真的时候，因为之前安装了anaconda python3.5 导致在编译的过程中出现_tf2 import error. 要切回ubuntu自带的python2.7才可以<br>系统自带的python位于/usr/bin, 所以先查看echo $PATH, 如果/usr/bin位于anaconda之前，则python会先找到python2.7而不是anaconda。<br>我的方法是将固定的PATH在.bashrc中先死打印，之后调整anaconda的前后顺序，这样就可以避免PATH出现一堆重复的路径。</p></li></ol><h3 id="gazebo-world-加载失败黑屏的问题"><a href="#gazebo-world-加载失败黑屏的问题" class="headerlink" title="gazebo world 加载失败黑屏的问题"></a>gazebo world 加载失败黑屏的问题</h3><p>$cd /usr/share/gazebo-7/worlds</p><p>$gazebo willowgarage.world </p><p>打开gazebo的时候会发现一直处于这种状态，这是因为model库加载不正确导致的。</p><p>解决办法：</p><p>$ cd ~/</p><p>$ hg clone <a href="https://bitbucket.org/osrf/gazebo_models" target="_blank" rel="noopener">https://bitbucket.org/osrf/gazebo_models</a></p><p>下载完成后将gazebo_models复制到~/.gazebo文件夹中，重命名为models.<br>注意使用cp 进行文件复制的时候，将该目录下的所有文件复制是<br>cp -r dir/ dir/<br>查看models下是否包含所有的model文件</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS相关表格设置</title>
      <link href="/2019/07/19/2019-07-19-CSS%E7%9B%B8%E5%85%B3%E8%A1%A8%E6%A0%BC%E8%AE%BE%E7%BD%AE/"/>
      <url>/2019/07/19/2019-07-19-CSS%E7%9B%B8%E5%85%B3%E8%A1%A8%E6%A0%BC%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>最近使用的hexo来重新部署我的博客。在hexo-theme中设置页面布局使用css。找到<code>hexo-theme/source/css</code>中使用的主题css。</p><h3 id="css-Table设置"><a href="#css-Table设置" class="headerlink" title="css Table设置"></a>css Table设置</h3><p>在html中一个表格包含：<code>&lt;table&gt;</code>元素，一个或多个<code>&lt;tr&gt;</code> <code>&lt;th&gt;</code> <code>&lt;td&gt;</code>元素。其中<code>&lt;tr&gt;</code>元素定义表格行，<code>&lt;th&gt;</code>元素定义表头，<code>&lt;td&gt;</code>元素定义表单元格。<br>更复杂的html表格可能包含<code>&lt;caption&gt;</code>、<code>&lt;col&gt;</code>、<code>&lt;colgroup&gt;</code>、<code>&lt;thead&gt;</code>、<code>&lt;tfoot&gt;</code> 以及 <code>&lt;tbody&gt;</code> 元素。</p><h4 id="表格边框"><a href="#表格边框" class="headerlink" title="表格边框"></a>表格边框</h4><p>采用黑色边框，颜色可以使用rgb。#000000表示黑色<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">table, th, td</span><br><span class="line">&#123;</span><br><span class="line">    border: 1px solid black; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意上边的例子中有双边框，因为table和th/td有独立的边界。为了使用一个表的单个边框，使用border-collapse属性</p><h4 id="折叠边框"><a href="#折叠边框" class="headerlink" title="折叠边框"></a>折叠边框</h4><p>collapse设置表格的边框是否被折叠成一个单一的边框。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">table</span><br><span class="line">&#123;</span><br><span class="line">    border-collapse:collapse;</span><br><span class="line">&#125;</span><br><span class="line">table, th, td</span><br><span class="line">&#123;</span><br><span class="line">    border: 1px solid black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="表格宽度和高度"><a href="#表格宽度和高度" class="headerlink" title="表格宽度和高度"></a>表格宽度和高度</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">table </span><br><span class="line">&#123;</span><br><span class="line">    width:100%;</span><br><span class="line">&#125;</span><br><span class="line">th</span><br><span class="line">&#123;</span><br><span class="line">    height:50px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然还有最小宽度min-width等。</p><h4 id="表格文字对齐"><a href="#表格文字对齐" class="headerlink" title="表格文字对齐"></a>表格文字对齐</h4><p>text-align属性设置水平对齐方式，向左，右，或中心:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">td</span><br><span class="line">&#123;</span><br><span class="line">    text-align:right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>垂直对齐属性设置垂直对齐，比如顶部，底部或中间:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">td</span><br><span class="line">&#123;</span><br><span class="line">    height:50px;</span><br><span class="line">    vertical-align:bottom;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="表格填充"><a href="#表格填充" class="headerlink" title="表格填充"></a>表格填充</h4><p>控制表格中内容和边框之间的距离<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">td</span><br><span class="line">&#123;</span><br><span class="line">    padding:15px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="表格颜色"><a href="#表格颜色" class="headerlink" title="表格颜色"></a>表格颜色</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">table, td, th</span><br><span class="line">&#123;</span><br><span class="line">    border:1px solid green;</span><br><span class="line">&#125;</span><br><span class="line">th</span><br><span class="line">&#123;</span><br><span class="line">    background-color:green;</span><br><span class="line">    color:white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="我设置的表格"><a href="#我设置的表格" class="headerlink" title="我设置的表格"></a>我设置的表格</h3><ol><li>css局部定义属性(沿用了我使用的主题)<code>.post-content</code>, 使用后代元素选择器和子元素选择器<ul><li>后代选择器又称为包含选择器，后代选择器可以选择作为某元素后代的元素。比如<code>.post-content table{}</code>就是对在post-content中table的元素全部使用这个。</li><li>子元素选择器，不想使用任意后代元素，只想选择某个元素的子元素<code>.post-content &gt; table</code>。也就是table元素必须是.post-content的直接子元素才可以。</li></ul></li><li>每行颜色不同</li><li>取消每个单元格内容缩进 <code>text-indent</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">.post-content &#123;</span><br><span class="line">  line-height: 20px;</span><br><span class="line">  font-size: 14px;</span><br><span class="line">  text-indent: 0; /*表格缩进*/</span><br><span class="line">  color: #333333;</span><br><span class="line">  font-weight: 300;</span><br><span class="line">&#125;</span><br><span class="line">.post-content &gt; table,</span><br><span class="line">.post-content &gt; table tr th,</span><br><span class="line">.post-content &gt; table tr td &#123; /*单元格*/</span><br><span class="line">  border: 1px solid #000000;</span><br><span class="line">  padding: 4px;</span><br><span class="line">  min-width: 50px;</span><br><span class="line">&#125;</span><br><span class="line">.post-content table &#123;</span><br><span class="line">  border-collapse: collapse;</span><br><span class="line">&#125;</span><br><span class="line">.post-content table tr:nth-child(odd)&#123; /*表行设置奇数行颜色不同*/</span><br><span class="line">  background: #ddd;</span><br><span class="line">&#125;</span><br><span class="line">.post-content table th&#123; /*表头行*/</span><br><span class="line">  background: #fff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS，hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP计算机网络总结</title>
      <link href="/2019/07/18/2019-07-18-TCP_IP%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/"/>
      <url>/2019/07/18/2019-07-18-TCP_IP%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>参考《图解TCP/IP》。</p><h3 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h3><p>OSI参考模型对通信中必要的功能做了归纳。OSI协议是以OSI参考模型为基础界定了每个阶层的协议和每个阶层之间接口相关的标准。OSI协议是为了让<strong>异构</strong>的计算机之间能够相互通信，由ISO和ITUT推进其标准化的网络体系结构。</p><div class="table-container"><table><thead><tr><th>NO.</th><th>分层名称</th><th>功能</th><th>功能概览</th></tr></thead><tbody><tr><td>7</td><td>应用层</td><td>针对特定应用的协议</td><td>针对每个应用的协议，如电子邮件、远程登录、文件传输。【APP协议】</td></tr><tr><td>6</td><td>表示层</td><td>设备固有数据格式和网络标准数据格式的转换</td><td>接收不同表现形式的信息，如文字流，图像，声音。【数据流】</td></tr><tr><td>5</td><td>会话层</td><td>通信管理。负责建立和断开通信连接（数据流动的逻辑通路）。管理传输层以下的分层</td><td>两台计算机之间何时建立连接，何时断开连接以及保持多久的连接。</td></tr><tr><td>4</td><td>传输层</td><td>管理两个节点之间的数据传输。负责可靠传输（确保数据被可靠地传送到目的地址）</td><td>在两个节点传输过程中是否有数据丢失【TCP、UDP】</td></tr><tr><td>3</td><td>网络层</td><td>地址管理与路由器选择</td><td>两个节点经过哪个路由器能够传递到目标地址【IP】</td></tr><tr><td>2</td><td>数据链路层</td><td>互联设备之间传送和识别数据帧</td><td>如数据帧与比特流之间的转换，数据包分段发送，互联设备之间使用mac地址进行区分。目的是为了识别连接到同一传输介质上的设备。</td></tr><tr><td>1</td><td>物理层</td><td>以0，1代表电压的高低。界定连接器与网线的规格</td><td>比特流与电子信号之间的切换</td></tr></tbody></table></div><p>双方通信，发送方<strong>从第7层到第1层</strong>由上向下按照顺序传输数据。接收端<strong>从下到上</strong>传输数据。</p><h3 id="传输方式的分类"><a href="#传输方式的分类" class="headerlink" title="传输方式的分类"></a>传输方式的分类</h3><h4 id="面向有连接性、面向无连接性"><a href="#面向有连接性、面向无连接性" class="headerlink" title="面向有连接性、面向无连接性"></a>面向有连接性、面向无连接性</h4><ul><li><strong>面向有连接型</strong>：在发送数据之前，需要在收发主机之间连接一条通信线路。必须在通信前后，专门进行建立和断开连接的处理。如果与对端之间无法通信，就可以避免发送无谓的数据。【TCP】</li><li><strong>面向无连接型</strong>：发送端可以在任何时候自由发送数据。接收端也永远不知道自己会在何时从哪里收到数据。在面向无连接的情况下，接收端需要时常确认自己是否收到了数据。【UDP】</li></ul><h4 id="电路交换与分组交换"><a href="#电路交换与分组交换" class="headerlink" title="电路交换与分组交换"></a>电路交换与分组交换</h4><ul><li><strong>电路交换</strong>中：交换机主要负责数据的 <em>中转处理</em> 。计算机先被连在交换机上，交换机与交换机之间由众多通信线路再继续连接。计算机之间在发送数据时，需要通过交换机与目标主机建立通信电路。 <em>一台计算机在收发信息时会独占整个电路</em> ，其他计算机只能等待这台计算机处理结束之后才有机会使用这条电路收发数据。如果并发用户超过交换机之间的通信线路数，就意味着通信根本无法实现。</li><li><strong>分组交换</strong>中：让连接到通信电路的计算机将所要 <em>发送的数据分成多个数据包</em> ，按照一定的顺序排列之后分别发送。这样<strong>提高了通信线路的利用率</strong>。数据包的首部header写入了发送端与接收端的地址。发送端计算机将数据分组发送给路由器，路由器收到这些分组数据以后缓存到自己的缓冲区，然后再转发给目标计算机。（蓄积交换， FIFO）<br>在分组交换中，通信线路的速度可能会有所不同，根据网络拥堵的情况，数据到达目标地址的时间有长有短。另外，路由器的缓存饱和或溢出时，甚至可能会发生分组数据丢失、无法发送到对端的情况。</li></ul><h4 id="根据接收端数量分类"><a href="#根据接收端数量分类" class="headerlink" title="根据接收端数量分类"></a>根据接收端数量分类</h4><ul><li>单播 Unicast 例如固定电话</li><li>广播 BroadCast 指将消息从一台主机发送给与值向量的所有其他主机。电视播放</li><li>多播 Multicast 电视会议</li><li>任播 Anycast 特定的多台主机中选出一台作为接收端的一种通信方式。任播从目标主机群众选择一台最符合网络条件的主机作为目标主机发送消息。通常，被选中的那台特定主机将返回一个单播信号，随后发送端主机会只跟这台主机进行通信。 【DNS根域名解析服务器】</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p>一个地址必须明确地表示一个主体对象。<strong>地址的唯一性</strong>。在广播，多播和任播通信中，通信接收端被赋予同一个具有唯一特性的地址，从而可以避免产生歧义。</p><h4 id="地址的层次性"><a href="#地址的层次性" class="headerlink" title="地址的层次性"></a>地址的层次性</h4><ul><li>mac地址由设备的制造商针对每块上网卡进行分别制定。虽然mac地址在某种程度上有一定的层次性，但对于寻找地址没有任何作用。【数据链路层使用地址】</li><li>IP地址由网络号和主机号两部分组成。网络号相同，说明他们处于同一网段。通常处于同一网段的主机也都属于同一个部门或集团组织。【网络层使用】<br>网络传输中，每个节点会根据分组数据的地址信息，来判断该报文应该由哪个网卡发送出去。为此，各个地址会参考一个发出接口列表。MAC寻址中参考的这张表叫做地址转发表，而IP寻址所参考的为路由控制表。路由表中记录的ip地址是集中了之后的网络号。<br>网络传输中，每个节点会根据分组数据的地址信息，来判断该报文应该由哪个网卡发送出去。</li></ul><h3 id="网络构成的要素"><a href="#网络构成的要素" class="headerlink" title="网络构成的要素"></a>网络构成的要素</h3><div class="table-container"><table><thead><tr><th>设备</th><th>作用</th></tr></thead><tbody><tr><td>网卡</td><td>是计算机联网的设备(Network interface)</td></tr><tr><td>中继器(Repeater)</td><td>从<strong>物理层</strong>上延长网络的设备</td></tr><tr><td>网桥(Bridge)、2层交换机</td><td>从<strong>数据链路层</strong>上延长网络的设备</td></tr><tr><td>路由器(Router)、3层交换机</td><td>通过<strong>网络层</strong>转发分组数据的设备</td></tr><tr><td>4-7层交换机</td><td>数理传输层以上各层网络传输的设备</td></tr><tr><td>网关(Gateway)</td><td>转换协议的设备</td></tr></tbody></table></div><p><strong>网卡</strong>：网络接口卡NIC，LAN卡<br><strong>中继器</strong>：连接相同的通信媒介。但也有中继器可以完成不同媒介之间的转接工作，也可以提供多端口服务(集线器)。【电路交换】<br><strong>网桥、2层交换机</strong>：能够识别数据链路层的数据帧，并将蛇蝎数据帧临时存储于内存，再重新生成信号作为一个全新的帧转发给相连的另一个网段。【分组交换】。以太网中经常使用的交换集线器Hub也属于网桥的一种，网桥根据mac地址进行处理。<br><strong>路由器、3层交换机</strong>：路由器根据IP地址进行处理。网络层连接两个网络，并对分组报文进行转发的设备。<br><strong>4-7层交换机</strong>：处理从传输层到应用层的数据，分析收发数据，并对其进行特定的处理。比如，为了通过同一个url将前端访问分发到后台多个服务器上，可以在这些服务器前端增加一个负载均衡器。<br><strong>网关</strong>：将传输层到应用层的数据进行转换和转发的设备。网关不仅转发数据还负责对数据进行转换，通常会使用一个表示层或应用层网关，在两个不能直接通信的协议之间进行翻译，最终实现两者的通信。例子，互联网邮件与手机邮件之间的转换服务。此外，在使用www时，为了控制网络流量和处于安全的考虑，有时会使用代理服务器（Proxy Server）。这种代理服务器也是网关的一种，成为应用网关。有了代理服务器，客户端与服务器之间无需在网络层上直接通信，而是从传输层到应用层对数据和访问进行各种控制和处理。</p><h3 id="不同层相关协议"><a href="#不同层相关协议" class="headerlink" title="不同层相关协议"></a>不同层相关协议</h3><h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p><strong>IP</strong>：</p><ul><li>IP是跨越网络传送数据包，整个互联网都能收到数据的协议，在这期间网络使用IP地址作为主机的表示。</li><li>IP还隐含着数据链路层的功能。通过IP，相互通信的主机之间不论经过怎样的底层数据链路都能够实现通信。</li><li>虽然IP也是分组交换的一种协议，但不具有重发机制。即使分组数据包未能到达主机端也不会重发。属于<strong>非可靠性传输协议。</strong></li></ul><p><strong>ICMP</strong>：</p><ul><li>IP数据包在发送途中一旦发生异常导致无法到达对端目标地址时，需要给发送端发送一个发生异常的通知。用来诊断网络的健康状况。</li></ul><p><strong>ARP（address resolution protocol）</strong>：</p><ul><li>从分组数据包的IP地址中解析出物理地址的一种协议。主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。</li><li>地址解析协议是建立在网络中各个主机互相信任的基础上的，网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存；由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个ARP欺骗。</li></ul><h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><p><strong>TCP</strong>：</p><ul><li>是一种面向有连接的传输层协议。可以保证两端通信主机之间的通信可达。TCP能够正确处理在传输过程中丢包、传输顺序乱掉等异常情况。此外，TCP还能够有效利用带宽，缓解网络拥堵。但为了建立与断开连接，有时他需要至少7次的发包首部，导致网络流量的浪费。</li></ul><p><strong>UDP</strong>：</p><ul><li>面向无连接的传输层协议。UDP不会关注对端是否真的收到了传送过去的数据，如果需要检查对端是否收到分组数据包，或者对端是否连接到网络，则需要在应用程序中实现。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">**TCP UDP区别**</span><br><span class="line">* TCP是面向连接的，UDP是无连接的；</span><br><span class="line">* TCP是可靠的，UDP是不可靠的；</span><br><span class="line">* TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多的通信模式；</span><br><span class="line">* TCP是面向字节流的，UDP是面向报文的；</span><br><span class="line">* TCP有拥塞控制机制;UDP没有拥塞控制，适合媒体通信；</span><br><span class="line">* TCP首部开销(20个字节)比UDP的首部开销(8个字节)要大；</span><br><span class="line"></span><br><span class="line">作者：CleverLove777</span><br><span class="line">链接：https://www.zhihu.com/question/28903757/answer/575333243</span><br><span class="line">来源：知乎</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h4 id="应用层（会话层以上的分层）"><a href="#应用层（会话层以上的分层）" class="headerlink" title="应用层（会话层以上的分层）"></a>应用层（会话层以上的分层）</h4><p><strong>WWW</strong>：<br>浏览器与服务端之间的通信所用协议为HTTP（HyperText Transfer Protocol）。数据格式主要是HTML</p><p><strong>电子邮件E-mail</strong></p><p><strong>文件传输 FTP</strong>：<br>指将保存在其他计算机硬盘上的文件转移到本地的硬盘，或者将本地硬盘的文件传送到其他机器硬盘上。在FTP进行文件传输时会建立两个TCP连接，分别是发出传输请求时所要用到的控制连接和与实际传输数据时所要用到的数据连接。</p><p><strong>远程登录TELNET与SSH</strong></p><p><strong>网络管理SNMP</strong></p><h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><p><img src="/images/2019-07-18-TCP_IP计算机网络总结/TCP_IP_header.png" alt="数据包首部"></p><p><strong>分组数据包经过以太网的数据链路大致流程</strong>：包流动时，从前往后依次被附加了以太网包首部，ip包首部，tcp包首部已经应用于自己的包首部和数据。包尾则追加了以太网的包尾。每个包首部都至少会包含两个信息：<strong>一个是发送端和接收端地址，另一个是上一层的协议类型</strong>。<br>经过每个协议分层时，都必须有识别包发送端和接收端的信息。以太网用mac地址，IP协议用ip地址，TCP/UDP用 <em>端口号</em> 作为识别两端主机的地址。</p><p><strong>数据接收处理</strong>：</p><ol><li>主机收到以太网包，首先在包首部找到mac地址判断是否为发送给自己的包。<ul><li>如果不是则丢弃数据。</li><li>如果是自己的包，在以太网包首部类型与确定以太网协议所穿过来的数据类型。如果以IP包，则将数据传给IP子程序，如果不是IP是ARP之类的协议，那么就把数据传给ARP处理。</li></ul></li><li>IP收到IP包首部及后边的数据部分后，做类似的处理。如果ip地址与自己的ip地址匹配，将后续数据tcp包或udp包传给后边的协议进行处理。</li><li>TCP模块。<ul><li>首先会计算校验和，判断数据是否破坏。</li><li>然后是否按照序号接受数据。</li><li>最后检查端口号，确定具体的应用程序。</li><li>数据接收完毕后，接收端发送一个确认回执给发送端。</li><li>如果这个回执未能到达发送端，那么发送端会认为接收端没有接受数据而一直反复发送。</li><li>数据被完成接受后会传给由端口号识别的应用程序。</li></ul></li><li>接收端应用程序会直接接收发送端发送的数据。</li></ol><p>tips：在TCP/IP协议中的服务端口（逻辑端口，即逻辑意义上用于区分服务的端口），端口号范围从0到65535。比如用于浏览网页服务的80端口，用于FTP服务的21端口。</p><h4 id="TCP的三次握手四次挥手"><a href="#TCP的三次握手四次挥手" class="headerlink" title="TCP的三次握手四次挥手"></a>TCP的三次握手四次挥手</h4><p><img src="/images/2019-07-18-TCP_IP计算机网络总结/TCP_IP_connection.jpeg" alt="TCP_IP_connection"></p><p><img src="/images/2019-07-18-TCP_IP计算机网络总结/TCP_header.png" alt="TCP_header"><br>如果SYN标志为1，说明是握手包。FIN标志为1，说明是挥手包。<br>窗口，占2个字节，窗口指的是发送本报文段的一方的接收窗口，不是自己的发送窗口，告诉对方：从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量。进行“流量控制”。</p><p>TCP主要包括<strong>建立连接</strong>、<strong>数据传输</strong>、<strong>断开连接</strong>这三步。</p><p><strong>三次握手建立连接</strong>：</p><ul><li><em>第一次</em> ：客户端发送syn包(seq=x)到服务器，并进入SYN_SEND状态，等待服务器确认</li><li><em>第二次</em> ：服务器收到syn包，必须确认客户的syn(ack=x+1)，同时自己也发送一个syn包(seq=y)，即SYN+ACK包，此时服务器进入SYN_RECV状态</li><li><em>第三次</em> ：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</li></ul><p>握手过程中传送的包里<strong>不包含数据</strong>，三次握手完毕后，客户端与服务器才正式开始传送数据。<strong>理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。</strong></p><p><strong>数据传输</strong>：</p><ul><li><em>超时重传</em> ：超时重传机制用来保证TCP传输的可靠性。每次发送数据包时，发送的数据报都有seq号，接收端收到数据后，会回复ack进行确认，表示某一seq 号数据已经收到。发送方在发送了某个seq包后，等待一段时间，如果没有收到对应的ack回复，就会认为报文丢失，会重传这个数据包。</li><li><em>快速重传</em> ：接受数据一方发现有数据包丢掉了。就会发送ack报文告诉发送端重传丢失的报文。如果发送端连续收到标号相同的ack包，则会触发客户端的快速重传。比较超时重传和快速重传，可以发现超时重传是发送端在傻等超时，然后触发重传;而快速重传则是接收端主动告诉发送端数据没收到，然后触发发送端重传。</li><li><em>流量控制</em> ：TCP滑动窗流量控制。TCP头里有一个字段叫Window，又叫Advertised-Window，这个字段是接收端告诉发送端自己 还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。 滑动窗可以是提高TCP传输效率的一种机制。</li><li><em>拥塞控制</em> ：滑动窗用来做流量控制。 <em>流量控制只关注发送端和接受端自身的状况</em> ，而没有考虑整个网络的通信情况。 <em>拥塞控制，则是基于整个网络来考虑的</em> 。考虑一下这样的场景：某一时刻网络上的延时突然增加，那么，TCP对这个事做出的应对只有重传数据，但是，重传会导致网络的负担更重，于是会导致更大的延迟以及更多 的丢包，于是，这个情况就会进入恶性循环被不断地放大。拥塞策略算法主要包括：慢启动，拥塞避免，拥塞发生，快速恢复。</li></ul><p><img src="/images/2019-07-18-TCP_IP计算机网络总结/TCP_retransmit.png" alt="TCP_retransmit"></p><p><img src="/images/2019-07-18-TCP_IP计算机网络总结/fast_retransmittion.png" alt="高速重发"></p><p><strong>四次挥手断开连接</strong>：</p><ul><li><em>第一次挥手</em> ：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但此时主动关闭方还可以接受数据。</li><li><em>第二次挥手</em> ：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1(与SYN相同，一个FIN占用一个序号)。</li><li><em>第三次挥手</em> ：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。</li><li><em>第四次挥手</em> ：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 为什么是三次握手而不是两次握手：</span><br><span class="line">假设是两次握手，client想要与server进行连通。</span><br><span class="line">（1）第一次握手syn包丢了。server没有收到，也没有ack。那么client会再发一个第一次握手包。这时server只收到了一个请求，连接正常。</span><br><span class="line">（2）第一次握手syn包只是因为网络阻塞，在规定时间没有到server。那么client再发一个syn包时，server最终回收到两个请求，请持续的等待两个client向它发送数据。而client这个时候只要发一次。会无端地占用资源。</span><br><span class="line">2. 为什么是四次挥手：</span><br><span class="line">（1）因为是双向通信。</span><br><span class="line">（2）client向server挥手，只能控制client不向server发送信息了。但是server仍然有权向client发送信息。</span><br></pre></td></tr></table></figure><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><ol><li>采用mac地址识别在数据链路中互联的节点。mac地址48bit，任何一个网卡的mac地址都是唯一。（当然全球范围内mac地址不总是唯一的，只要在一个数据链路中的mac地址不重复就没有问题。）</li><li><strong>共享介质网络</strong>：多个设备共享一个通信介质的一种网络。设备之间使用同一个载波信道进行发送和接收，基本采用半双工通信（同一时间只能允许一个传输行为）。控制方式：争用方式和令牌传递方式。【典型：在无线数据链路中，如2.4GHz无线WiFi，同一时刻无线WiFi只能和一个设备进行通信。因此当设备增多的时候，每一个设备分得的资源就会极大的降低，导致网速降低。】</li><li><strong>非共享介质网络</strong>(ATM、以太网的主流方式)。对介质采取专用的一种传输控制方式。在这种方式下，网络中的每个站直连交换机。由交换机负责转发数据帧。在此方式下，发送端和接收端并不共享通信介质，因此很多情况下采用全双工通信方式。通过交换机攻坚网络，从而使计算机与交换机端口之间形成一对一的连接。该方式还可以根据交换机的特性构建虚拟局域网进行流量控制VLAN。</li></ol><p>以太网交换机就是持有多个端口的网桥（交换集线器）。他们根据数据链路层中的每个帧的目标mac地址，决定从哪个网络接口发送数据。这个要参考用来记录发送接口的<strong>转发表</strong>。当某个mac地址作为源地址的包由某一接口发出，就可以理解为该mac地址就是该接口的目标。这是一个自学过程。</p><p><img src="/images/2019-07-18-TCP_IP计算机网络总结/selfLearning_bridge.png" alt="交换集线器自学过程"></p><h3 id="IP网际传输协议"><a href="#IP网际传输协议" class="headerlink" title="IP网际传输协议"></a>IP网际传输协议</h3><ul><li>网络层的主要作用是实现终端节点之间的end-to-end通信。配有IP地址但不进行路由控制的设备成为主机。既配有ip地址又具有路由控制能力的设备叫做路由器。节点是主机和路由器的统称。</li><li>数据链路层提供直连两个设备之间的通信功能（也就是局域网通信功能）。网络层的IP协议负责由<strong>路由器</strong>连接的两个网络之间的通信传输。</li><li>IP协议大致的三个作用模块为<strong>IP寻址</strong>、<strong>路由</strong>以及<strong>IP分包与分组</strong>。<ul><li>IP地址用于在所有连接到网络中的主机中识别与之进行通信的目标地址。路由控制是将发送数据送到最终的目标地址。IP包在网络间一个一个被跳（Hop）着转发。</li><li>Hop是指<strong>利用数据链路层以下的功能</strong>传输数据的一个区间。路由器与路由器之间是数据链路在连接，他们之间的一个Hop是由mac地址识别的。那么我们要发往目标ip地址的包要怎么跳呢？通过路由控制表。</li><li><strong>路由控制表</strong>。为了将数据包发给目标主机，所有主机都维护一张路由控制表。该表记录发往某ip地址的包在下一跳应该发送给哪个路由器。然后在 <em>数据链路</em> 上进行传输。（当然维护这个表是有时限的，因为有些ip地址是变化的）</li><li><strong>IP分包与分组</strong>。IP实现的是多数据链路之间的协议。IP连接了多个不同的数据链路，而数据链路最大的区别就是他们各自的最大传输单位不同。为了解决这个问题，IP进行分片处理，将大IP包分成多个小IP包。到对端目的地址（mac）之后再组合起来传给上一层。</li></ul></li><li>IP协议特征：<ul><li>面向无连接，在发包之前不需要建立连接。目的是简化，提速。传输的可靠性由上一层的TCP来提供</li><li>提供尽力服务。为了把数据包发送到最终目标地址尽最大努力，但不做收到与否的验证。（所以会出现掉包）</li></ul></li><li>IP地址：由网段和主机两部分表示组成。网段标识必须保证相互连接的每个段的地址不重复，而相同段内的主机必须有相同的网段地址。IP地址的主机标识不允许在一个网段内重复出现。<ul><li>例子：192.168.128.107/24 表示从第一位数到第24位位置属于网络标识。现在基本上以子网掩码来区分网络标识。255.255.255.0就是24位网段标识。</li><li>IP包在被转发的途中，路由器根据目标IP地址的<strong>网络标识进行路由</strong>。</li><li>目前普遍采用的扩充IP的方式为NAT。通过少数全局IP地址代理服务器结合NAT进行互联网通信来扩充ip地址。</li><li>主机地址全部设为1的时候，该地址是广播地址。主机地址全部为0时，只有在对应网络地址或ip地址不可获知的情况下才可使用。广播地址192.168.0.255用于在同一链路中相互连接的主机之间发送数据包。设为广播地址的IP包会被路由器屏蔽掉，不会到达其他网段的链路上。</li></ul></li></ul><p><img src="/images/2019-07-18-TCP_IP计算机网络总结/NAT.png" alt="NAT"></p><p><img src="/images/2019-07-18-TCP_IP计算机网络总结/broadcasting_IP.png" alt="广播地址"></p><ul><li>路由控制表生成：<ul><li>管理员手动</li><li>路由器与其他路由器相互交换信息时自动刷新。IP协议始终认为路由表是正确的。</li><li>默认路由，路由表中的任何一个地址都能与之匹配的记录。一般记为0.0.0.0/0</li><li>主机路由，IP地址所有位都参与路由192.168.153.15/32。主机路由多用于不希望通过网络地址路由的情况。</li><li>回环地址，<strong>同一台计算机上的不同程序之间进行网络通信时所使用的默认地址</strong>。localhost(127.0.0.1)。使用这个ip或主机名时，数据包不会流向网络。</li><li>路由表的聚合：利用网络地址的比特分布可以有效地进行分层配置。对内即使有多个子网掩码，对外呈现出的也是一个网络地址。（其实就是修改了对应的子网掩码）</li></ul></li></ul><p><img src="/images/2019-07-18-TCP_IP计算机网络总结/router_learning.png" alt="路由控制表生成"></p><p><img src="/images/2019-07-18-TCP_IP计算机网络总结/router_learning_aggregate.png" alt="路由表聚合"></p><ul><li>DNS服务：Domain Name System域名管理服务。DNS可以将通信字符串自动转换为具体的IP地址。在TCP/IP中有一个叫做主机识别码的东西，主机识别码为每台计算机赋予唯一的主机名，在进行网络通信时可以直接使用主机名而无需一大长传ip地址。主机往往会利用一个叫hosts的数据库文件（比如在Linux中的/etc/hosts）。</li><li>DDNS解析器。进行DNS查询的主机和软件叫做DNS解析器。用户所使用的工作站或者个人电脑都属于解析器。一个解析器至少要注册一个以上域名服务器的ip地址。通常他至少包括组织内部的域名服务器ip地址。</li></ul><p><img src="/images/2019-07-18-TCP_IP计算机网络总结/DNS.png" alt="DNS服务"></p><ul><li>ARP：根据ARP可以动态地进行地址解析。所以在TCP/IP的网络构造和网络通信中无需事先知道MAC地址究竟是什么，只要有IP地址就可以。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP/IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java单例模式</title>
      <link href="/2019/07/17/2019-07-17-Java%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/07/17/2019-07-17-Java%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>Java单例模式的几种实现方法：<br><a id="more"></a> <!-- 摘要 --></p><h3 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h3><p>线程安全，调用效率高，但是不能延时加载。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class ImageLoader&#123; </span><br><span class="line">     private static ImageLoader instance = new ImageLoader; </span><br><span class="line">     private ImageLoader()&#123;&#125; </span><br><span class="line">     public static ImageLoader getInstance()&#123;  </span><br><span class="line">          return instance;  </span><br><span class="line">      &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>特点：<br>（1）单例模式在类定义中设置为static<br>（2）类构造函数设置为private<br>在程序编译的过程中就把单例对象构建出来保存在内存中，是单例模式最简单的实现模式。问题就是在还没有用到单例的时候，初始化就已经加载出来了。如果从头到尾都没有使用这个单例，那么这个单例还是会加载出来占用资源。</p><h3 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h3><p>线程安全，调用效率不高，但是能延时加载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonDemo2 &#123;</span><br><span class="line">     </span><br><span class="line">    //类初始化时，不初始化这个对象(延时加载，真正用的时候再创建)</span><br><span class="line">    private static SingletonDemo2 instance;</span><br><span class="line">     </span><br><span class="line">    //构造器私有化</span><br><span class="line">    private SingletonDemo2()&#123;&#125;</span><br><span class="line">     </span><br><span class="line">    //方法同步，调用效率低</span><br><span class="line">    public static synchronized SingletonDemo2 getInstance()&#123;</span><br><span class="line">        if(instance==null)&#123;</span><br><span class="line">            instance=new SingletonDemo2();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用synchronized保证线程安全。<strong>synchronized修饰方法的时候锁定的是调用该方法的对象。它并不能使调用该方法的多个对象在方法执行上进行互斥。</strong><br>将一个类的构造函数私有化将使这个类不被实例化和不能被继承。要创建这个类的实例，必须创造一个静态的公共方法。这种方式就是懒汉单例模式。</p><h3 id="静态内部类实现模式"><a href="#静态内部类实现模式" class="headerlink" title="静态内部类实现模式"></a>静态内部类实现模式</h3><p>线程安全，调用效率高，可以延时加载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonDemo3 &#123;</span><br><span class="line">    //创建静态私有内部类</span><br><span class="line">    private static class SingletonClassInstance&#123;</span><br><span class="line">        private static final SingletonDemo3 instance=new SingletonDemo3();</span><br><span class="line">    &#125;</span><br><span class="line">    //同样私有化构造函数</span><br><span class="line">    private SingletonDemo3()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    public static SingletonDemo3 getInstance()&#123;</span><br><span class="line">        return SingletonClassInstance.instance;</span><br><span class="line">    &#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>参考<a href="/2019/07/17/2019-07-17-JVM的类加载原理机制/" title="JVM的类加载原理机制">JVM的类加载原理机制</a>中解析的部分。由于解析的的动态链接属性，将单例存放在内部类中，在加载过程class SingletonDemo3的时候会发现加入了内部类，该内部类不会马上被加载。而是在调用到该类中的成员变量或方法的时候才加载该内部类。<strong>即使这个内部类是静态的也不会被当做静态代码块进行加载</strong>。</p><h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public enum SingletonDemo4 &#123;</span><br><span class="line">    //枚举元素本身就是单例</span><br><span class="line">    INSTANCE;</span><br><span class="line">    //添加自己需要的操作</span><br><span class="line">    public void singletonOperation()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用关键字enum定义的枚举类型，在编译期后，也将转换成为一个实实在在的类，而在该类中，会存在每个在枚举类型中定义好变量的对应实例对象。</p><h3 id="选用标准"><a href="#选用标准" class="headerlink" title="选用标准"></a>选用标准</h3><ul><li>单例对象 占用资源少，不需要延时加载，<strong>枚举</strong> 好于 饿汉</li><li>单例对象 占用资源多，需要延时加载，<strong>静态内部类</strong> 好于 懒汉式</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM的类加载原理机制</title>
      <link href="/2019/07/17/2019-07-17-JVM%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/07/17/2019-07-17-JVM%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>参考：<br><a href="https://www.cnblogs.com/Qian123/p/5707562.html" target="_blank" rel="noopener">https://www.cnblogs.com/Qian123/p/5707562.html</a><br><a href="https://blog.csdn.net/xiao__jia__jia/article/details/81044621" target="_blank" rel="noopener">https://blog.csdn.net/xiao__jia__jia/article/details/81044621</a></p><h3 id="JVM简介"><a href="#JVM简介" class="headerlink" title="JVM简介"></a>JVM简介</h3><p>JVM 全称是Java Virtual Machine ，Java 虚拟机。JVM 的命令集则是可以到处运行的，因为JVM 做了翻译，根据不同的CPU ，翻译成不同的机器语言。<br>JVM是一个在内存中生成的虚拟机，它的存储全部都在内存中，也就是我们写的所有类、常量、变量、方法都在内存中，这决定着我们程序运行的是否健壮、是否高效。</p><h3 id="JVM组成部分"><a href="#JVM组成部分" class="headerlink" title="JVM组成部分"></a>JVM组成部分</h3><p><img src="/images/2019-07-17-JVM的类加载原理机制/JVM结构.png" alt="JVM结构"><br>从图中可以看出，JVM是运行在操作系统之上的，没有与硬件的直接互通。下图显示的是JVM的构成图。<br><img src="/images/2019-07-17-JVM的类加载原理机制/JVM构成.png" alt="JVM构成"><br>可以看出JVM主要由以下四部分构成</p><h4 id="class-loader-类加载器"><a href="#class-loader-类加载器" class="headerlink" title="class loader 类加载器"></a>class loader 类加载器</h4><p>类加载器的作用是将class文件加载到内存中。</p><h4 id="execution-engine-执行引擎"><a href="#execution-engine-执行引擎" class="headerlink" title="execution engine 执行引擎"></a>execution engine 执行引擎</h4><p>执行引擎也叫做解释器，负责将命令解释给操作系统执行。</p><h4 id="native-interface-本地接口"><a href="#native-interface-本地接口" class="headerlink" title="native interface 本地接口"></a>native interface 本地接口</h4><p>本地接口是为了融合不同的编程语言为Java所用，目前使用的比较少。</p><h4 id="runtime-data-area-运行数据区"><a href="#runtime-data-area-运行数据区" class="headerlink" title="runtime data area 运行数据区"></a>runtime data area 运行数据区</h4><p>运行数据区是整个JVM 的重点。我们所有写的程序都被加载到这里，之后才开始运行。</p><h3 id="JVM类加载器的原理机制"><a href="#JVM类加载器的原理机制" class="headerlink" title="JVM类加载器的原理机制"></a>JVM类加载器的原理机制</h3><p>Java中的所有类，都需要由类加载器装载到JVM中才能运行。类加载器本身也是一个类，而它的工作就是把class文件从硬盘读取到内存中。在写程序的时候，我们几乎不需要关心类的加载，因为这些都是隐式装载的，除非我们有特殊的用法，像是反射，就需要显式的加载所需要的类。<br>类装载方式有两种：</p><ul><li>隐式装载：程序在运行过程中当碰到通过new 等方式生成对象时，隐式调用类装载器加载对应的类到jvm中；</li><li>显示装载：通过class.forname()等方法，显式加载需要的类<br>Java的类加载是动态的，它并不会一次性地将所有类全部加载后在运行，而是保证程序运行的基础类（像基类）完全加载到jvm中，置于其他类，则在需要的时候才加载。这就节省了内存开销。<br>Java的类加载器有三个，对应Java的三种类<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Bootstrap Loader //负责加载系统类。指内置类如String</span><br><span class="line"> |</span><br><span class="line"> -- ExtClassLoader //负责加载扩展类。指继承类和实现类</span><br><span class="line">  |</span><br><span class="line">  -- AppClassLoader //负责加载应用类，程序员自定义的类</span><br></pre></td></tr></table></figure></li></ul><p>类加载器的步骤如下：<br>（1）装载：查找和导入class文件。<br>（2）连接：检查载入的class文件数据的正确性；为类的静态变量分配存储空间；将符合引用转换为直接引用。（也就是<strong>验证</strong>，<strong>准备</strong>，<strong>解析</strong>三个步骤）<br>（3）初始化：初始化静态变量和静态代码块。<br>（4）使用<br>（5）卸载<br>这样的过程会在程序调用类的静态成员的时候开始执行，所以静态方法main()才会成为一般程序的入口方法。类的构造器也会引发该动作。</p><h4 id="关注连接步骤的准备阶段"><a href="#关注连接步骤的准备阶段" class="headerlink" title="关注连接步骤的准备阶段"></a>关注连接步骤的准备阶段</h4><ol><li>准备阶段的目的：正式为<strong>类变量</strong>分配内存并设置<strong>类变量初始值</strong>的阶段。这些变量所使用的内存将在方法区中分配。注意这里是类变量（static）而不是实例变量。</li><li>这里的类变量初始值通常是指数据类型的零值。比如int=0， boolean=false。真正的初始化赋值是在初始化阶段进行的。当然如果你将类变量设置为final，那么准备阶段变量的初始值就会直接变为你设定的那个初始值。</li></ol><h4 id="关注连接步骤的解析阶段"><a href="#关注连接步骤的解析阶段" class="headerlink" title="关注连接步骤的解析阶段"></a>关注连接步骤的解析阶段</h4><ol><li><strong>解析的目的：虚拟机将常量池内的符号引用替换为直接引用。</strong>因为在准备阶段为类变量分配了内存，将直接引用分配的内存地址。</li><li>解析阶段的特点：发生时间不可预料，有可能和初始化阶段相互交换位置。</li><li>什么是常量池？常量池(constant pool)指的是在编译期被确定，并被保存在已编译的.class文件中的一些数据。他包括了关于类、方法、接口等中的<strong>常量static</strong>，也包括字符串常量。解析阶段的常量池就是存在于.class文件中的常量池，结果在运行期被JVM装载，并且可以扩充的存在于方法区中的运行时常量池。</li><li>解析中的动态链接：这是解析阶段发生时间不确定的直接原因：大部分JVM的实现都是延迟加载或者叫动态链接。他的意思就是JVM装载某个类A时，<strong>如果类A中有引用其他类B，虚拟机并不会将这个类B也同时装载进JVM内存，而是等到执行的时候采取装载。</strong>而这个被引用的B类在引用他的类A中的表现形式主要被登记在了符号表中，而解析的过程就是当需要用到被引用类B的时候，将引用类B在引用类A的符号尹永明改为内存中的直接引用。这就是解析发生时间不确定的原因，而且这个阶段是发生在方法区的。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac OS 环境变量设置</title>
      <link href="/2019/07/16/2019-07-16-MacOS%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%AE%BE%E7%BD%AE/"/>
      <url>/2019/07/16/2019-07-16-MacOS%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>问题：MacOS，配置了iTerms作为终端工具，最近发现在/etc/profile和~/.bashrc中配置的环境变量在开机或者打开新的终端的时候并没有自动加载，每一次打开新的终端端口都要重新source一下。但是诸如 <code>echo $HADOOP_HOME</code> 这样的命令执行是可以执行的，所以问题就在于环境变量总加载点在哪里。</p><a id="more"></a> <!-- 摘要 --><h3 id="Mac中的环境变量文件"><a href="#Mac中的环境变量文件" class="headerlink" title="Mac中的环境变量文件"></a>Mac中的环境变量文件</h3><p>Mac一般使用bash作为默认shell，mac系统的环境变量加载顺序一般为：</p><p><strong>全局配置</strong></p><ul><li><strong>/etc/profile</strong> 系统级别环境变量，全局公有配置，不管是哪个用户登录的时候都会读取该文件。此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行. 并从/etc/profile.d目录的配置文件中搜集shell的设置。</li><li><strong>/etc/paths</strong> 全局环境变量建议修改到这个文件</li><li><strong>/etc/bashrc</strong> 全局公有配置，bash shell执行时不管是何种方式都会读取此文件。为每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取。</li></ul><p><strong>单个用户配置</strong></p><ul><li><strong>~/.bash_profile</strong> 任意一个文件中添加环境变量（注意Linux中是.bashrc,Mac中是.bash_profile）。当bash shell是以login方式登录的时候才会读取此文件，该文件仅执行一次。如果在操作命令行的过程中想立刻生效，需要source命令。默认情况下，他设置一些环境变量，并加载用户的.bashrc文件</li><li><strong>~/.bashrc</strong> 该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该该文件被读取。</li></ul><h3 id="我的情况"><a href="#我的情况" class="headerlink" title="我的情况"></a>我的情况</h3><ol><li>首先发现/etc/profile中配置的环境变量名称是没有问题的，但是路径$PATH并没有加载</li></ol><p><img src="/images/2019-07-16-Mac环境变量设置/etc_profile检查.png" alt="etc_profile环境变量检查"></p><ol><li>检查~/.bash_profile发现了罗列在这个文件中的环境变量都加载到了$PATH中，那么在这个文件中添加<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure></li></ol><p>然后问题解决。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>注意我的~/.bash_profile中只有路径变量，并没有其他文件的加载。</p><p>/etc/profile中与其他路径的加载相关的也只有<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if [ -x /usr/libexec/path_helper ]; then</span><br><span class="line">        eval `/usr/libexec/path_helper -s`</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ &quot;$&#123;BASH-no&#125;&quot; != &quot;no&quot; ]; then</span><br><span class="line">        [ -r /etc/bashrc ] &amp;&amp; . /etc/bashrc</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p><p>所以私以为~/.bash_profile会是最终配置$PATH的地方，至少是决定了最终环境路径的地方。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> macOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java项目_一本糊涂账_Debug开发日志</title>
      <link href="/2019/07/16/2019-07-16-Java%E9%A1%B9%E7%9B%AE_%E4%B8%80%E6%9C%AC%E7%B3%8A%E6%B6%82%E8%B4%A6_Debug%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/"/>
      <url>/2019/07/16/2019-07-16-Java%E9%A1%B9%E7%9B%AE_%E4%B8%80%E6%9C%AC%E7%B3%8A%E6%B6%82%E8%B4%A6_Debug%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p>本篇记录了Java项目 ”一本糊涂账“ 的Debug开发日志。包括项目总结，整体架构复盘。<br><a id="more"></a> <!-- 摘要 --></p><h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h3><p>”一本糊涂账“是一个Java + MySQL项目，对数据库中的数据进行简单统计和显示的项目。<br>主体架构分为：（1）数据库MySQL设计 （2）UI设计 （3）JDBC传递MySQL数据库与Java程序的接口<br>三层架构之间的关系为：UI中的数据与数据库MySQL中的数据通过JDBC进行交互</p><p>我们要解决的需求：<br>（1）需要记录每一笔消费，这笔<strong>消费</strong>要对应<strong>不同分类</strong>，<strong>当天日期</strong>，<strong>相应备注</strong><br>（2）分类信息可以自行添加增减修改<br>（3）对消费记录信息进行简单统计，并用图标形式进行更改<br>（4）能够设置当月经费预算，并能够对数据库进行备份和恢复</p><p>针对以上主体架构和需求分析，我们需要构建的包如下：</p><ul><li>gui.frame =&gt; 对应UI设计主窗格</li><li>gui.panel =&gt; 对应UI设计<ul><li>gui.service =&gt; 对应UI中相应的服务，在这里调用JDBC</li><li>gui.listener =&gt; 对应于UI中相应的控件所触发的服务 </li><li>gui.model =&gt; UI中相关表格和相关数据统计可视化</li></ul></li><li>entity =&gt; 对应MySQL中相应的表结构，对应MySQL数据库中每一条数据在Java程序中的实例</li><li>dao =&gt; JDBC实现，调用sql语句进行相应的数据库操作，并将数据库数据对应到entity实例</li><li>util =&gt; 小功能实现，比如java.sql.Date与java.Util.Date之间的转化</li><li>startup =&gt; 总程序入口，建立一个线程入口</li></ul><h3 id="项目总结复盘"><a href="#项目总结复盘" class="headerlink" title="项目总结复盘"></a>项目总结复盘</h3><h4 id="数据库MySQL设计"><a href="#数据库MySQL设计" class="headerlink" title="数据库MySQL设计"></a>数据库MySQL设计</h4><p>如何构建数据库表结构是应该最先考虑的事情，也就是如何设置原始数据。后续的一切功能都需要建立在这个数据库上。</p><ul><li>针对需求1：记录表格。记录每一笔消费，每一条记录具有属性 <em>消费金额</em> ， <em>消费类别</em> ， <em>消费日期</em> ， <em>备注</em> 这四个属性。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">create table record(</span><br><span class="line">id int auto_increment, #主键</span><br><span class="line">   spend int, # 消费金额</span><br><span class="line">   cid int, #消费类别</span><br><span class="line">   comment varchar(255), #备注</span><br><span class="line">   date Date, #消费日期</span><br><span class="line">   primary key(id),</span><br><span class="line">   constraint fk_record_category foreign key (cid) references category(id)</span><br><span class="line">)ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure></li></ul><p>其中我们注意到<strong>消费类别</strong>是有限固定的，因此需要建立另一个表对应消费类别。这个消费类别对应另一个表中的主键数字。</p><ul><li><p>针对消费类别：记录消费类别。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table category(</span><br><span class="line">id int auto_increment, #主键</span><br><span class="line">   name varchar(255), #分类的名称</span><br><span class="line">   primary key(id)</span><br><span class="line">)ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure></li><li><p>针对需求4：需要进行相关设置。建立一个表来配置相关设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table config(</span><br><span class="line">id int auto_increment, #主键</span><br><span class="line">    key_ varchar(255), #设置名称 key_</span><br><span class="line">    value varchar(255), #设置内容 value</span><br><span class="line">    primary key (id)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure></li><li><p>相应的对应于Java中的entity数据实例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Category &#123; //对应消费类别</span><br><span class="line">    public int id;</span><br><span class="line">    public String name;</span><br><span class="line">    public int recordNumber; //这个其实没有用到</span><br><span class="line">    public method()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Config &#123; //对应数据库设置</span><br><span class="line">    public int id;</span><br><span class="line">    public String key;</span><br><span class="line">    public String value;</span><br><span class="line">    public method()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Record &#123; //对应每条消费记录</span><br><span class="line">    public int id;</span><br><span class="line">    public int spend;</span><br><span class="line">    public int cid;//对应category中的类别id</span><br><span class="line">    public String comment;</span><br><span class="line">    public Date date;</span><br><span class="line">    public method()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="相关sql建立"><a href="#相关sql建立" class="headerlink" title="相关sql建立"></a>相关sql建立</h5><ul><li><p>建立数据库并使用该数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">drop database if exists hutubill; #检查是否存在该数据库</span><br><span class="line">create database hutubill; #如果不存在则创建该数据库</span><br><span class="line">use hutubill; #定位到该数据库</span><br></pre></td></tr></table></figure></li><li><p>定义表属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE table_name (column_name column_type);</span><br><span class="line">example：</span><br><span class="line">`runoob_title` VARCHAR(100) NOT NULL #通过设置NOT NULL, 当输入数据位NULL的时候，mysql会报错</span><br></pre></td></tr></table></figure></li><li><p>设置主键</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">primary key (column_name) #设置主键</span><br><span class="line">auto_increment #设置自增加，一般设置在主键上</span><br></pre></td></tr></table></figure></li><li><p>设置存储引擎</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENGINE 设置存储引擎, InnoDB是数据存储过后，关闭数据库数据仍然存在。</span><br><span class="line">CHARSET 设置编码，utf-8编码包含了中文</span><br></pre></td></tr></table></figure></li></ul><h4 id="JDBC使用"><a href="#JDBC使用" class="headerlink" title="JDBC使用"></a>JDBC使用</h4><p>JDBC是Mysql提供给Java语言的一个接口。主要目的是通过Java程序来操作Mysql数据库。</p><p><strong>获取Mysql连接</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package util;</span><br><span class="line"></span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 建立DB连接</span><br><span class="line"> * @author shaoguoliang</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class DBUtil &#123;</span><br><span class="line">    static String ip = &quot;127.0.0.1&quot;;</span><br><span class="line">    static int port = 3306; //问题是如何确定是mysql是在3306端口,在mysql Workbench查看</span><br><span class="line">    static String database = &quot;hutubill&quot;;</span><br><span class="line">    static String encoding = &quot;UTF-8&quot;;</span><br><span class="line">    static String loginName = &quot;root&quot;;</span><br><span class="line">    static String password = &quot;shaoguoliang&quot;;</span><br><span class="line">    static&#123;</span><br><span class="line">    try &#123;</span><br><span class="line">    Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); //注意与你的Mysql版本相对应</span><br><span class="line">    &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">    // TODO: handle exception</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static Connection getConnection() throws SQLException&#123;</span><br><span class="line">    String url = String.format(&quot;jdbc:mysql://%s:%d/%s?characterEncoding=%s&quot;, ip, port, database, encoding);</span><br><span class="line">    return DriverManager.getConnection(url,loginName,password);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>JDBC的基本使用模式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">String sql = &quot;insert into record values (NULL, ?, ?, ?, ?)&quot;;</span><br><span class="line">try(Connection connection = new DBUtil.getConnection();</span><br><span class="line">    PreparedStatement ps = connection.preparedStatement(sql, Statement.RETURN_GENERATED_KEYS);)&#123; //这里需要带上Statement.RETURN_GENERATED_KEYS才能使sql返回的结果成功转化为ResultSet</span><br><span class="line">    ps.setInt(1, record.spend); //设置相应数据表的数据，注意要与数据表中的设置一一对应</span><br><span class="line">    ps.setInt(2, record.cid);</span><br><span class="line">    ps.setString(3, record.comment);</span><br><span class="line">    ps.setDate(4, DateUtil.util2sql(record.date));</span><br><span class="line">    ps.execute();</span><br><span class="line">    ResultSet rs = ps.getGeneratedKeys(); //返回执行结果</span><br><span class="line">    while(rs.next())&#123; //判断返回结果rs是否为空</span><br><span class="line">        record.id = rs.getInt(1); //这里数据表中的第一位为id主键</span><br><span class="line">    &#125;</span><br><span class="line">&#125; catch (Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>使用经验：</strong></p><ol><li>尽量使用PreparedStatement，这样你可以轻而易举的控制能够加载sql语句中的那几个限定的类型，而不是自己将他转化成String的形式 <a href="https://www.runoob.com/mysql/mysql-data-types.html" target="_blank" rel="noopener">https://www.runoob.com/mysql/mysql-data-types.html</a></li><li><p>在使用日期查询的过程中，sql语句中的date格式必须是<code>yyyy-mm-dd HH:MM:SS</code>. 比如在进行查询两个日期中间的数据时：<br><code>String sql = &quot;select * from record where date &gt;= ? and date &lt;= ? order by id desc&quot;;</code><br>如果使用<code>ps.setDate(1, java.sql.Date date)；</code> 来进行填充，那么java.sql.Date只有yyyy-mm-dd没有时间信息。并且我们数据库里的是java.Util.Date。需要进行转换：<code>java.sql.Date(java.sql.Date d.getTime())</code>。但转换过来就只有日期。<br>也可以使用<code>ps.setTimeStamp(1, java.sql.TimeStamp(d.getTime()))</code>来进行填充，但是timeStamp是毫秒计数，转换出来的是<code>yyyy-mm-dd HH:MM:SS.ms</code>。同样不符合要求。所以我选择了用字符串来填充的方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static String util2sqlTimestamp(java.util.Date d)&#123;</span><br><span class="line">    DateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);    </span><br><span class="line">    String dateStr = sdf.format(d);</span><br><span class="line">    return dateStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>statement执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Statement s = connection.createStatement(); //这里不加sql</span><br><span class="line">s.execute(sql);</span><br><span class="line">s.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">PreparedStatement = connection.preparedStatement(sql); //这里要加上sql</span><br><span class="line">ps.execute();</span><br><span class="line">ResultSet rs = ps.executeQuery();</span><br><span class="line"></span><br><span class="line">注意如果需要返回ResultSet需要在statement中加入Statement.RETURN_GENERATED_KEYS</span><br></pre></td></tr></table></figure></li><li><p>ResultSet返回</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rs.next(); //用来判断是否返回ResultSet</span><br><span class="line">rs.getInt(); //填入列号或者字段名</span><br><span class="line">rs.getString();</span><br></pre></td></tr></table></figure></li></ol><h4 id="UI设计，Service与Listener触发"><a href="#UI设计，Service与Listener触发" class="headerlink" title="UI设计，Service与Listener触发"></a>UI设计，Service与Listener触发</h4><p><strong>1. UI设计</strong><br>UI设计主要用到包含两个库：</p><ul><li>import javax.swing.JFrame; //用来创建主窗体，包含各种板面</li><li>import javax.swing.JPanel; //用来创建各种板面，包含各种控件。<br>主窗体是整个程序的入口。一个程序的UI实际上就是在一个主窗体上不断变换各种显示面板。<br><em>创建单例模式</em> ：<br>单例模式指的是在应用整个生命周期内只能存在一个<strong>实例</strong>。单例模式是一种被广泛使用的设计模式。他有很多好处，能够避免实例对象的重复创建，减少创建实例的系统开销，节省内存。<br><em>单例模式与静态类的区别</em> ：首先单例模式是一个唯一存在的实例。静态类只是在程序编译的时候就创建了，可以不用创建实例就能进行调用。如果是一个非常重的对象，单例模式可以进行懒加载，静态类无法做到。如果只想使用一些方法或者变量，使用静态类在编译的过程中进行构建会比较快；但如果这个对象需要大量的后期维护，访问资源的时候，应该选择单例模式。</li></ul><p>这里创建主窗体和板面都我们都用了单例模式：(都使用了饿汉模式加载:声明静态变量，在编译的时候构建对象, 缺点是占用资源，这种方式适合占用资源少，在初始化时候就能够用到的类。)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">主窗体单例模式</span><br><span class="line">public class MainFrame extends JFrame&#123;</span><br><span class="line">    public static MainFrame instance = new MainFrame(); </span><br><span class="line">    private MainFrame() &#123;</span><br><span class="line">        // TODO Auto-generated constructor stub</span><br><span class="line">        this.setSize(500, 450);</span><br><span class="line">        this.setTitle(&quot;一本糊涂账&quot;);</span><br><span class="line">        this.setContentPane(MainPanel.instance);</span><br><span class="line">        this.setLocationRelativeTo(null);//无固定位置</span><br><span class="line">        this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在考虑板面交互的过程中，我们发现板面拥有共同的特征：</p><ol><li>基本都需要对按键等控件添加监听器触发</li><li>基本都要进行数据的更新操作<br>因为我们抽象出一个WorkingPanel作为每一个板面的抽象类。注意继承抽象类的类必须实现所有的抽象类中定义为abstract的方法。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public abstract class WorkingPanel extends JPanel&#123;</span><br><span class="line">    public abstract void updateData(); //添加数据更新方法</span><br><span class="line">    public abstract void addListener(); //添加监听器</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>在显示板面的时候，首先要更新板面数据。然后使用JPanel.updateUI()来进行板面更新。</p><p><strong>2. 控件监听器Listener</strong><br>空间监听器是实现了ActionListener接口的类。需要实现actionPerformed方法，表示当该监听器被触发的时候做的一系列操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class ConfigListener implements ActionListener&#123;</span><br><span class="line"></span><br><span class="line">    /* (non-Javadoc)</span><br><span class="line">     * @see java.awt.event.ActionListener#actionPerformed(java.awt.event.ActionEvent)</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void actionPerformed(ActionEvent e) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        ConfigPanel panel = ConfigPanel.instance; //调用ConfigPanel面板，读取相应的数据</span><br><span class="line">        if(!GUIUtil.checkNumber(panel.budgetTextField, &quot;本月预算&quot;))&#123;</span><br><span class="line">        return;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        String mysqlPath = panel.mysqlPathTextField.getText();</span><br><span class="line">        if(0 != mysqlPath.length())&#123;</span><br><span class="line">            File commandFile = new File(mysqlPath, &quot;bin/mysql&quot;);</span><br><span class="line">            if(!commandFile.exists())&#123;</span><br><span class="line">            JOptionPane.showMessageDialog(panel, &quot;Mysql路径不正确&quot;);</span><br><span class="line">            panel.mysqlPathTextField.grabFocus();</span><br><span class="line">            return;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    </span><br><span class="line">        //两个验证通过，连接Config服务</span><br><span class="line">        ConfigService cs = new ConfigService(); </span><br><span class="line">        cs.update(ConfigService.budget, panel.budgetTextField.getText()); //更新预算数字</span><br><span class="line">        cs.update(ConfigService.mysqlPath, panel.mysqlPathTextField.getText()); //更新数据库安装目录</span><br><span class="line">        cs.update(ConfigService.backupPath, panel.backupFilePathTextField.getText()); //更新备份目录</span><br><span class="line">        JOptionPane.showMessageDialog(panel, &quot;设置修改成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在板面的addListener方法中，通过如下方式添加监听器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protected void addListener() &#123;</span><br><span class="line">    // TODO Auto-generated method stub</span><br><span class="line">    ConfigListener listener = new ConfigListener();</span><br><span class="line">    updateButton.addActionListener(listener); //为updateButton控件添加事件监听器</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一般情况下，在监听器被触发的条件下，都会产生相对应的操作。这些操作都会定义在Service类中，并放在监听器的actionPerformed方法中执行。<br><strong>3. Service相应服务</strong><br>对于本例来说，相应的服务都是对数据库进行相关操作，也就是数据更新，数据查询等操作。这个时候就会用到之前所定义的DAO类进行数据库相关操作。</p><h3 id="Debug开发日志"><a href="#Debug开发日志" class="headerlink" title="Debug开发日志"></a>Debug开发日志</h3><h4 id="2019-07-16-第一版构建完成"><a href="#2019-07-16-第一版构建完成" class="headerlink" title="2019-07-16 第一版构建完成"></a>2019-07-16 第一版构建完成</h4><p><img src="/images/2019-07-16-Java项目_一本糊涂账_Debug开发日志/消费一览.png" alt="消费一览"><br><img src="/images/2019-07-16-Java项目_一本糊涂账_Debug开发日志/记一笔.png" alt="记一笔"><br><img src="/images/2019-07-16-Java项目_一本糊涂账_Debug开发日志/消费分类.png" alt="消费分类"><br><img src="/images/2019-07-16-Java项目_一本糊涂账_Debug开发日志/月消费报表.png" alt="月消费报表"><br><img src="/images/2019-07-16-Java项目_一本糊涂账_Debug开发日志/设置.png" alt="设置"><br><img src="/images/2019-07-16-Java项目_一本糊涂账_Debug开发日志/备份.png" alt="备份"><br><img src="/images/2019-07-16-Java项目_一本糊涂账_Debug开发日志/恢复.png" alt="恢复"></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL操作, Java JDBC</title>
      <link href="/2019/07/12/2019-07-12-Java_mysql/"/>
      <url>/2019/07/12/2019-07-12-Java_mysql/</url>
      
        <content type="html"><![CDATA[<p>最近编写一个“一本糊涂账”的Java项目，连接mysql数据库进行数据更新和相应的软件界面开发。<br>其中涉及到了很多MySQL的使用，在这里做一个记录</p><a id="more"></a> <!-- 摘要 --><h3 id="Java使用mysql的库-JDBC"><a href="#Java使用mysql的库-JDBC" class="headerlink" title="Java使用mysql的库 JDBC"></a>Java使用mysql的库 JDBC</h3><p>在Oracle主页下载，是免费的。<br>项目指导中提供的是 mysql-connector-java-5.0.8-bin.jar<br>但是在进行开发的过程中，出现了版本功能不一致的现象。<br>更新版本的jdbc库 mysql-connector-java-8.0.16.jar</p><ol><li><p>jdbc-8.0中的相关driver类com.mysql.cj.jdbc.Driver，但jdbc-5.0中的相关类是com.mysql.jdbc.Driver</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">程序代码：</span><br><span class="line">String url = String.format(&quot;jdbc:mysql://%s:%d/%s?characterEncoding=%s&quot;, ip, port, database, encoding);</span><br><span class="line">return DriverManager.getConnection(url,loginName,password);</span><br><span class="line"></span><br><span class="line">出现报错：</span><br><span class="line">com.mysql.jdbc.exceptions.MySQLNonTransientConnectionException: Client does not support authentication protocol requested by server; consider upgrading MySQL client</span><br><span class="line">这个表示我们安装的mysql版本与jdbc driver不匹配。所以要更新到jdbc-8.0。</span><br></pre></td></tr></table></figure></li><li><p>jdbc库<br> String sql；<br> (1) 执行sql命令：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try(Connection connection = DBUtil.getConnection(); </span><br><span class="line">    Statement s = connection.createStatement();)&#123;</span><br><span class="line">    </span><br><span class="line">    s.execute(); //执行命令</span><br><span class="line">    ResultSet rs = s.getGeneratedKeys(); //获得当前的rs</span><br><span class="line">    </span><br><span class="line">&#125; catch (Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> (2) 执行sql参数命令：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PreparedStatement ps = connection.preparedStatement(sql, Statement.RETURN_GENERATED_KEYS); //这里设置Statement.RETURN_GENERATED_KEYS</span><br><span class="line"></span><br><span class="line">ps.setString(1, value);</span><br><span class="line">ps.setString(2, value);</span><br><span class="line"></span><br><span class="line">ps.execute();</span><br><span class="line">ResultSet rs = ps.getGeneratedKeys();</span><br></pre></td></tr></table></figure><p> (3) 如何判断ResultSet是否返回数据集</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">判断rs.next()。如果rs.next()存在，则返回数据集结果存在。</span><br></pre></td></tr></table></figure><p> (4) 获取返回resultset的id</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">有两种方式，但是其中一种并不稳定</span><br><span class="line">首先设置实体类</span><br><span class="line">class table_name&#123;</span><br><span class="line">public int id;</span><br><span class="line">public String key;</span><br><span class="line">public String Value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(rs.next())&#123;</span><br><span class="line">    //下边两个获取id的方式否可以，1表示id是表内的第一行，这个需要与db中的一样。</span><br><span class="line">    //但“id”并不稳定，有时候会出现找不到column的报错，目前还没发现是为什么</span><br><span class="line">    int id = rs.getInt(1);</span><br><span class="line">    int id = rs.getInt(&quot;id&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>mysql命令</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">mysql &gt; 命令行 </span><br><span class="line"></span><br><span class="line">**添加数据库**</span><br><span class="line">create database_name</span><br><span class="line"></span><br><span class="line">**添加表**</span><br><span class="line">create table config(</span><br><span class="line">    id int auto_increment, # id列 int类型 auto_increment 设置自增加</span><br><span class="line">    key_ varchar(255),</span><br><span class="line">    value varchar(255),</span><br><span class="line">    primary key (id) # 设置id为主键</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8; #InnoDB表示数据库关闭后数据仍然保存</span><br><span class="line">create table record(</span><br><span class="line">    id int auto_increment,</span><br><span class="line">    spend int, #本次花费</span><br><span class="line">    cid int, #对应category中的分类,外键，指向category的主键</span><br><span class="line">    comment varchar(255), #备注</span><br><span class="line">    date Date, #本次记录发生的时间</span><br><span class="line">    primary key(id),</span><br><span class="line">    constraint fk_record_category foreign key (cid) references category(id) #设置外键约束</span><br><span class="line">)ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">**使用数据库**</span><br><span class="line">use database_name</span><br><span class="line"></span><br><span class="line">**添加命令 (null表示空出来的id)**</span><br><span class="line">insert into table_name value (null, value1, value2, ...)</span><br><span class="line">insert into table_name (field1, field2, ...) value (value1, value2, ...)</span><br><span class="line"></span><br><span class="line">**删除命令**</span><br><span class="line">delete from table_name where id = delete_id</span><br><span class="line"></span><br><span class="line">**更新命令**</span><br><span class="line">update config set key_=?, value=?, where id=?</span><br><span class="line"></span><br><span class="line">**查询命令**</span><br><span class="line">select * from config where id=?</span><br><span class="line">select * from config order by id desc limit ?,?</span><br><span class="line"># order by id desc 按照id降序来进行排序</span><br><span class="line"># limit ?,? 返回从?到?的记录</span><br><span class="line">select count(*) from config #返回记录总数</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> mysql </tag>
            
            <tag> jdbc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark RDD编程</title>
      <link href="/2019/07/11/2019-07-11-Spark_RDD_Programming/"/>
      <url>/2019/07/11/2019-07-11-Spark_RDD_Programming/</url>
      
        <content type="html"><![CDATA[<ol><li>RDD是什么</li><li>RDD常用操作</li></ol><a id="more"></a> <!-- 摘要 --><h3 id="1-RDD是什么"><a href="#1-RDD是什么" class="headerlink" title="1. RDD是什么"></a>1. RDD是什么</h3><p>RDD是Spark对数据的核心抽象（弹性分布式数据集 Resilient Distributed Dataset）。其实就是分布式的元素集合。在spark中，对数据的所有操作都基于RDD创建，RDD Transformation，RDD Action。在这个过程中，spark会自动将RDD中的数据分发到集群上，并将操作并行化执行。</p><p>RDD是一个不可变的分布式对象集合。每个RDD都被分为多个分区，这些分区运行在集群中的不同节点上。</p><p>每个spark程序或shell会话都会按照如下方式工作：<br>（1）从外部数据创建出输入RDD<br>（2）使用诸如filter()这样的转化操作对RDD进行转化，以定义新的RDD<br>（3）告诉spark对需要被重用的中间结果RDD执行persist()操作，或cache()<br>（4）使用行动操作来触发一次并行计算，spark会对计算进行优化后再执行。</p><h3 id="2-RDD操作"><a href="#2-RDD操作" class="headerlink" title="2. RDD操作"></a>2. RDD操作</h3><h4 id="1-创建RDD"><a href="#1-创建RDD" class="headerlink" title="1. 创建RDD"></a>1. 创建RDD</h4><p>spark提供了两种创建RDD的方式：读取外部数据结构；在驱动器程序中对一个集合进行并行化。</p><p>例子：把程序中一个已有的集合传给SparkContext的parallelize()方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lines = sc.parallelize([&quot;panadas&quot;, &quot;i like pandas&quot;])</span><br><span class="line">    </span><br><span class="line">JavaRDD&lt;String&gt; lines = sc.parallelize(Arrays.asList(&quot;panads&quot;, &quot;i like pandas&quot;));</span><br><span class="line">    </span><br><span class="line">从外部存储中创建RDD</span><br><span class="line">lines = sc.textFile(path);</span><br><span class="line">    </span><br><span class="line">JavaRDD&lt;String&gt; lines = sc.textFile(path);</span><br></pre></td></tr></table></figure></p><h4 id="2-RDD操作-1"><a href="#2-RDD操作-1" class="headerlink" title="2. RDD操作"></a>2. RDD操作</h4><ul><li><em>转化操作</em> ： 返回一个新的RDD操作，但并不触发实际的计算，比如map(), filter()，union()。转化操作可以操作任意数量的输入RDD。spark会用谱系图来记录这些不同RDD之间的依赖关系。</li><li><em>行动操作</em> ： 将最终求得的结果返回到驱动器程序，或者写入外部存储系统中。他会强制执行哪些求值过程中必须用到的RDD转化操作。</li></ul><h4 id="3-传递函数"><a href="#3-传递函数" class="headerlink" title="3. 传递函数"></a>3. 传递函数</h4><p>spark大部分转化操作和一部分行动操作，都需要依赖用户传递的函数来计算。<br><strong>Python</strong> ：<br>（1）传递lambda表达式：word = rdd.filter(lambda s: “error” in s)<br>（2）传递顶层函数或局部函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def containsError(s):</span><br><span class="line">    return &quot;error&quot; in s</span><br><span class="line">word = rdd.filter(containesError)</span><br></pre></td></tr></table></figure></p><p>传递函数的过程中，python可能会将函数所在的对象也序列化传出去。当你传递的对象是某个对象的成员，或者包含对某个对象中的一个字段的引用时，spark就会把整个对象发送到工作节点上。如果传递的类里包含python不知道如何序列化传输的对象，也会导致程序失败。<br>替代方案是记住，传输rdd的函数引用的应该都是 <em>局部变量</em> 。<br><strong><em>Java</em></strong> ：<br>函数需要实现spark的org.apache.spark.api.java.function包中的任意函数接口对象来传递。这时候需要maven来建立包依赖。<br>    标准Java函数接口：</p><div class="table-container"><table><thead><tr><th>函数名</th><th>实现的方法</th><th>用途</th></tr></thead><tbody><tr><td>Function<t, r></t,></td><td>R call(T)</td><td>接收一个输入值并返回一个输出值，类似于map()和filter()</td></tr><tr><td>Function<t1, t2, r></t1,></td><td>R call(T1, T2)</td><td>接收两个输入值并返回一个输出值，类似于aggregate()和fold()操作</td></tr><tr><td>FlatMapFunction<t, r></t,></td><td>Iterable<r> call(T)</r></td><td>接收一个输入值并返回任一个输出，用于类似flatMap()这样的操作</td></tr></tbody></table></div><p>可以把函数类内联定义为匿名内部类，也可以创建一个具名类。<br>在Java8中也可以使用lambda表达式进行基本函数传递。<br>RDD<string> errors = lines.filter(s -&gt; s.contains(“error”));</string></p><h4 id="4-常见的转化操作和行动操作"><a href="#4-常见的转化操作和行动操作" class="headerlink" title="4. 常见的转化操作和行动操作"></a>4. 常见的转化操作和行动操作</h4><p>Tips:<br>所有的传入函数function<t, k, v>之类的，放在前边的都是输入类型，放在后边的都是输出类型。</t,></p><p><em>基本RDD转化操作</em> ：<br><em>（1）针对各个元素的转化操作：map()和filter()。</em><br>   有时候我们希望每个输入元素生成多个输出元素，flatMap()。flatMap()函数分别应用到了输入RDD的每个元素上，不过返回的不是一个元素，而是一个返回值序列的迭代器。<br>   <strong>注意，我们使用的是spark-2.4,这里的call函数返回值已经改成了Iterator<r></r></strong>。原版本的Iterable<r>已经更改了。<br>   <img src="/images/2019-07-11-Spark_RDD/Spark-2.4-FlatMapFunctionAPI.png" alt="spark-api"></r></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Spark-2.4 API</span><br><span class="line">@FunctionalInterface</span><br><span class="line">public interface FlatMapFunction&lt;T, R&gt; extends Serializable &#123;</span><br><span class="line">Iterator&lt;R&gt; call(T t) throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//切分单词</span><br><span class="line">JavaRDD&lt;String&gt; words = input.flatMap(</span><br><span class="line">new FlatMapFunction&lt;String, String&gt;() &#123;</span><br><span class="line">public Iterator&lt;String&gt; call(String arg0) throws Exception &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">String[] splitStrings = arg0.split(&quot; &quot;);</span><br><span class="line">return Arrays.asList(splitStrings).iterator();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>Tips:<br>Java 中Iterable和Iterator的区别：<br>Iterable接口是java集合框架的顶级接口,实现此接口使集合对象可以通过迭代器遍历自身元素,我们可以看下它的成员方法：</p><ul><li>返回Iterator<t> 方法iterator() 返回一个内部元素为T的迭代器</t></li><li>返回void 方法forEach() 对内部元素进行遍历</li><li>返回Spliterator<t> 方法spliterator() 返回一个可分割迭代器</t></li></ul><p>我们常用的Collection， List， Set等都是Iterable的子类。可以通过.iterator()返回该类型的迭代器。<br>而Iterator接口就只是单向移动的迭代器，创建它的代价比较小。</p><p><em>（2）伪集合操作</em></p><p>尽管RDD本身不是严格意义上的集合，但它也支持许多数学上的集合操作，比如合并和相交操作。注意这些操作都要求操作的RDD是相同数据类型的。<br>RDD中最常确实的集合属性是元素的唯一性，因为常常有重复的元素。<br>RDD.distinct()转化操作来生成一个只包含不同元素的新RDD。不过distinct()操作的开销很大，需要将所有数据通过网络混洗。<br>RDD.intersection(other)转化操作来返回两个RDD中都有的元素。需要混洗<br>RDD.subtract(other)接收另一个RDD作为参数，返回一个由只存在第一个RDD中而不存在与第二个RDD中的所有元素组成的RDD。需要混洗<br>RDD.cartesian(other)计算两个RDD的笛卡尔积。返回一个矩阵。</p><p><em>基本RDD行动操作</em> ：</p><ul><li>reduce()操作，接收一个函数为参数，这个函数操作两个相同类型的RDD并返回一个同样类型的新元素。依然通过传入function来进行相应的reduce操作。</li><li>fold()和reduce()类似，接收一个与reduce()接收函数签名相同的函数，再加上一个初始值作为每个分区第一次调用的结果。</li></ul><p><img src="/images/2019-07-11-Spark_RDD/Spark-2.4_Function2.png" alt="spark-function2"><br><img src="/images/2019-07-11-Spark_RDD/Spark-2.4-PairFunction.png" alt="spark-pairfunction"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">wordcount reduce操作</span><br><span class="line">   </span><br><span class="line">//转换为键值对技术 action</span><br><span class="line">JavaPairRDD&lt;String, Integer&gt; counts = words.mapToPair(</span><br><span class="line">new PairFunction&lt;String, String, Integer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">public Tuple2&lt;String, Integer&gt; call(String t) throws Exception &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return new Tuple2&lt;String, Integer&gt;(t, 1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">).reduceByKey(</span><br><span class="line">new Function2&lt;Integer, Integer, Integer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">public Integer call(Integer v1, Integer v2) throws Exception &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return v1+v2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>aggregate() 累加器。 提供一个我们期待返回的类型的初始值，然后通过一个函数将RDD中的元素合并起来放入累加器。</li></ul><p>JavaRDD.aggregate(zeroValue, seqOp, combOp)聚合操作</p><ul><li><p>@param zeroValue the initial value for the accumulated result of each partition for the <code>seqOp</code> operator, and also the initial value for the combine results from different partitions for the <code>combOp</code> operator - this will typically be the neutral element (e.g. <code>Nil</code> for list concatenation or <code>0</code> for summation)</p><ul><li>@param seqOp an operator used to accumulate results within a partition</li><li>@param combOp an associative operator used to combine results from different partitions</li></ul><p>zeroValue就是初始值，之后的聚合操作都是在这个初始值上进行操作<br>seqOp先在分区上进行聚合操作<br>combOp将不同分区上的聚合结果进行总聚合</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class AvgCount implements Serializable&#123; //创建一个可序列化对象</span><br><span class="line">   public AvgCount(int total, int num)&#123;</span><br><span class="line">       this.total = total;</span><br><span class="line">       this.num = num;</span><br><span class="line">   &#125;</span><br><span class="line">   public int total;</span><br><span class="line">   public int num;</span><br><span class="line">   </span><br><span class="line">   public double avg()&#123; //计算平均值函数</span><br><span class="line">       return (double) total/num;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">Function2&lt;AvgCount, Integer, AvgCount&gt; addAndCount = </span><br><span class="line">   new Function2&lt;AvgCount, Integer, AvgCount&gt;()&#123;</span><br><span class="line">       public AvgCount call(AvgCount a, Integer x)&#123;</span><br><span class="line">           a.total += x;</span><br><span class="line">           a.num += 1;</span><br><span class="line">           return a; //注意传入的a是实时更改的。</span><br><span class="line">       &#125; </span><br><span class="line">   &#125;;</span><br><span class="line">   </span><br><span class="line">Function2&lt;AvgCount, AvgCount, AvgCount&gt; combine = </span><br><span class="line">   new Function2&lt;AvgCount, AvgCount, AvgCount&gt;()&#123;</span><br><span class="line">       public AvgCount call(AvgCount a, AvgCount b)&#123;</span><br><span class="line">           a.total += b.total;</span><br><span class="line">           a.num += b.num;</span><br><span class="line">           return a; //注意这相当于在实际的a中添加了b，而不是新生成了一个对象</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">    </span><br><span class="line">// aggregate 操作</span><br><span class="line">AvgCount initial = new AvgCount(0, 0); 初始值</span><br><span class="line">AvgCount result = rdd.aggregate(initial, addAndCount, combine);</span><br></pre></td></tr></table></figure><p><em>常见的对RDD的行动操作</em> ：</p><div class="table-container"><table><thead><tr><th>函数名</th><th>目的</th><th>示例scala</th></tr></thead><tbody><tr><td>collect()</td><td>返回RDD中的所有元素</td><td>rdd.collect()</td></tr><tr><td>count()</td><td>返回RDD中所有元素的个数</td><td>rdd.count()</td></tr><tr><td>countByValue()</td><td>各元素在RDD中出现的次数</td><td>rdd.countByValue()</td></tr><tr><td>take()</td><td>从RDD中返回num个元素</td><td>rdd.take(2)</td></tr><tr><td>top()</td><td>返回RDD中最前面的num个元素</td><td>rdd.top(2)</td></tr><tr><td>takeOrdered(num)(ordering)</td><td>返回RDD按提供的顺序返回最前面的num个元素</td><td>rdd.takeOrdered(2)(myordering)</td></tr><tr><td>reduce(func)</td><td>并行整合rdd所有的数据</td><td></td></tr><tr><td>fold(zero)(cunf)</td><td>和reduce()一样，但要提供初始值</td><td>rdd.fold(0)((x, y) =&gt; x+y)</td></tr><tr><td>aggregate(zeroValue)(seqOp, combOp)</td><td>和reduce()类似，但是通常返回不同的数据类型</td><td>rdd.aggregate((0,0))((x, y) =&gt; (x._1+y, x._2+1), (x, y) =&gt; (x._1 + y._1, x._2 + y._2))</td></tr><tr><td>foreach(func)</td><td>对RDD中的每个元素使用给定的函数</td><td>rdd.foreach(func)</td></tr></tbody></table></div><h4 id="5-在不同的RDD类型间转化"><a href="#5-在不同的RDD类型间转化" class="headerlink" title="5. 在不同的RDD类型间转化"></a>5. <strong>在不同的RDD类型间转化</strong></h4><p>有些函数只能用于特定类型的RDD，比如mean()和variance()只能用于数值RDD上，而join()只能用在键值对RDD上。在Scala或者Java中，这些函数都没有定义在标准的RDD类中，要访问这些附加功能，必须确保获得了正确的专用RDD类。</p><p>在Java中有两个专门的类JavaDoubleRDD和JavaPairRDD来处理特殊类型的RDD。</p><h4 id="6-RDD持久化-缓存"><a href="#6-RDD持久化-缓存" class="headerlink" title="6. RDD持久化(缓存)"></a>6. <strong>RDD持久化(缓存)</strong></h4><p>如果我们希望能多次使用同一个RDD，并且避免多次计算同一个RDD，可以让spark对数据进行持久化。当让spark持久化存储一个RDD时，计算出RDD的阶段会分别保存他们所求出的分区数据。如果一个有持久化数据的节点发生故障，spark会在需要用到缓存数据时重新计算丢失的数据分区。<br>默认情况下，persist()会把数据以序列化的形式缓存在JVM的堆空间中。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark环境搭建与RDD编程基础</title>
      <link href="/2019/07/10/2019-07-10-Spark%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8ERDD%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/07/10/2019-07-10-Spark%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8ERDD%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<ol><li>Spark环境搭建</li><li>Spark shell运行</li><li>Spark wordcount Java版</li></ol><a id="more"></a> <!-- 摘要 --><h3 id="1-Spark环境搭建"><a href="#1-Spark环境搭建" class="headerlink" title="1. Spark环境搭建"></a>1. Spark环境搭建</h3><p>spark仍然是一个解压安装包，将spark解压到固定路径，然后在环境变量中添加就可以了。</p><p>Spark带有交互式的shell可以用作即时数据分析。与其他操作系统的shell不同的是，spark的shell可以用来与分布式存储在许多机器的内存或者硬盘上的数据进行交互，并且处理过程的分发由spark自动控制完成。</p><p>注意要启动spark-shell的话，需要scala。直接brew install scala就可以了。命令：spark-shell</p><p>如果要启动python-shell的话，命令：pyspark</p><p><img src="/images/2019-07-10-Spark/spark-install-successful.png" alt="spark-install"></p><h3 id="2-Spark编程基础-shell"><a href="#2-Spark编程基础-shell" class="headerlink" title="2. Spark编程基础-shell"></a>2. Spark编程基础-shell</h3><p>我们在shell中采用python语言来进行spark测试</p><p><strong>环境</strong>：<br>Hadoop环境配置为单机模式，hadoop.tmp.dir设置为了一个文件夹。</p><p>打开pyspark后，进行行数统计：</p><p>注意这个文件TEST_SPARK.md是需要存在于hadoop.tmp.dir中的。但是这个时候我并没有启动hadoop，所以不知道是不是这么设置了之后就默认会从这个路径来读取了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; lines = sc.textFile(&quot;TEST_SPARK.md&quot;) #创建一个名为lines的RDD</span><br><span class="line">&gt;&gt;&gt; lines.count()</span><br><span class="line">&gt;&gt;&gt; 4</span><br><span class="line">&gt;&gt;&gt; lines.first()</span><br><span class="line">&gt;&gt;&gt; u&apos;# This is a spark test file&apos;</span><br></pre></td></tr></table></figure><p><strong>Spark程序核心概念</strong><br>从上层来看，每个spark应用都由一个驱动器程序driver program来发起集群上的各种并行操作。驱动器程序包含应用的main函数，并且定义了集群上的分布式数据集，还对这些分布式数据集应用了相关操作。在shell中，实际的驱动器程序就是spark shell本身。</p><p>驱动器程序通过一个SparkContext对象来访问Spark。这个对象代表对计算集群的一个连接。</p><p><strong>Spark API</strong><br>Spark可以在Java，python，scala的独立程序中被连接使用，接下来使用的API就一样了。<br>在java和scala中，是需要给应用添加一个对spark-core的maven依赖就可以了。对应于安装的spark-2.4.3来说，使用如下的依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/org.apache.spark/spark-core --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spark-core_2.12&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.4.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="3-Spark-wordcount-Java版程序"><a href="#3-Spark-wordcount-Java版程序" class="headerlink" title="3. Spark wordcount Java版程序"></a>3. Spark wordcount Java版程序</h3><p>（1）Spark java程序<br>自从Java8之后，java支持了’-&gt;‘ 这个简写语法，但是要在maven编译中添加限定。这个spark传递函数将会在后续进行学习。<br>按照《Spark快速大数据分析》中第二章的wordcount例程出现了Iterator和Iterable转换的不匹配。既然Java8支持了lambda简写，很明确，那就大势所趋还是使用lambda简写吧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line">package com.fredshao.spark;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">import org.apache.spark.SparkConf;</span><br><span class="line">import org.apache.spark.api.java.JavaPairRDD;</span><br><span class="line">import org.apache.spark.api.java.JavaRDD;</span><br><span class="line">import org.apache.spark.api.java.JavaSparkContext;</span><br><span class="line">import org.apache.spark.api.java.function.FlatMapFunction;</span><br><span class="line">import org.apache.spark.api.java.function.Function2;</span><br><span class="line">import org.apache.spark.api.java.function.PairFunction;</span><br><span class="line"></span><br><span class="line">import com.twitter.chill.java.ArraysAsListSerializer;</span><br><span class="line"></span><br><span class="line">import scala.Tuple12;</span><br><span class="line">import scala.Tuple2;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author shaoguoliang</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class MySparkTest01 &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        //创建java版spark context</span><br><span class="line">        SparkConf conf = new SparkConf().setAppName(&quot;sparktest01&quot;);</span><br><span class="line">        conf.setMaster(&quot;local&quot;);</span><br><span class="line">        JavaSparkContext sContext = new JavaSparkContext(conf);</span><br><span class="line">        //读取输入数据</span><br><span class="line">        JavaRDD&lt;String&gt; input = sContext.textFile(&quot;../data/Test_spark.txt&quot;);</span><br><span class="line">            </span><br><span class="line">        //切分为单词</span><br><span class="line">        JavaRDD&lt;String&gt; words = input.flatMap(</span><br><span class="line">        x -&gt; Arrays.asList(x.split(&quot; &quot;)).iterator()</span><br><span class="line">        );</span><br><span class="line">            </span><br><span class="line">        //转换为键值对技术</span><br><span class="line">        JavaPairRDD&lt;String, Integer&gt; counts = words.mapToPair(x -&gt; new Tuple2&lt;&gt;(x, 1))</span><br><span class="line">        .reduceByKey((x, y) -&gt; x + y);</span><br><span class="line">            </span><br><span class="line">        System.out.println(counts.collect());</span><br><span class="line">            </span><br><span class="line">        counts.saveAsTextFile(&quot;Test_spark_result.txt&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：<br>相关的文件读取I/O一定要注意，<br>路径名前缀为：<code>file://</code> 表示是从本地主机读取和写入文件<br>路径名前缀为：<code>hdfs://</code> 表示是从集群中读取和写入文件<br>上述代码中就没有写清楚从哪里读取textFile，也没有写清楚textFile写到哪里，注意一定是要全路径名。<br>正确的写法是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JavaRDD&lt;String&gt; input = sc.textFile(&quot;file:///Users/shaoguoliang/Workspaces/MyEclipse 2017 CI/spark-test-0.1/data/Test_spark.txt&quot;);</span><br><span class="line"></span><br><span class="line">和</span><br><span class="line"></span><br><span class="line">counts.saveAsTextFile(&quot;file:///Users/shaoguoliang/Workspaces/MyEclipse 2017 CI/spark-test-0.1/data/count_result.txt&quot;);</span><br></pre></td></tr></table></figure><p>（2） maven 依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">  &lt;groupId&gt;com.fredshao.spark&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spark-test-0.1&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;properties&gt;</span><br><span class="line">  &lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">  &lt;/properties&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;dependencies&gt;</span><br><span class="line">  &lt;!-- https://mvnrepository.com/artifact/org.apache.spark/spark-core --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spark-core_2.12&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.4.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--这个不是必备的--&gt;</span><br><span class="line">&lt;!--     &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;hadoop-client&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.9.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt; --&gt;</span><br><span class="line">  &lt;/dependencies&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;build&gt;</span><br><span class="line">    &lt;pluginManagement&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">       &lt;!--这个必须声明编译采用java1.8才可以使用lambda简写--&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.1&lt;/version&gt;</span><br><span class="line">    &lt;configuration&gt;</span><br><span class="line">    &lt;source&gt;$&#123;java.version&#125;&lt;/source&gt;</span><br><span class="line">    &lt;target&gt;$&#123;java.version&#125;&lt;/target&gt;</span><br><span class="line">    &lt;/configuration&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!--通过这个插件打包jar，指定main函数入口--&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;2.6&lt;/version&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;archive&gt;</span><br><span class="line">&lt;manifest&gt;</span><br><span class="line">&lt;addClasspath&gt;true&lt;/addClasspath&gt;</span><br><span class="line">&lt;classpathPrefix&gt;lib/&lt;/classpathPrefix&gt;</span><br><span class="line">&lt;mainClass&gt;com.fredshao.spark.MySparkTest01&lt;/mainClass&gt;</span><br><span class="line">&lt;/manifest&gt;</span><br><span class="line">&lt;/archive&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">    &lt;/pluginManagement&gt;</span><br><span class="line">  &lt;/build&gt;</span><br><span class="line">  </span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p>（3）mvn编译</p><p>在Eclipse中，点击项目名称-&gt;Run as-&gt; maven build…</p><p><img src="/images/2019-07-10-Spark/mvn_compile.png" alt="mvn_compile"></p><p>在mvn build 中的goal里添加想要执行的mvn操作<br>clean compile package</p><p><img src="/images/2019-07-10-Spark/mvn_proceed.png" alt="mvn_proceed"></p><p>之后看到building jar显示已经生成了jar就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[INFO] --- maven-jar-plugin:2.6:jar (default-jar) @ spark-test-0.1 ---</span><br><span class="line">[INFO] Building jar: /Users/shaoguoliang/Workspaces/MyEclipse 2017 CI/spark-test-0.1/target/spark-test-0.1-0.0.1-SNAPSHOT.jar</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time: 3.872 s</span><br><span class="line">[INFO] Finished at: 2019-07-10T13:17:30+08:00</span><br><span class="line">[INFO] Final Memory: 36M/336M</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>（4）spark 提交<br>因为我们已经将 $SPARK_HOME/bin添加进了 环境变量中，因为找到jar包所在目录，运行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spark-submit --master spark://localhost:7077 ./spark-test-0.1-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure><p>之后将会在target目录下生成 </p><p><img src="/images/2019-07-10-Spark/word_count_result.png" alt="word_count_result"></p><p>Test_spark_result.txt<br>将最终结果放在part-00000</p><p>注意，这里的输入文件路径和输出文件路径都是在jar包路径下的。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark是什么</title>
      <link href="/2019/07/09/2019-07-09-Spark%E6%98%AF%E4%BB%80%E4%B9%88/"/>
      <url>/2019/07/09/2019-07-09-Spark%E6%98%AF%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<ol><li>Hadoop 与 Spark 的对比</li><li>什么是Spark</li></ol><a id="more"></a> <!-- 摘要 --><p>部分摘自<a href="https://www.zhihu.com/question/26568496/answer/41608400" target="_blank" rel="noopener">https://www.zhihu.com/question/26568496/answer/41608400</a></p><h3 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h3><p>Hadoop解决了<strong>大数据（大到一台计算机无法进行存储，大到一台计算机无法在要求的时间内进行处理）的可靠存储和处理</strong>。</p><ul><li>HDFS通过在普通PC组成的集群上提供高可靠的文件存储，通过将块保存多个副本的方法解决服务器或硬盘坏掉的问题</li><li>MapReduce，通过简单的Mapper和Reducer的抽象提供一个变成模型，可以在一个非常多PC组成的不可靠集群上<strong>并发地</strong>，<strong>分布式地</strong>处理解决大量数据集，从而把并发、分布式（如机器间通信）和故障恢复等计算细节隐藏起来。Mapper和Reducer的抽象，是各种复杂数据处理都可以分解的基本元素。这样复杂的数据处理就可以分解为多个Job(一个Job只包含一个Mapper和一个Reducer)组成的有向无环图DAG。然后每个Mapper和Reducer放到Hadoop集群上执行，就可以得出结果。在Map和Reduce中间的过程中存在一个shuffle过程对Map得出的结果进行洗牌整理，排序，之后在将所有的输出数据合并成一个文件的过程。如果数据量大将会非常耗时。</li></ul><p><strong>Hadoop的局限于不足：</strong></p><ol><li>抽象层次低，需要手工编写代码来完成，使用上难以上手。</li><li>只提供两个操作，Map和Reducer，表达力欠缺。</li><li>一个Job只有Map和Reducer两个阶段，复杂的计算需要大量的Job完成，（通过中间变量来连接Job之间的关系），Job之间的依赖关系是由开发者自己管理的。</li><li>处理逻辑隐含在代码细节中，没有整体逻辑</li><li>中间结果也放在HDFS文件系统中（造成了大量数据复制，磁盘IO和序列化开销）</li><li><em>ReduceTask需要等待所有MapTask都完成后才可以开始</em></li><li>时延高，只适用于Batch数据处理，对于流式数据（交互式数据，实时数据）处理的支持不够</li><li>对于迭代式数据处理性能比较差</li></ol><p>在Hadoop推出后，出现了很多相关技术对其局限性进行改进，其中Spark就是一个。</p><h3 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h3><p>Apache Spark 是一个新兴的大数据处理引擎，主要特点是提供了一个集群的分布式内存抽象，以支持需要工作集的应用。</p><p><strong>注意</strong><br><em>Hadoop主要用于解决普通应尽存储和计算问题；而Spark用于构建大型的，低延迟的数据分析应用程序，不实现存储。</em></p><ol><li><p>RDD设计背景<br> 在实际应用中，存在许多迭代式计算，这些迭代计算的共同之处是，不同计算阶段之间会重用中间结果，即一个阶段的输出结果会作为下一阶段的输出。MapReduce将中间结果写入到HDFS中，造成了局限性。如果能将中间结果保存在内存中，就可以大量减少IO。RDD就是为满足这一需求而出现的，提供了一个抽象的数据架构，我们不必担心底层数据的分布式特性，只需将具体的应用逻辑表达为一系列转换处理，不同RDD之间的转换操作形成依赖关系，以实现管道化。</p></li><li><p>RDD概念<br> 一个RDD就是一个分布式对象集合。本质上是一个只读的（不可改变的）分区记录集合。每个RDD可以分成多个分区，每个分区就是一个数据集片段（HDFS上的块），并且一个RDD的不同分区可以被保存到集群中不同的节点上，从而可以在集群的不同节点上进行并行计算。<br> RDD提供了一种高度受限的 <em>共享内存模型</em> ，也就是RDD的不能直接修改，只能基于稳定的物理存储中的数据集来创建RDD，或者通过其他RDD上执行确定的转换操作（map，join和groupBy）来创建得到新的RDD。<br> RDD提供了一组抽象的数据运算（Transformations和Actions）。Transformation指定RDD之间的相互依赖关系，Actions用于执行计算并指定输出的形式。两个操作的主要区别是，Transformation（比如map，filter，groupBy，join等）接收RDD并返回RDD，而行动操作（比如count，collect等）接收RDD但是返回非RDD，输出一个值或一个结果。</p></li><li><p>RDD的典型执行过程：</p><ul><li>RDD读入外部数据源（或内存中的集合）进行创建</li><li>RDD经过一系列的Transformation进行处理，每一次都会产生不同的RDD供下一个Transformation使用</li><li><p>最后一个RDD经过Action操作进行处理，并输出到外部数据源。（或者变成Scala/Java集合或变量）</p><p>RDD采用了惰性调用，在RDD的执行过程中，真正的计算发生在RDD的Action操作，对于Transformation操作，Spark只是记录下Transformation操作莹莹的一些基础数据集以及RDD生成的轨迹（即相互依赖关系）而不会触发真正的计算。</p><p>这一系列处理称为“血缘关系”，即DAG拓扑排序的结果。采用惰性调用，通过学院关系连接起来的RDD操作就可以实现管道化，避免了多次转换操作之间数据同步的等待，而且不用担心有过多的中间数据。因为管道化，一个操作得到的结果不需要保存为中间数据，而是直接管道式流入下一个操作进行处理。也是的管道中每次操作的计算变得相对简单，保证了每个操作在逻辑上的单一性。</p></li></ul></li><li><p>RDD特性：<br> （1）高效的容错性。现有的分布式共享内存，键值存储，内存数据库等，为了实现容错，必须在集群节点之间进行数据复制或者记录日志，也就会在节点之间发生大量的数据传输。在RDD设计中，数据只读，不可修改，如果要修改数据，必须从父RDD转换到子RDD，因此在不同的RDD之间建立了血缘关系。所以RDD是一种天生具有容错机制的特殊集合，不需要通过数据冗余的方式（如checkpoint）来实现容错。只需要通过RDD学院关系计算得到丢失的分区来实现容错，无需回滚整个系统。并且RDD依赖关系只需要记录这种粗粒度的转换操作，而不需要记录具体的数据和各种细粒度操作的日志，大大降低了数据密集型应用中的容错开销。<br> （2）中间结果持久化到内存。数据在内存中的多个RDD操作之间进行传递，不需要落地到磁盘上，避免了不必要的读写开销<br> （3）存放的数据可以是Java对象，避免了不必要的对象序列化和反序列化开销。</p><p> tips：对象序列化是一个将对象状态转换为字节流的过程，可以将其保存在磁盘文件中，或通过网络发送到其他程序；从字节流创建对象的过程称为反序列化。创建的字节流是与平台无关的，在一个平台上序列化的对象可以在不同的平台上反序列化。</p></li><li><p>RDD之间的依赖关系<br> RDD中的不同操作会使得不同的RDD中分区产生不同的依赖。RDD中的依赖关系分为窄依赖（Narrow Dependency）和宽依赖(Wide Dependency)。<br> 窄依赖表现为一个父RDD的分区对应于一个子RDD的分区。或多个父RDD的分区对应于一个子RDD的分区。多到1映射。典型操作包括map，filter，union等。Join对输入进行协同划分为窄依赖。<br> 宽依赖表现为一个父RDD的一个分区，对应一个子RDD的多个分区。1到多映射。典型操作包括groupByKey，sortByKey。Join对输入进行非协同划分为宽依赖。</p><p> <img src="http://hainiubl.com/uploads/images/201709/29/1004/KYJ5yXCjYL.jpg" alt="RDD依赖关系"><br> (图片来源于海牛大数据)</p><p> tips: 这里的1和多都指的是RDD的一个分区。</p><p> 相对而言，窄依赖的失败恢复更为高效，它只需要根据父RDD分区重新计算丢失的分区即可，不需要计算所有分区，而且可以并行地在不同几点进行重新计算。（也就是，子RDD的某些分区丢失后，只需要找到部分父RDD分区就可以恢复）而宽依赖，单个节点失效通常意味着重新计算过程会涉及多个父RDD分区，开销比较大。此外，Spark还提供了数据检查点和记录日志，用于持久化中间RDD，从而使得在进行失败恢复是不需要追溯到最开始的阶段。在进行故障恢复时，spark会对数据检查点开销和重新计算RDD分区的开销进行比较，自动选择最优的恢复策略。</p></li><li><p>Spark阶段的划分<br> Spark通过分析各个RDD的依赖关系生成了DAG，再通过分析各个RDD中的分区之间的依赖关系来决定如何划分阶段。具体划分方法：<br> 在DAG中进行反向解析，遇到宽依赖就断开，遇到窄依赖就把当前RDD加入到当前的阶段；<br> 将窄依赖尽量划分在同一个阶段中，可以实现流水线计算。</p><p> <img src="http://hainiubl.com/uploads/images/201709/29/1004/ghe5SttFva.jpg" alt="Spark阶段划分"><br> （图片源于海牛大数据）</p><p> 如上图例子。<br> 从HDFS中读取分区A和C，经过一系列操作后得出结果，再写入HDFS中。<br> 在操作中A-&gt;B, 和F-&gt;G是宽依赖，所以断开。其余的是窄依赖，尽量将窄依赖归到一个pipeline上实现流水线作业。<br> 在分区7到分区9再到分区13这个过程中，可以不用等待分区8到分区10这个转换操作的计算结束，而是直接从分区9进行union操作到分区13，这样流水线执行大大提高了计算的效率。<br> 将一个DAG图划分成多个阶段以后，每个阶段都代表了一组关联的、 <em>相互之间没有shuffle依赖关系</em> 的任务组成的任务集合。每个任务集合会被提交给任务调度器（TsakScheduler）进行处理，由任务调度器将任务分发给Executor运行。</p><p> RDD在Spar框架中的运行过程：<br> （1）创建RDD对象；<br> （2）SparkContext负责计算RDD之间的依赖关系，构建DAG<br> （3）DAG Scheduler负责把DAG图分解成多个阶段，每个阶段包含了多个任务，每个任务会被任务调度器分发给各个工作节点上的Executor去执行。</p><p> 默认情况下，每个transformation RDD在执行action操作时都会重新计算。即使两个action操作会使用同一个转换RDD，该RDD也会重新计算。除非使用persist方法或者cache方法将RDD缓存到内存，这样下次使用这个RDD时将会提高计算效率，也支持将RDD持久化到硬盘上，或在多个节点上复制。</p></li></ol><h5 id="Spark-Transformation部分操作"><a href="#Spark-Transformation部分操作" class="headerlink" title="Spark Transformation部分操作"></a>Spark Transformation部分操作</h5><ul><li>map(func) 将原来RDD的每个数据项，使用map中用户自定义的函数func进行映射，转变为一个新的元素，并返回一个新的RDD</li><li>filter(func) 使用func对原RDD中数据项进行过滤，将符合func中条件的数据项组成新的RDD返回。</li><li>flatMap(func) 类似于map，但是输入数据项可以被映射到0个或多个输入数据集合中，所以func返回值是一个数据项集合而不是一个单一的数据项。</li><li>mapPartitions(func) 类似于map，但是该操作时在每个分区上分别执行，所以当操作一个类型为T的RDD是func的格式必须是Iterator=&gt;Iterator。即mapPartitions需要获取到每个分区的迭代器，在函数中通过这个分区的迭代器对整个分区的元素进行操作。</li><li>union(otherDataset) 返回数据结构和参数指定的数据集合并后的数据集。使用union函数是要保证两个RDD元素的数据类型相同。返回的RDD数据类型和被合并的RDD元素数据类型相同。该操作不进行去冲操作，返回的结果会保留所有元素。如果想去重，可以使用distinct()。</li><li>distinct([numTasks]) 将RDD中的元素进行去重操作。</li></ul><h3 id="Spark-Actions部分操作"><a href="#Spark-Actions部分操作" class="headerlink" title="Spark Actions部分操作"></a>Spark Actions部分操作</h3><ul><li>reduce(func) 使用func聚集数据集中的元素，这个函数func输入为两个元素，返回一个元素。这个函数符合结合律和交换律，这样才能保证数据集中各个元素计算的正确性。</li><li>collect() 在驱动程序中，以数组的形式返回数据集的所有元素。通常用于filter或其他产生了大量小数据集的情况。</li><li>count() 返回数据集中元素的个数。</li><li>first() 返回数据集中的第一个元素</li><li>saveAsTestFile(path) 将数据集中的元素以文本文件的形式保存到指定的本地文件系统、HDFS或其他Hadoop支持的文件系统中。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合框架</title>
      <link href="/2019/07/08/2019-07-08-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
      <url>/2019/07/08/2019-07-08-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<p>Java集合框架是围绕一组标准接口设计的。Java集合框架主要包括两种类型的容器，一个是集合Collection，用来存储元素集合；另一个是图Map，用来存储key-value映射。</p><a id="more"></a> <!-- 摘要 --><p><img src="https://www.runoob.com/wp-content/uploads/2014/01/2243690-9cd9c896e0d512ed.gif" alt="Java集合框架"></p><h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><p>Collection的接口有三种子类型，List、Set和Queue。<br>再下面是一些抽象类，最后是具体实现类，常用的有ArrayList，LinkedList，HashSet，LinkedHashSet，HashMap，LinkedHashMap。</p><h3 id="关系与区别"><a href="#关系与区别" class="headerlink" title="关系与区别"></a>关系与区别</h3><p><strong>1. <em>ArrayList与HashSet</em></strong></p><ul><li>ArrayList有顺序，HashSet无顺序。<br>HashSet的具体顺序既不是按照插入顺序，也不是按照hashcode的顺序。同样的HashSet在不同版本下的JVM里也是不一样的。</li><li>List的数据可以重复，Set的数据不能重复（HashSet其实就是实现了一个只有key的HashMap）<br>Set中数据重复的标准是：首先看hashcode是否相同，如果不同，则认为是不同数据；如果hashcode相同，再比较equals，如果equals相同则是相同数据，否则是不同数据。    </li></ul><p><strong><em>2. ArrayList和LinkedList的区别</em></strong></p><ul><li>ArrayList插入，删除数据慢（数据块存储，插入删除需要移动大面积数据）；LinkedList插入，删除数据块（指针连接下一个数据，插入删除只要链接下一个位置就可以）</li><li>ArrayList是顺序结构，定位很快；LinkedList是链表结构，定位慢。</li></ul><p><strong><em>3. HashMap与HashTable的区别</em></strong></p><ul><li>HashMap和HashTable都实现了Map接口</li><li>HashMap可以存放null（包括指针或值）；HashTable不能存放null（指针不能是null，值也不能是null）</li><li>HashMap不是线程安全的类；HashTable是线程安全的类</li></ul><p><strong><em>4. 几种Set：HashSet，LinkedHashSet，TreeSet (Set都是不重复的)</em></strong></p><ul><li>顺序性：HashSet无序；LinkedHashSet按照插入顺序；TreeSet从小到大排序</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程</title>
      <link href="/2019/07/06/2019-07-06-Java_Thread/"/>
      <url>/2019/07/06/2019-07-06-Java_Thread/</url>
      
        <content type="html"><![CDATA[<p>Java多线程相关知识。<br>Java给多线程变成提供了内置的支持。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。<br>多线程是多任务的一种特别的形式，但多线程使用了更小的资源开销。<br>进程：一个进程包括由操作系统分配的内存空间，包括一个或多个线程。一个线程不能独立存在，他必须是进程的一部分。一个进程一直运行，知道所有非守护线程都结束运行后才能结束。</p><a id="more"></a> <!-- 摘要 --><h3 id="一个线程的生命周期"><a href="#一个线程的生命周期" class="headerlink" title="一个线程的生命周期"></a>一个线程的生命周期</h3><p><img src="/images/2019-07-06-Java_Thread/Thread_lifecircle.jpg" alt="Thread_lifecircle"></p><ul><li>新建状态：创建线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序start()这个线程。</li><li>就绪状态：线程对象调用start()方法后，进入就绪状态，处于就绪队列中，等到JVM里的线程调度器的调度。</li><li>运行状态：就绪状态的线程获得CPU资源，就可以执行run()，处于运行状态。运行状态可以变为阻塞状态，就绪状态或死亡状态。</li><li>阻塞状态：线程执行sleep睡眠，suspend挂起等方法，失去所占用资源后，进入阻塞状态。在睡眠到时或获得设备资源后重新进入就绪状态。<ul><li><em>等待阻塞</em> ：执行wait()</li><li><em>同步阻塞</em> ：线程在获取synchronized同步锁失败（同步锁被其他线程占用）</li><li><em>其他阻塞</em> ：通过调用sleep()或join()发起了IO请求。</li></ul></li><li>死亡状态：运行状态的线程完成任务或其他终止条件发生时，就切换到终止状态。</li></ul><h3 id="Java线程的优先级"><a href="#Java线程的优先级" class="headerlink" title="Java线程的优先级"></a>Java线程的优先级</h3><p>每个线程都有优先级，有助于操作系统确定线程的调度顺序：<br>Java线程的优先级是一个整数 1(Thread.MIN_PRIORITY)~10(Thread.MAX_PRIORITY)<br>默认情况下，线程都会去分配一个NORM_PRIORITY(5)。<br>注意线程优先级并不能保证线程执行的顺序，而且非常依赖与平台。</p><h3 id="Java创建一个线程的三种方式"><a href="#Java创建一个线程的三种方式" class="headerlink" title="Java创建一个线程的三种方式"></a>Java创建一个线程的三种方式</h3><ul><li>继承线程类 Thread （可以使用匿名类）</li><li>实现Runnable接口，线程类只是实现了Runnable接口，还可以继承其他类。</li><li>通过Callable和Future创建线程</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">实现Runnable接口</span><br><span class="line"></span><br><span class="line">class RunnableDemo implements Runnable &#123;</span><br><span class="line">   private Thread t;</span><br><span class="line">   private String threadName;</span><br><span class="line">   </span><br><span class="line">   RunnableDemo( String name) &#123;</span><br><span class="line">      threadName = name;</span><br><span class="line">      System.out.println(&quot;Creating &quot; +  threadName );</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public void run() &#123;</span><br><span class="line">      System.out.println(&quot;Running &quot; +  threadName );</span><br><span class="line">      try &#123;</span><br><span class="line">         for(int i = 4; i &gt; 0; i--) &#123;</span><br><span class="line">            System.out.println(&quot;Thread: &quot; + threadName + &quot;, &quot; + i);</span><br><span class="line">            // 让线程睡眠一会</span><br><span class="line">            Thread.sleep(50);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;catch (InterruptedException e) &#123;</span><br><span class="line">         System.out.println(&quot;Thread &quot; +  threadName + &quot; interrupted.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(&quot;Thread &quot; +  threadName + &quot; exiting.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public void start () &#123;</span><br><span class="line">      System.out.println(&quot;Starting &quot; +  threadName );</span><br><span class="line">      if (t == null) &#123;</span><br><span class="line">         t = new Thread (this, threadName);</span><br><span class="line">         t.start ();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承Thread来创建线程。继承类比如重写run()方法，该方法是新县城的入口点，必须调用start()才能执行。本质上也是实现了Runnable接口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class ThreadDemo extends Thread &#123;</span><br><span class="line">   private Thread t;</span><br><span class="line">   private String threadName;</span><br><span class="line">   </span><br><span class="line">   ThreadDemo( String name) &#123;</span><br><span class="line">      threadName = name;</span><br><span class="line">      System.out.println(&quot;Creating &quot; +  threadName );</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public void run() &#123;</span><br><span class="line">      System.out.println(&quot;Running &quot; +  threadName );</span><br><span class="line">      try &#123;</span><br><span class="line">         for(int i = 4; i &gt; 0; i--) &#123;</span><br><span class="line">            System.out.println(&quot;Thread: &quot; + threadName + &quot;, &quot; + i);</span><br><span class="line">            // 让线程睡眠一会</span><br><span class="line">            Thread.sleep(50);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;catch (InterruptedException e) &#123;</span><br><span class="line">         System.out.println(&quot;Thread &quot; +  threadName + &quot; interrupted.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(&quot;Thread &quot; +  threadName + &quot; exiting.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public void start () &#123;</span><br><span class="line">      System.out.println(&quot;Starting &quot; +  threadName );</span><br><span class="line">      if (t == null) &#123;</span><br><span class="line">         t = new Thread (this, threadName);</span><br><span class="line">         t.start ();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Thread类的重要方法：</p><ul><li>public void start()</li><li>public void run() 如果该线程是使用独立的Runnable运行对象构造的，则调用该Runnable对象的方法；否则该方法不执行任何操作并返回。</li><li>public final void setName(String name)</li><li>public final void setPriority(int priority)</li><li>public final void setDaemon(boolean on) 将该线程标记为守护线程或用户线程 </li><li>public final void join(long millisec)</li><li>public void interrupt()</li><li>public final boolean isAlive()测试线程是否处于活动状态</li><li>public static void yield()暂停当前执行的线程对象，并执行其他线程</li><li>public static void sleep(long millisec)</li><li>public static boolean holdsLock(Object x) 当且仅当当前线程在指定的对象上保持监视器锁时，才返回true</li><li>public static Thread currentThread()</li><li>public static void dumpStack()将当前线程的堆栈跟踪打印</li></ul><p>加入线程join()。所有进程，至少会有一个线程为主线程，即main方法开始执行，就会有一个看不见的主线程存在。执行thread.join()就表明在主线程中加入该线程。主线程会等待该线程结束完毕才会往下运行。</p><h5 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h5><p>守护线程的概念是：当一个进程里，所有的线程都是守护线程的时候，结束当前进程。守护线程通常会被用来做日志，性能统计等工作。</p><h5 id="线程的同步-Concurrency"><a href="#线程的同步-Concurrency" class="headerlink" title="线程的同步 Concurrency"></a>线程的同步 Concurrency</h5><p>所线程的同步问题指的是多个线程同时修改一个数据的时候可能导致的问题。<br>解决思路是，在增加线程访问一个数据的时候，其他线程不可以访问该数据。<br>synchronized同步对象概念</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object someObject = new Object();</span><br><span class="line">synchronized(someObject)&#123;</span><br><span class="line">    //此处的代码只有占用了someObject后才能执行。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>synchronized表示当前线程，独占对象someObject。当前线程独占了对象，如果有其他线程试图占有对象someObject，就会等待，直到该线程释放对象占用。someObject又叫同步对象，所有的对象都可以作为同步对象。注意这个对象不一定是要被修改的那个对象，只要是一个对象，所有的线程都去试图访问的一个对象就可以。</p><p>当然对一个对象来说可以这么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">m1和m2达到的效果是一样的</span><br><span class="line">public class C&#123;</span><br><span class="line">    public synchronized void m1()&#123;&#125;</span><br><span class="line">    public void m2()&#123;</span><br><span class="line">        synchronized(this)&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个类，其方法都是有synchronized修饰的，那么该类就叫做线程安全的类。同一时间，只有一个线程能够进入 <em>这种类的一个实例</em> 去修改数据，从而保证了这个实例中的数据的安全。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">属于线程安全类的</span><br><span class="line">1. HashMap和Hashtable都实现了Map接口，都是key-value保存数据的方式。</span><br><span class="line">    区别1：HashMap可以存放null，Hashtable不能存放null</span><br><span class="line">    区别2：HashMap不是线程安全的类，Hashtable是线程安全类</span><br><span class="line">2. StringBuffer和StringBuilder。存在大量字符串拼接操作的时候，要保证字符串处理安全。</span><br><span class="line">    StringBuffer是线程安全的。</span><br><span class="line">    StringBuilder是非线程安全的。</span><br><span class="line">3. ArrayList和Vector</span><br><span class="line">    Vector是线程安全类。</span><br><span class="line">    ArrayList不是线程安全类。</span><br><span class="line">4. 把非线程安全的集合转换为线程安全</span><br><span class="line">    通过Collections工具类转换为线程安全的</span><br></pre></td></tr></table></figure><h3 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h3><ol><li>线程1首先占有对象1，接着试图占有对象2</li><li>线程2首先占有对象2，接着试图占有对象1</li><li>线程1等待线程2释放对象2，于此同时线程2等待线程1释放对象1</li></ol><h3 id="线程之间交互"><a href="#线程之间交互" class="headerlink" title="线程之间交互"></a>线程之间交互</h3><p>使用wait和notify进行线程交互<br>this.wait表示让占有this的线程等待，并临时释放占有。调用wait是有条件的，必须是在synchronized块里，否则会出错。<br>this.notify表示通知哪些等待在this的线程可以苏醒过来了。<br>this.notifyAll()的意思是，通知一个所有等待在这个同步对象上的线程可以苏醒了。</p><p>需要强调的是wait和notify并不是Thread线程上的方法，他们是Object上的方法。因为所有的Object都可以被同来作为同步对象。</p><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>每个线程的启动和结束都是比较消耗时间和占用资源的。如果在系统中用了很多线程，大量的启动和结束动作会导致系统性能变卡，相应变慢。为了解决这个问题，引入线程池这种思想。</p><ol><li>准备一个任务容器</li><li>一次性启动10个消费者线程</li><li>该开始任务容器是空的，所有的线程都wait</li><li>知道一个外部线程往这个任务容器中扔了一个任务，就会有一个消费者线程被notify唤醒</li><li>这个消费者线程取出任务，并执行这个任务，执行完毕后，继续等待下一次任务</li><li>如果短时间内，有较多的任务加入，那么就会有多个线程被唤醒，去执行这些任务。</li></ol><p>整个这个过程，都不需要创建新的线程，而是循环使用这些已经存在的线程</p><p>注意这个过程中的线程同步锁是这个任务容器。添加任务是向这个容器中添加任务，读取任务proceed也是从这个容器中提取。所以要保证该容器的读写唯一性。当容器为空时，所有的线程wait状态，等待任务容器存入一个任务后，唤醒所有线程notifyAll来proceed。</p><p>Java自建的线程池类ThreadPoolExecutor</p><h3 id="使用Lock对象实现同步效果"><a href="#使用Lock对象实现同步效果" class="headerlink" title="使用Lock对象实现同步效果"></a>使用Lock对象实现同步效果</h3><p>Lock是一个接口，为了使用一个Lock对象，需要用到</p><p>Lock lock = new ReentrantLock();</p><p>与Synchronized(someObject)类似，lock方法表示当前线程占用lock对象，一旦占用，其他线程就不能占用了。</p><p>与Synchronized(someObject)不同的是，一旦Synchronized块结束，就会自动释放对someObject的占用。lock必须调用unlock方法进行手动释放。为了保证释放的执行，往往会把unlock()放在finally中进行。</p><p>Synchronized是不占用到手不会停止，会一直试图占用下去。Lock接口提供了一个trylock方法，trylock会在指定时间范围内试图占用，占用可能成功，也可能失败。在后边unlock释放的时候需要判断是否占用成功了。如果没有占用成功就会报错。</p><p>使用Synchronized方式进行线程交互，用到的是<strong>同步对象</strong>的wait，notify和notifyAll的方法。Lock也提供了类似的解决办法，首先通过lock对象得到一个Condition对象，然后分别调用这个Condition对象的await，signal，signalAll方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = new ReentrantLock();</span><br><span class="line">Condition condition = lock.newCondition();</span><br></pre></td></tr></table></figure><p>区别：</p><ol><li>Lock是一个借口，而Synchronized是Java中的关键字，Synchronized是内置的语言实现，Lock是代码层面的实现。</li><li>Lock可以选择性的获取锁，如果一段时间获取不到可以放弃。Synchronized不行，会一直取下去。Lock的这个特性可以避免死锁，Synchronized必须通过谨慎良好的设计才能减少死锁的发生。</li><li>Synchronized在发生异常和同步快结束的时候会自动释放锁。而Lock必须手动释放。如果忘记释放一样会造成死锁。</li></ol><h3 id="原子性操作"><a href="#原子性操作" class="headerlink" title="原子性操作"></a>原子性操作</h3><p>原子性操作即为不可中断的操作，比如赋值操作 int i = 5;</p><p>原子性操作本身是线程安全的。但是对于i++这个行为，事实上是由3个原子性操作组成的，何在一起就不是线程安全的了。</p><p>JDK6之后，新增加了一个java.util.concurrent.atomic。里边包含了各种原子类。包含各种原子性操作，如自增，自减等方法。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java匿名类</title>
      <link href="/2019/07/05/2019-07-05-Java_anonymous_classes/"/>
      <url>/2019/07/05/2019-07-05-Java_anonymous_classes/</url>
      
        <content type="html"><![CDATA[<p>匿名内部类</p><ul><li>概念：即内部类的简化写法</li><li>前提：存在一个类（可以是具体类也可以是抽象类）或接口</li><li>格式：new 类名或接口名{重写的方法}</li><li>本质：创建的是继承了类或实现了接口的子类匿名对象。</li></ul><a id="more"></a> <!-- 摘要 --><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>匿名类是内部类，首先看一下什么是内部类。根据内部类的不同位置，可将内部类分为：</p><ul><li>成员内部类</li><li>局部内部类（位于外部类方法内）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class C&#123;</span><br><span class="line"></span><br><span class="line">    //成员内部类</span><br><span class="line">    class B&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    public void show&#123;</span><br><span class="line">        //局部内部类</span><br><span class="line">        class D&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>1. 成员内部类的访问格式：C.B b = new C().new B()</em></strong><br>实际开发中，常将内部类设为私有成员以保护数据安全。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class C&#123;</span><br><span class="line">   </span><br><span class="line">   private class B&#123;</span><br><span class="line">       public void methodB()&#123;&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public void method()&#123;</span><br><span class="line">       B b = new B();</span><br><span class="line">       b.methodB();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">通过</span><br><span class="line">C c = new C();</span><br><span class="line">C.method(); </span><br><span class="line">来访问内部类函数成员。</span><br></pre></td></tr></table></figure><p>或者，将内部类设置为静态类。 <em>静态内部类在访问外部类成员时，只能访问外部类的静态成员。</em><br><strong>private让数据更安全，static让数据访问更方便</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Outer&#123;</span><br><span class="line">   public int num = 10;</span><br><span class="line">   class Inner&#123;</span><br><span class="line">       public int num = 20;</span><br><span class="line">       public void show()&#123;</span><br><span class="line">           int num = 30;</span><br><span class="line">           System.out.println(num);//访问本方法的num=30</span><br><span class="line">           System.out.println(this.num);//访问Inner类的num=20</span><br><span class="line">           System.out.println(Outer.this.num); //添加外部类对象，访问外部类Outer的num=10</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong><em>2. 局部内部类</em></strong><br>可以直接访问外部类的成员。 <em>局部内部类访问的外部变量必须定义为final或static类型。</em> </p><p><strong>内部类和外部类其实是处于同一级别的，局部内部类不会因为方法的执行完毕而销毁。那么问题就来了：</strong></p><ul><li>如果外部类的方法中的变量不定义为final，当外部类方法执行完毕的时候，这个变量就被销毁了。 <em>然而内部类的某个方法还没有执行完，这个时候他所引用的外部变量已经找不到了。</em> 【在多线程工作时经常出现】如果定义为final，java会将这个变量复制一份作为成员变量内置于内部类中，这样的话final修饰的值始终无法改变，这个变量所指的内存区域就不会改变。</li></ul><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><ul><li>概念：即内部类的简化写法</li><li>前提：存在一个类（可以是具体类也可以是抽象类）或接口</li><li>格式：new 类名或接口名{重写的方法}</li><li>本质：创建的是继承了类或实现了接口的子类匿名对象。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">匿名类的声明是由java编译器自动派生一个类实例创建表达式。</span><br><span class="line">匿名类永远不能是抽象的。</span><br><span class="line">匿名类总是隐式的final。</span><br><span class="line">匿名类总是一个内部类，并且不能使static。</span><br><span class="line">在所有的情况下，匿名构造函数的throws语句必须列出所有的检查异常。包括父类构造函数显示调用语句跑出的和匿名类的实例初始化或者变量初始化抛出的异常。</span><br><span class="line">   </span><br><span class="line">实际使用的时候要注意：</span><br><span class="line">1. 使用匿名类时，我们必须是继承一个类或者实现一个接口。但二者不能兼得，同时也只能继承 _一个_ 类或实现 _一个_ 接口。</span><br><span class="line">2. 匿名类不能定义构造函数</span><br><span class="line">3. 匿名类中不能存在任何的静态成员变量或静态方法。</span><br><span class="line">4. 匿名类是局部内部类，所以局部内部类的所有限制对匿名类同样生效。</span><br><span class="line">5. 匿名类不能是抽象的，必须要实现继承类或接口的所有抽象方法。</span><br></pre></td></tr></table></figure><p>匿名类的语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Runnable hello = new Runnable()&#123; //1.new操作符; 2.接口名称 3. ()中构造函数的参数列表。</span><br><span class="line">    public void run()&#123; //4. 匿名类的结构</span><br><span class="line">        System.out.prinln(&quot;hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>访问权限：    </p><ul><li>外部class里的字段</li><li>不能访问外部类的本地变量，除非是final</li><li>如果内部类的名称与外部能访问的名称相同，就近原则。</li><li>不能定义静态初始化代码块</li><li>不能在匿名类里定义接口</li><li>不能再匿名类里定义构造函数</li></ul><p>匿名类方法的访问：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">方法1：直接在new 匿名类后边加.method()。这样访问如果方法多了调用很麻烦</span><br><span class="line"></span><br><span class="line">new D()&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void method()&#123;&#125;</span><br><span class="line">&#125;.method();</span><br><span class="line"></span><br><span class="line">方法2：通过创建对象来访问，多态思维</span><br><span class="line">D d = new D()&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void method()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">d.method();</span><br></pre></td></tr></table></figure><p>匿名类在开发中，一般是方法参数为接口的情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">interface D&#123;</span><br><span class="line">    void showD();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B&#123;</span><br><span class="line">    //参数为接口对象</span><br><span class="line">    public void show(D d)&#123;</span><br><span class="line">        d.showD();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class niming&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        B b = new B();</span><br><span class="line">        b.show(new D()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void showD()&#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyEclipse 添加 Hadoop Plugin</title>
      <link href="/2019/07/04/2019-07-04-hadoop-eclipse-plugin/"/>
      <url>/2019/07/04/2019-07-04-hadoop-eclipse-plugin/</url>
      
        <content type="html"><![CDATA[<p>使用MyEclipse IDE进行hadoop 开发的时候，需要导入hadoop-eclipse-plugin。本文记录了如何通过<a href="https://github.com/winghc/hadoop2x-eclipse-plugin" target="_blank" rel="noopener">https://github.com/winghc/hadoop2x-eclipse-plugin</a>进行该插件的生成。</p><a id="more"></a> <!-- 摘要 --><p>前提是安装ant，解压包，并把安装路径添加到~/.bash_profile即可。</p><ol><li>下载或clone <a href="https://github.com/winghc/hadoop2x-eclipse-plugin" target="_blank" rel="noopener">https://github.com/winghc/hadoop2x-eclipse-plugin</a>这个包到本地</li><li>找到你的hadoop安装地址和myeclipse的安装地址<br> 对mac来说：<br> myeclipse的安装地址是要能够找到一个plugin文件夹的地方。<br> /Applications/MyEclipse 2017 CI/MyEclipse 2017 CI.app/Contents/Profile  </li><li><p>根据readme中的提示在相应的目录下执行：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ant jar -Dversion=2.9.2 -Dhadoop.version=2.9.2 -Declipse.home=/Applications/MyEclipse\ 2017\ CI/MyEclipse\ 2017\ CI.app/Contents/Profile -Dhadoop.home=/usr/local/hadoop-2.9.2</span><br></pre></td></tr></table></figure></li><li><p>执行上述命令后会停在一个ivy common的地方一直不动。这个时候修改./eclipse-plugin/build.xml</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;target name=&quot;compile&quot; depends=&quot;init, ivy-retrieve-common&quot; unless=&quot;skip.contrib&quot;&gt;</span><br><span class="line">&lt;echo message=&quot;contrib: $&#123;name&#125;&quot;/&gt;</span><br><span class="line">&lt;javac</span><br><span class="line"> encoding=&quot;$&#123;build.encoding&#125;&quot;</span><br><span class="line"> srcdir=&quot;$&#123;src.dir&#125;&quot;</span><br><span class="line"> includes=&quot;**/*.java&quot;</span><br><span class="line"> destdir=&quot;$&#123;build.classes&#125;&quot;</span><br><span class="line"> debug=&quot;$&#123;javac.debug&#125;&quot;</span><br><span class="line"> deprecation=&quot;$&#123;javac.deprecation&#125;&quot;&gt;</span><br><span class="line"> &lt;classpath refid=&quot;classpath&quot;/&gt;</span><br><span class="line">&lt;/javac&gt;</span><br><span class="line">&lt;/target&gt;</span><br><span class="line"></span><br><span class="line">将该条改为</span><br><span class="line">&lt;target name=&quot;compile&quot; unless=&quot;skip.contrib&quot;&gt;</span><br></pre></td></tr></table></figure></li><li><p>继续运行上述命令。之后会得到一系列jar包找不到的报错，其实都是因为版本的问题。在google上搜索相应版本的jar包并添加进命令中hadoop的安装目录下/usr/local/hadoop-2.9.2/share/hadoop/common/lib</p></li></ol><p>直到编译完成生成hadoop-eclipse-plugin-2.9.2.jar.</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>这个方法只在MyEclipse下生成成功，但是在Eclipse下没有生成成功，问题应该是Eclipse中的plugins/下插件没有提供。MyEclipse和Eclipse的hadoop插件是通用的。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hadoop </tag>
            
            <tag> myeclipse </tag>
            
            <tag> plugin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VirtualBox NAT 端口映射实现宿主机与虚拟机相互通信</title>
      <link href="/2019/07/03/2019-07-03-VirtualBox-NAT-Configuration/"/>
      <url>/2019/07/03/2019-07-03-VirtualBox-NAT-Configuration/</url>
      
        <content type="html"><![CDATA[<p>在进行分布式开发的过程中需要配置主机和服务器的ssh服务。在学习的过程中只能通过配置虚拟机来进行。我用的电脑是Mac，使用了VirtualBox来配置虚拟机服务。</p><a id="more"></a> <!-- 摘要 --><h3 id="VirtualBox的5种连接方式"><a href="#VirtualBox的5种连接方式" class="headerlink" title="VirtualBox的5种连接方式"></a>VirtualBox的5种连接方式</h3><ul><li>NAT ：虚拟机可以通过宿主机访问主机能够访问的一切网络，宿主机不能访问虚拟机，虚拟机之间不能访问</li><li>NAT网络 ：在NAT的基础上，虚拟机之间搭建了局域网，可以实现虚拟机之间的相互访问</li><li>桥接 ：相当于虚拟机与宿主机连接在同一局域网内，相对于宿主机可见，可以看成是一台连接的宿主机</li><li>内部 ：虚拟机不能连外网</li><li>仅主机(host-only) ：虚拟机不能连外网，并且不互通</li></ul><p>在进行开发的最开始我选择了桥接模式，但桥接模式每一台虚拟机都会占用一个真实的ip地址，会造成ip地址极大的浪费。并且分布式一般需要设置固定ip，使用桥接模式经常会造成局域网内ip冲突。因此想到用NAT网络对建立的虚拟机网络进行隔离。</p><h3 id="NAT面对的需求"><a href="#NAT面对的需求" class="headerlink" title="NAT面对的需求"></a>NAT面对的需求</h3><ul><li>虚拟机可以连外网</li><li>虚拟机与主机互通</li><li>虚拟机与虚拟机互通</li><li>虚拟机需要固定IP (防止意外)</li><li>主机所在局域网的其他机器访问虚拟机</li></ul><h3 id="VirtualBox-NAT-Network的配置方法"><a href="#VirtualBox-NAT-Network的配置方法" class="headerlink" title="VirtualBox NAT Network的配置方法"></a>VirtualBox NAT Network的配置方法</h3><p><strong><em>1. VirtualBox全局设置</em></strong><br>在VirtualBox中添加一块网卡来实现NAT Network。<br>Preference=&gt;Network=&gt;右边的三个小图标中的Configure设置。如果Network中没有网卡的话添加一个。<br><img src="/images/2019-07-03-VirtualBox-NAT-Configuration/preference-network.png" alt="preference-network"><br><img src="/images/2019-07-03-VirtualBox-NAT-Configuration/preference-network-netcard.png" alt="preference-network"><br><strong><em>2. 虚拟机网络设置NAT Network</em></strong><br>注意首先关闭虚拟机，再进行虚拟机网络设置。<br>Network=&gt;attached to =&gt;NAT Network<br><img src="/images/2019-07-03-VirtualBox-NAT-Configuration/VM-network.png" alt="VM-network"><br><strong><em>3. 启动虚拟机，设置虚拟机网络配置</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ vim /etc/sysconfig/network-scripts/ifcfg-enp0s3 注意这里的enp0s3是网卡的名字，每台机器可能不一样，换成你自己的</span><br><span class="line">    </span><br><span class="line">将这个文件中的如下配置修改或添加成如下：</span><br><span class="line">BOOTPROTO=static</span><br><span class="line">ONBOOT=yes</span><br><span class="line">IPADDR=10.0.2.14</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line">GATEWAY=10.0.2.1</span><br><span class="line">DNS1=114.114.114.114</span><br><span class="line">DNS2=8.8.8.8</span><br><span class="line">    </span><br><span class="line">然后启动该网络设置</span><br><span class="line">$ systemctl restart network 或者</span><br><span class="line">$ service network restart</span><br></pre></td></tr></table></figure></p><p>上述配置中，因为在步骤1中的全局设置中，NAT局域网段设置为了10.0.2.0/24(也就是GATEWAY=10.0.2.1，NETMASK=255.255.255.0 24位子网掩码)，所以你设置的IPADDR必须是在这个网段内的地址。<br>此时ping一下<a href="www.baidu.com">www.baidu.com</a> 看是否实现了外网访问。使用ifconfig来查看当前本机ip地址是什么。这表示虚拟机可以访问外网。<br><img src="/images/2019-07-03-VirtualBox-NAT-Configuration/VM-network-configuration.png" alt="VM-network-configuration"><br><strong><em>4. 主机访问虚拟机，采用NAT端口映射</em></strong><br>虚拟机采用NAT网络配置，虚拟机的ip相对于宿主机是隐藏的。想要使得宿主机对虚拟机进行访问，需要配置端口映射，即通过将宿主机的一个端口(localhost:port)与虚拟机的ssh端口进行连接，宿主机通过访问宿主机端口(localhost:port)实现对虚拟机ssh端口(ip:22)的访问。<br>注意，这个端口是一一对应的。因为整个虚拟机子网10.0.2.0/24网段对主机是隐藏的，主机要想访问虚拟机子网中的任意一台虚拟机，就必须建立一个独立的宿主机端口与虚拟机的ssh端口进行连接。<br>配置NAT端口映射，如下：<br>在VirtualBox全局设置中，配置端口映射Port Forwarding (在步骤1中的NAT网卡设置)<br><img src="/images/2019-07-03-VirtualBox-NAT-Configuration/NAT-port-forwarding.png" alt="NAT-port-forwarding"><br>在宿主机中，ssh访问localhost:port (localhost地址为127.0.0.1)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh hadoop@127.0.0.1 -p 23333 或者</span><br><span class="line">ssh hadoop@localhost -p 23333</span><br></pre></td></tr></table></figure><p><img src="/images/2019-07-03-VirtualBox-NAT-Configuration/localhost-ssh-access.png" alt="localhost-ssh-access"><br>这样就实现了宿主机与虚拟机之间的访问<br><strong><em>5. 虚拟机与虚拟机之间的访问</em></strong></p><p>虚拟机之间使用ip地址就可以了，因为虚拟机之间由虚拟局域网连接。<br>参考<a href="/2019/06/21/2019-06-21-ssh_remote_access/" title="SSH 远程登录">SSH 远程登录</a><br><img src="/images/2019-07-03-VirtualBox-NAT-Configuration/batch-access.png" alt="batch-access"><br>至此，我们就完成了NAT Network下虚拟机配置的全部操作。<br>相比于桥接模式，极大的节省了ip资源，也减少了因为虚拟机存在导致对主机局域网的干扰。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VirtualMachine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Maven开发mapreduce，使用mapreduce 单元Test测试</title>
      <link href="/2019/07/03/2019-07-03-mvn-mapred-test/"/>
      <url>/2019/07/03/2019-07-03-mvn-mapred-test/</url>
      
        <content type="html"><![CDATA[<p>本文对应于《Hadoop权威指南》第6章Mapreduce应用开发的内容</p><p>通常情况下我们进行mapreduce开发要对每个模块进行单元测试，来检查模块的行为是否正确。本文主要介绍在mvn下进行mapreduce模块单元测试。</p><p>使用mvn开发mapreduce有两种方法，一个是源码编译（问题少，你必须知道你在干什么，本文采用的方法）；另外一个是借助IDE进行编译（集成度高，设置自动生成，写代码可以自动补全，比较爽）。在使用MyEclipse进行mapreduce开发的过程中，出现了hadoop插件导致的问题，因此，在完全解决hadoop插件的问题之前，我选择了如下方法：</p><ol><li>使用IDE进行代码编写。</li><li>上传到CentOS中，进行maven源码编译。</li><li>在这个过程中要尤其注意pom依赖。</li></ol><a id="more"></a> <!-- 摘要 --><h3 id="使用MRUnit写单元测试-v1"><a href="#使用MRUnit写单元测试-v1" class="headerlink" title="使用MRUnit写单元测试 - v1"></a>使用MRUnit写单元测试 - v1</h3><p>MRUnit是一个测试库，它便于将已知的输入传递给mapper或者检查reducer的输出是否符合预期。MRUnit与标准测试框架JUnit一起使用，可以在正常的开发环境中运行MapReduce作业测试。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">maven工程目录结构</span><br><span class="line"></span><br><span class="line">ch6-mr-dev/</span><br><span class="line">    |--pom.xml</span><br><span class="line">    |--src/</span><br><span class="line">        |--main/</span><br><span class="line">            |--java/v1/</span><br><span class="line">                |--Mapper.java</span><br><span class="line">        |--test/</span><br><span class="line">            |--java/v1/</span><br><span class="line">                |--MapperTest.java</span><br><span class="line">    |--target/</span><br><span class="line">        |--classes/</span><br><span class="line">        |--test-classes/</span><br></pre></td></tr></table></figure><p>在源文件下的main目录编写mapper模块和reducer模块。将相应的测试模块放在test目录下。注意package的目录等级。</p><h3 id="Mapper模块"><a href="#Mapper模块" class="headerlink" title="Mapper模块"></a>Mapper模块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package v1;</span><br><span class="line"></span><br><span class="line">import org.apache.hadoop.mapreduce.*;</span><br><span class="line">import org.apache.hadoop.io.*;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class MaxTempMapper extends Mapper&lt;LongWritable, Text, Text, IntWritable&gt;&#123;</span><br><span class="line"></span><br><span class="line">    @Override //加上标签表示对方法的重写，系统会自动检查重写方法是否正确</span><br><span class="line">    public void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException&#123;</span><br><span class="line">    String line = value.toString();</span><br><span class="line">    String year = line.substring(15, 19);</span><br><span class="line">    int airTemp = Integer.parseInt(line.substring(87, 92));</span><br><span class="line">    context.write(new Text(year), new IntWritable(airTemp));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MapperTest模块"><a href="#MapperTest模块" class="headerlink" title="MapperTest模块"></a>MapperTest模块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package v1;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">import org.apache.hadoop.mapreduce.*;</span><br><span class="line">import org.apache.hadoop.io.*;</span><br><span class="line">import org.apache.hadoop.mrunit.mapreduce.MapDriver;</span><br><span class="line"></span><br><span class="line">import org.junit.*;</span><br><span class="line"></span><br><span class="line">public class MaxTempMapperTest&#123;</span><br><span class="line">    @Test</span><br><span class="line">    public void processesValidRecord() throws IOException, InterruptedException&#123;</span><br><span class="line">    Text value = new Text(&quot;0043011990999991950051518004+68750+023550FM-12+0382&quot; +</span><br><span class="line">               // Year ^^^^</span><br><span class="line">    &quot;99999V0203201N00261220001CN9999999N9-00111+99999999999&quot;);</span><br><span class="line">                // Temperature ^^^^^</span><br><span class="line">    new MapDriver&lt;LongWritable, Text, Text, IntWritable&gt;()</span><br><span class="line">     .withMapper(new MaxTempMapper())</span><br><span class="line">     .withInput(new LongWritable(0), value)</span><br><span class="line">     .withOutput(new Text(&quot;1950&quot;), new IntWritable(-11))</span><br><span class="line">     .runTest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个测试很简单：内置传输一个天气记录作为mapper的输入，然后检查输出是否是读入的年份和气温。<br>测试的是mapper，可以使用MRUnit的MapDriver.调用runTest()方法。<br><strong><em>@Test</em></strong> 表示该方法可以不用通过main函数入口就可以执行得出运行结果，用于标准测试。注意被@Test修饰的方法必须是public。<br><strong><em>.withMapper</em></strong> 指向被测试的Mapper，注意该Mapper需要和MapperTest处在同一个package下，这样才能找到Mapper类。<br><strong><em>.withInput</em></strong> 指向输入的key和value。这里因为mapper的原始输入kay是文本的偏移值，所以没有意义，这个key可以随意设定。<br><strong><em>.withOutput</em></strong> 指向期望的输出。key(1950)和期望的输出值value(-11)。如果mapper没有输出期望值，则MRUnit测试失败。<br>根据withOutput()被调用的次数，MapDriver能用来检查0，1或多个输出记录。</p><h3 id="mvn编译"><a href="#mvn编译" class="headerlink" title="mvn编译"></a>mvn编译</h3><h4 id="1-pom-xml的导入"><a href="#1-pom-xml的导入" class="headerlink" title="1. pom.xml的导入:"></a>1. pom.xml的导入:</h4><p>在pom.xml中可以引入一个通用的pom基础，如下：<br>其中hadoop-meta中包含了很多包版本的定义等通用信息。同时添加了用于标准单元测试的junit。注意，在创建mvn project的时候默认的junit版本是3.8.2，而这个版本在导入<strong>org.junit.*这个包的时候会报错，这个包属于junit 4版本</strong>，所以要在pom.xml中修改junit版本。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">  &lt;groupId&gt;com.fredshao.hadoop&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;hadoop-meta&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">  &lt;relativePath&gt;../hadoop-meta/&lt;/relativePath&gt;</span><br><span class="line">&lt;/parent&gt;</span><br></pre></td></tr></table></figure></p><p>pom母版<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">hadoop-meta/pom.xml</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line"> &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line"> &lt;groupId&gt;com.hadoop-meta&lt;/groupId&gt;</span><br><span class="line"> &lt;artifactId&gt;hadoop-meta&lt;/artifactId&gt;</span><br><span class="line"> &lt;version&gt;1.0&lt;/version&gt;</span><br><span class="line"> &lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class="line">    </span><br><span class="line"> &lt;name&gt;hadoop-meta-configuration&lt;/name&gt;</span><br><span class="line"> &lt;url&gt;http://maven.apache.org&lt;/url&gt;</span><br><span class="line">    </span><br><span class="line"> &lt;properties&gt;</span><br><span class="line">   &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!-- Component versions are defined here --&gt;</span><br><span class="line">   &lt;hadoop.version&gt;2.9.2&lt;/hadoop.version&gt;</span><br><span class="line">   &lt;hbase.version&gt;1.3.5&lt;/hbase.version&gt;</span><br><span class="line">   &lt;hive.version&gt;0.13.1&lt;/hive.version&gt;</span><br><span class="line">   &lt;mrunit.version&gt;1.1.0&lt;/mrunit.version&gt;</span><br><span class="line">   &lt;spark.version&gt;1.1.0&lt;/spark.version&gt;</span><br><span class="line">   &lt;sqoop.version&gt;1.4.5&lt;/sqoop.version&gt;</span><br><span class="line"> &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">  &lt;dependencyManagement&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;4.11&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">  &lt;/dependencyManagement&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></p><h4 id="2-pom-xml需要加载的依赖包"><a href="#2-pom-xml需要加载的依赖包" class="headerlink" title="2. pom.xml需要加载的依赖包:"></a>2. pom.xml需要加载的依赖包:</h4><p>hadoop-client其实包含了hadoop-common依赖包，所以只用添加一个client就可以了。<br>mrunit要加上classifier表示是hadoop2版本下的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;hadoop-client&lt;/artifactId&gt;</span><br><span class="line"> &lt;/dependency&gt;</span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.mrunit&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;mrunit&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;$&#123;mrunit.version&#125;&lt;/version&gt;</span><br><span class="line">      &lt;classifier&gt;hadoop2&lt;/classifier&gt;</span><br><span class="line">      &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line"> &lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><h4 id="3-MyEclipse下mvn编译报错"><a href="#3-MyEclipse下mvn编译报错" class="headerlink" title="3. MyEclipse下mvn编译报错"></a>3. MyEclipse下mvn编译报错</h4><p>在MyEclipse下对上述工程进行编译会得到mvn编译报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Running v1.MaxTempMapperTest</span><br><span class="line">Tests run: 1, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 0.103 sec &lt;&lt;&lt; FAILURE!</span><br><span class="line">processesValidRecord(v1.MaxTempMapperTest)  Time elapsed: 0.032 sec  &lt;&lt;&lt; ERROR!</span><br><span class="line">java.lang.NoClassDefFoundError: com/ctc/wstx/io/InputBootstrapper</span><br></pre></td></tr></table></figure></p><p>这个错误并不是因为pom依赖出现问题，而是在MyEclipse下的hadoop插件出现了问题，导致依赖包导入不全。提供的解决帮助也把问题指向了hadoop-eclipse-plugin插件。这个遗留问题后期解决。TBC </p><h4 id="4-mvn命令行编译"><a href="#4-mvn命令行编译" class="headerlink" title="4. mvn命令行编译"></a>4. mvn命令行编译</h4><p>(1) 执行mvn test测试，测试出错：<br><img src="/images/2019-07-03-mvn-mapred-test/test_failure_mapper.png" alt="test_failure_mapper"><br>可以看到当我们把期待输出的温度调整为-16的时候，实际mapper得到的输出仍然为-11，这是测试出错，会报error。</p><h3 id="Reducer与ReducerTest模块"><a href="#Reducer与ReducerTest模块" class="headerlink" title="Reducer与ReducerTest模块"></a>Reducer与ReducerTest模块</h3><p>注意导入库的版本问题。<br>如:<br>org.apache.hadoop.mapred.Reducer 与 org.apache.hadoop.mapreduce.Reducer<br>org.apache.hadoop.mrunit.ReduceDriver 与 org.apache.hadoop.mrunit.mapreduce.ReduceDriver</p><p>不注意检查经常会导致编译出错。<br>Reducer程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> v1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxTempReducer</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>, <span class="title">IntWritable</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>&gt;</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text key, Iterable&lt;IntWritable&gt; values, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> maxVal = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span>(IntWritable value:values)&#123;</span><br><span class="line">    maxVal = Math.max(value.get(), maxVal);</span><br><span class="line">    &#125;</span><br><span class="line">    context.write(key, <span class="keyword">new</span> IntWritable(maxVal));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Reducer Test</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package v1;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">import org.apache.hadoop.io.IntWritable;</span><br><span class="line">import org.apache.hadoop.io.Text;</span><br><span class="line">import org.apache.hadoop.mrunit.mapreduce.ReduceDriver;</span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">public class MaxTempReducerTest &#123;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void returnsMaximumIntegerValues() throws IOException, InterruptedException&#123;</span><br><span class="line">    </span><br><span class="line">    new ReduceDriver&lt;Text, IntWritable, Text, IntWritable&gt;()</span><br><span class="line">    .withReducer(new MaxTempReducer())</span><br><span class="line">    .withInput(new Text(&quot;1950&quot;), Arrays.asList(new IntWritable(10), </span><br><span class="line">    new IntWritable(5)))</span><br><span class="line">    .withOutput(new Text(&quot;1950&quot;), new IntWritable(10))</span><br><span class="line">    .runTest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><p>我是实用rz工具将代码传入centos进行mvn编译的，rz有一个问题是，如果目标路径里已经有同名的文件了，他是不会完成传输的。所以经常发现已经提交了代码实际却没有更改的问题。</p><p>在使用Eclipse进行mvn test时，报了如下几个错误：</p><ul><li>java.lang.NoClassDefFoundError: com/ctc/wstx/io/InputBootstrapper</li><li>java.lang.NoClassDefFoundError: Could not initialize class org.apache.hadoop.io.Text</li></ul><p>完全不知道这个错误是为什么会出现的。在源码mvn构建就没有任何问题，所以应该是Eclipse配置的问题。如果你知道这两个报错如何解决请联系我guoliang_shao@u.nus.edu。不胜感激</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jekyll 模板撰写博客 相关设置</title>
      <link href="/2019/07/01/2019-07-01-jekyll_using/"/>
      <url>/2019/07/01/2019-07-01-jekyll_using/</url>
      
        <content type="html"><![CDATA[<p>博主是javascript盲，想要使用jekyll来进行文档管理和分享。这篇是记录在使用jekyll 建立Github博客的时候出现的问题。（后来博主弃用jekyll改用了hexo）</p><ol><li>正常markdown编译下表格在kramdown编译中的显示问题</li><li>对页面进行布局之后，markdown插入的图片超过了页面布局</li><li>markdown在于jekyll一起使用时支持content block横向滚动</li></ol><a id="more"></a> <!-- 摘要 --><h3 id="表格在kramdown中的显示问题"><a href="#表格在kramdown中的显示问题" class="headerlink" title="表格在kramdown中的显示问题"></a>表格在kramdown中的显示问题</h3><p>在本地markdown编译下的表格显示正常，但是在jekyll server本地编译和Github Pages下表格完全没有显示表格线。</p><p>解决办法：参考<a href="https://www.yfmingo.cn/2017/06/30/Jekyll-kramdown-tableline/" target="_blank" rel="noopener">https://www.yfmingo.cn/2017/06/30/Jekyll-kramdown-tableline/</a></p><p>在_include/下添加table.html来部署你的表格格式。（当然，表格格式不是固定的，而且上边连接的格式并不怎么好）。我采用的是如下模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># _include/table.html, 注意下边是所有的内容，一定要加上style。至于为什么，我作为一个javascript白痴我也不知道，这是我试出来的。</span><br><span class="line"># 大概是 border:2px控制线宽； #000000是rgb的颜色控制，采用十六进制。比如#ff0000就是红色</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">table&#123;</span><br><span class="line">    border-collapse: collapse;</span><br><span class="line">    border-spacing: 0;</span><br><span class="line">    border:2px solid #000000;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">th&#123;</span><br><span class="line">    border:2px solid #000000;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">td&#123;</span><br><span class="line">    border:1px solid #000000;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>然后找到你博客的显示页面，我的模板中是/_layouts/post.html。找到博文显示的部分，将上述style添加进去。之后进行编译就可以得到有表格线的表格了。<br><strong>注意：这个方法在你使用Hexo的时候同样适用。重要的是找到theme/layout/post这个文件</strong></p><p><img src="/images/2019-07-01-jekyll_using/content_template.png" alt="content_template"></p><p>当然，我的表格加上表格线之后还是有些丑，还存在表格中文字的缩进问题。我对javascript也一无所知，就暂且放在这。</p><h3 id="markdown中统一修改插入图片大小的设定"><a href="#markdown中统一修改插入图片大小的设定" class="headerlink" title="markdown中统一修改插入图片大小的设定"></a>markdown中统一修改插入图片大小的设定</h3><p>问题描述：博客页面中使用了分栏，也就是博文内容占整个页面70%的空间，但是在markdown中插入的图片却通常要占整个页面的宽度。</p><p>解决办法：<br>_include/下加入image_size.html文件来统一设定图片的大小。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># _include/image_size.html</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">img&#123;</span><br><span class="line">    width: 100%;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>像上述修改表格框线一样，将这个html头文件引用进content中。</p><h3 id="markdown在于jekyll一起使用时支持content-block横向滚动"><a href="#markdown在于jekyll一起使用时支持content-block横向滚动" class="headerlink" title="markdown在于jekyll一起使用时支持content block横向滚动"></a>markdown在于jekyll一起使用时支持content block横向滚动</h3><p>参考<a href="http://landcareweb.com/questions/27307/ru-he-zai-yu-jekyllyi-qi-shi-yong-pygmentsshi-zhi-chi-gun-dong" target="_blank" rel="noopener">如何在与Jekyll一起使用pygments时支持滚动</a></p><p>因为我采用的模板中含有css/bootstrap.min.css，因此采用了最简单的方案：<br>在该文件中添加如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// -- selector prefixed to the wrapper div for collision prevention</span><br><span class="line"></span><br><span class="line">.highlight pre code * &#123;</span><br><span class="line">  white-space: nowrap;    // this sets all children inside to nowrap</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.highlight pre &#123;</span><br><span class="line">  overflow-x: auto;       // this sets the scrolling in x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.highlight pre code &#123;</span><br><span class="line">  white-space: pre;       // forces &lt;code&gt; to respect &lt;pre&gt; formatting</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jekyll </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven 打包Jar 插件</title>
      <link href="/2019/07/01/2019-07-01-maven_plugin/"/>
      <url>/2019/07/01/2019-07-01-maven_plugin/</url>
      
        <content type="html"><![CDATA[<p>Maven可以使用mvn package指令对项目进行打包。Maven 提供的打包插件一共有三种，每种打包方式都有自己的应用场景。<br><a id="more"></a> <!-- 摘要 --></p><p>在Java中，如果使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar xxx.jar</span><br></pre></td></tr></table></figure><p>来执行运行jar文件经常会出现没有设置main-class，ClassNotFoundException(找不到依赖包)等错误。</p><p>要想jar包通过java -jar xxx.jar运行，必须满足：</p><ol><li>在jar包中的META-INF/MANIFEST.MF中指定Main-class，确定程序入口在哪里</li><li>将所有需要加载的依赖包通过-classpath导入 </li></ol><p>使用maven可以通过如下几个插件来生成能直接运行的jar包。</p><div class="table-container"><table><thead><tr><th>插件名</th><th>功能</th></tr></thead><tbody><tr><td>maven-jar-plugin</td><td>maven默认的打包插件，用来创建project jar</td></tr><tr><td>maven-shade-plugin</td><td>用来打可执行包，executable jar</td></tr><tr><td>maven-assembly-plugin</td><td>支持定制化打包方式，例如apache项目的打包方式</td></tr></tbody></table></div><p>参考<a href="https://blog.csdn.net/xiao__gui/article/details/47341385" target="_blank" rel="noopener">https://blog.csdn.net/xiao__gui/article/details/47341385</a></p><h3 id="方法一：使用maven-jar-plugin和maven-dependency-plugin插件"><a href="#方法一：使用maven-jar-plugin和maven-dependency-plugin插件" class="headerlink" title="方法一：使用maven-jar-plugin和maven-dependency-plugin插件"></a>方法一：使用maven-jar-plugin和maven-dependency-plugin插件</h3><p>在pom.xml文件中配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">&lt;plugins&gt;</span><br><span class="line"> </span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;2.6&lt;/version&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;archive&gt;</span><br><span class="line">&lt;manifest&gt;</span><br><span class="line">&lt;addClasspath&gt;true&lt;/addClasspath&gt;</span><br><span class="line">&lt;classpathPrefix&gt;lib/&lt;/classpathPrefix&gt;</span><br><span class="line">&lt;mainClass&gt;com.xxg.Main&lt;/mainClass&gt;</span><br><span class="line">&lt;/manifest&gt;</span><br><span class="line">&lt;/archive&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;2.10&lt;/version&gt;</span><br><span class="line">&lt;executions&gt;</span><br><span class="line">&lt;execution&gt;</span><br><span class="line">&lt;id&gt;copy-dependencies&lt;/id&gt;</span><br><span class="line">&lt;phase&gt;package&lt;/phase&gt;</span><br><span class="line">&lt;goals&gt;</span><br><span class="line">&lt;goal&gt;copy-dependencies&lt;/goal&gt;</span><br><span class="line">&lt;/goals&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;outputDirectory&gt;$&#123;project.build.directory&#125;/lib&lt;/outputDirectory&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line">&lt;/execution&gt;</span><br><span class="line">&lt;/executions&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br><span class="line"> </span><br><span class="line">&lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure><ul><li><p>首先要将所需要的依赖包包含进<dependency>这个tag。如果没有吧依赖包加进来那么一定会产生编译错误。</dependency></p></li><li><p>maven-jar-plugin用于生成META-INF/MANIFEST.MF文件的部分内容</p><p>  <mainclass>com.xxx.Main</mainclass> 指定了MANIFEST.MF中的Main-Class<br>  <addclasspath>true</addclasspath>会在MANIFEST.MF加上Class-Path项并配置依赖包，<br>  <classpathprefix>lib/<classpathprefix>指定依赖包所在的目录。</classpathprefix></classpathprefix></p></li><li><p>maven-dependency-plugin插件用于将依赖包拷贝到<outputdirectory>${project.build.directory}/lib</outputdirectory>指定的位置，即lib目录下。注意，如果不包含这个插件的话，mvn还是会先从中央仓库下载相关的依赖包，但是不会将依赖包表现在你的生成文件中，也就是你并不能实际的找到这个依赖包。这样某种程度影响不大。</p></li></ul><p>配置完成后，通过mvn package指令打包，会在target目录下生成jar包，并将依赖包拷贝到目录/target/lib/下。</p><h3 id="方法二：使用maven-assembly-plugin进行插件打包"><a href="#方法二：使用maven-assembly-plugin进行插件打包" class="headerlink" title="方法二：使用maven-assembly-plugin进行插件打包"></a>方法二：使用maven-assembly-plugin进行插件打包</h3><p>在pom.xml中配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">     </span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.5.5&lt;/version&gt;</span><br><span class="line">    &lt;configuration&gt;</span><br><span class="line">    &lt;archive&gt;</span><br><span class="line">    &lt;manifest&gt;</span><br><span class="line">    &lt;mainClass&gt;com.xxg.Main&lt;/mainClass&gt;</span><br><span class="line">    &lt;/manifest&gt;</span><br><span class="line">    &lt;/archive&gt;</span><br><span class="line">    &lt;descriptorRefs&gt;</span><br><span class="line">    &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;</span><br><span class="line">    &lt;/descriptorRefs&gt;</span><br><span class="line">    &lt;/configuration&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure><p>打包方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn package assembly:single</span><br></pre></td></tr></table></figure><p>打包后会在target目录下生成一个xxx-jar-with-dependencies.jar文件，这个文件不但包含自己项目下的所有代码和资源，而且包含了所有依赖包的内容。可以复制到任何地方直接通过java -jar 来运行。</p><p>当然也可以通过 mvn package来打包，无需assembly:single，而且需要加上一些额外配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">     </span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.5.5&lt;/version&gt;</span><br><span class="line">    &lt;configuration&gt;</span><br><span class="line">    &lt;archive&gt;</span><br><span class="line">    &lt;manifest&gt;</span><br><span class="line">    &lt;mainClass&gt;com.xxg.Main&lt;/mainClass&gt;</span><br><span class="line">    &lt;/manifest&gt;</span><br><span class="line">    &lt;/archive&gt;</span><br><span class="line">    &lt;descriptorRefs&gt;</span><br><span class="line">    &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;</span><br><span class="line">    &lt;/descriptorRefs&gt;</span><br><span class="line">    &lt;/configuration&gt;</span><br><span class="line">    &lt;executions&gt;</span><br><span class="line">    &lt;execution&gt;</span><br><span class="line">    &lt;id&gt;make-assembly&lt;/id&gt;</span><br><span class="line">    &lt;phase&gt;package&lt;/phase&gt;</span><br><span class="line">    &lt;goals&gt;</span><br><span class="line">    &lt;goal&gt;single&lt;/goal&gt;</span><br><span class="line">    &lt;/goals&gt;</span><br><span class="line">    &lt;/execution&gt;</span><br><span class="line">    &lt;/executions&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">     </span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure><p>其中<phase>package</phase>, <goal>single</goal>表示在执行package命令的时候执行assembly:single。</p><p>不过，如果项目中用到Spring Framework，用这种方式打出来的包运行时会出错。可以使用下边的方法三进行处理。</p><h3 id="方法三：使用maven-shade-plugin进行打包"><a href="#方法三：使用maven-shade-plugin进行打包" class="headerlink" title="方法三：使用maven-shade-plugin进行打包"></a>方法三：使用maven-shade-plugin进行打包</h3><p>在pom.xml中配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">     </span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.4.1&lt;/version&gt;</span><br><span class="line">    &lt;executions&gt;</span><br><span class="line">    &lt;execution&gt;</span><br><span class="line">    &lt;phase&gt;package&lt;/phase&gt;</span><br><span class="line">    &lt;goals&gt;</span><br><span class="line">    &lt;goal&gt;shade&lt;/goal&gt;</span><br><span class="line">    &lt;/goals&gt;</span><br><span class="line">    &lt;configuration&gt;</span><br><span class="line">    &lt;transformers&gt;</span><br><span class="line">    &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;&gt;</span><br><span class="line">    &lt;mainClass&gt;com.xxg.Main&lt;/mainClass&gt;</span><br><span class="line">    &lt;/transformer&gt;</span><br><span class="line">    &lt;/transformers&gt;</span><br><span class="line">    &lt;/configuration&gt;</span><br><span class="line">    &lt;/execution&gt;</span><br><span class="line">    &lt;/executions&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">     </span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure><p>配置完成后，执行mvn package进行打包。在target目录下会生成两个jar包。和maven-assembly-plugin一样，生成的jar文件包含了所有的依赖，可以直接运行。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划 Dynamic Program算法</title>
      <link href="/2019/06/28/2019-06-28-DynamicProgram/"/>
      <url>/2019/06/28/2019-06-28-DynamicProgram/</url>
      
        <content type="html"><![CDATA[<p>动态规划英文 Dynamic Programming，是求解决策过程最优化的数学方法，后来沿用到了编程领域。</p><p>动态规划的大致思路是把一个复杂的问题转化成一个分阶段逐步递推的过程，从简单的初始状态一步一步递推，最终得到复杂问题的最优解。</p><p>动态规划解决问题的过程分为两步：</p><ul><li>寻找状态转移方程</li><li>利用状态转移方程式自底向上求解问题</li></ul><a id="more"></a> <!-- 摘要 --><h3 id="5-Longest-Palindromic-Substring"><a href="#5-Longest-Palindromic-Substring" class="headerlink" title="#5. Longest Palindromic Substring"></a>#5. Longest Palindromic Substring</h3><p>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.</p><p>Example 1:<br>Input: “babad”<br>Output: “bab”<br>Note: “aba” is also a valid answer.</p><p>Example 2:<br>Input: “cbbd”<br>Output: “bb”</p><p>思路：<br>首先，如果一个子串 s(i, j)是一个回文，那么s[i-1]==s[j+1]的时候，我们可以推断s(i-1, j+1)也是一个回文。基于这个动态转移，我们可以推断用DP。</p><p>找到初始状态：<br>首先，一个字符一定是回文。<br>其次，两个相同的字符一定是回文。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> s;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n, <span class="built_in">vector</span>&lt;n, <span class="number">0</span>&gt;); <span class="comment">//建立dp二维表格</span></span><br><span class="line">        <span class="keyword">int</span> maxl = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>; <span class="comment">//注意start和maxl必须同时进行更新</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//初始状态1：</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">            start = i;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始状态2：</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)&#123;</span><br><span class="line">            dp[i][i+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            maxl = <span class="number">2</span>; </span><br><span class="line">            start = i;   </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//状态转移</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">3</span>; k&lt;=n; k++)&#123; <span class="comment">//遍历长度 maxl</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n-k+<span class="number">1</span>; i++)&#123; <span class="comment">//遍历start</span></span><br><span class="line">                <span class="keyword">int</span> j = i+k<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">if</span>(dp[i+<span class="number">1</span>][j<span class="number">-1</span>] == <span class="number">1</span> &amp;&amp; s[i] == s[j]) &#123;</span><br><span class="line">                    dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(k &gt; maxl)&#123;</span><br><span class="line">                        maxl = k;</span><br><span class="line">                        start = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> s.substr(start, maxl);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="10-Regular-Expression-Matching-正则表达式"><a href="#10-Regular-Expression-Matching-正则表达式" class="headerlink" title="#10. Regular Expression Matching 正则表达式"></a>#10. Regular Expression Matching 正则表达式</h3><p>Given an input string (s) and a pattern (p), implement regular expression matching with support for ‘.’ and ‘*’.</p><p>‘.’ Matches any single character.<br>‘*’ Matches zero or more of the preceding element.<br>The matching should cover the entire input string (not partial).</p><p>Note:</p><p>s could be empty and contains only lowercase letters a-z.<br>p could be empty and contains only lowercase letters a-z, and characters like . or *.</p><p>思路：<br>首先想是否存在状态方程，显然是存在的。两个指针s[i]和p[j]。假设当前s(0~i-1)与p(0~j-1)符合正则表达式要求，那么我们只需要判断s[i]和p[j]的这个状态就好了。</p><p>那么我们来看pattern的两个字符。</p><ul><li>‘.’单个占位，表示任何字符。</li><li>‘<em>‘不占位，表示前一个字符的复制情况。分两种情况：（1）忽略前一个字符；此时你比较的是s[i]和p[j-2]（2）复制前一个字符任意次，但至少1次，那么你首先要保证 \</em> 前边的这个字符已经存在了，也就是验证s[i-1]和p[j]是正则的。之后再去验证s[i]是否正则。</li></ul><p>一定要记住*不占位，他只代表重复次数。</p><p>代码：</p><pre><code class="lang-c++">class Solution {public:    bool isMatch(string s, string p) {        int sn = s.size();        int pn = p.size();        //注意这里使用了多添加一个位置，来处理空字符串的情况。        vector&lt;vector&lt;bool&gt;&gt; dp = vector(sn+1, vector&lt;bool&gt;(pn+1, false));        //初始状态，两个字符串都是空的，那么肯定是正则的        dp[0][0] = true;        for(int i = 0; i&lt;sn+1; i++){            for(int j = 1; j&lt;pn+1; j++){                if(p[j-1] == &#39;*&#39;){                //遇到&#39;*&#39;                //(1)保证&#39;*&#39;前边的字符存在，先要验证dp[i-1][j];然后再验证s[i]是否是*前边的字符。                //(2)&#39;*&#39;前边的字符不存在，那么退化                    dp[i][j] = i &amp;&amp; dp[i-1][j] &amp;&amp; (s[i-1]==p[j-2] || p[j-2] == &#39;.&#39;) || dp[i][j-2];                               } else{                //正常情况，正常处理。                    dp[i][j] = i &amp;&amp; dp[i-1][j-1] &amp;&amp; (s[i-1]==p[j-1] || p[j-1] == &#39;.&#39;);                }            }        }        return dp[sn][pn];    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop IO接口</title>
      <link href="/2019/06/28/2019-06-28-Hadoop-IO/"/>
      <url>/2019/06/28/2019-06-28-Hadoop-IO/</url>
      
        <content type="html"><![CDATA[<p>Hadoop IO接口相关操作包括：文件压缩，序列化</p><a id="more"></a> <!-- 摘要 --><h3 id="文件压缩"><a href="#文件压缩" class="headerlink" title="文件压缩"></a>文件压缩</h3><p>文件压缩有两大好处：减少存储文件所需要的磁盘空间，加速数据在网络和磁盘上的传输。这两大好处在处理大量数据时相当重要。<br>与Hadoop结合使用的常见压缩方法：</p><div class="table-container"><table><thead><tr><th>压缩格式</th><th>工具</th><th>算法</th><th>文件扩展名</th><th>是否可切分</th></tr></thead><tbody><tr><td>DEFLATE</td><td>无</td><td>DEFLATE</td><td>.deflate</td><td>否</td></tr><tr><td>gzip</td><td>gzip</td><td>DEFLATE</td><td>.gz</td><td>否</td></tr><tr><td>bzip2</td><td>bzip2</td><td>bzip2</td><td>.bz2</td><td>是</td></tr><tr><td>LZO</td><td>lzop</td><td>LZO</td><td>.lzo</td><td>否</td></tr><tr><td>LZ4</td><td>无</td><td>LZ4</td><td>.lz4</td><td>否</td></tr><tr><td>Snappy</td><td>无</td><td>Snappy</td><td>.snappy</td><td>否</td></tr></tbody></table></div><p>所有的压缩算法都需要权衡<em>空间/时间</em>。压缩和解压缩的速度更快，其代价通常是只能节省少量的空间。上表中的工具提供9个不同的选项来控制空间/时间权衡：选项-1为优化压缩速度，-9为优化压缩空间。</p><p>不同的压缩工具有不同的压缩特性。其中，<strong>是否可切分</strong>对应压缩算法是否可以搜索数据流的任意位置并进一步向下读取数据。可切分压缩格式尤其适合MapReduce。</p><h3 id="codec-压缩-解压算法的一种实现。"><a href="#codec-压缩-解压算法的一种实现。" class="headerlink" title="codec 压缩-解压算法的一种实现。"></a>codec 压缩-解压算法的一种实现。</h3><p>在Hadoop中，一个对CompressionCodec接口的实现代表一个codec。<br><img src="/images/2019-06-28-Hadoop-IO/hadoop_codec.png" alt="hadoop_codec"></p><p><strong><em>1. 通过CompressionCodec对数据流进行压缩和解压缩。</em></strong></p><ul><li>对写入输出数据流的数据进行压缩createOutputStream(OutputStream out)，获得CompressionOutputStream对象。</li><li>对输入数据流读取的数据进行解压缩，调用createInputStream(InputStream in)，获得CompressionInputStream对象。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Example: 压缩从标准输入读取的数据，然后将其写到标准输出</span><br><span class="line">    </span><br><span class="line">package com.fredshao.hadoop;</span><br><span class="line">    </span><br><span class="line">//import org.apache.hadoop.io.compress.DefaultCodec;</span><br><span class="line">//import org.apache.hadoop.io.compress.GzipCodec;</span><br><span class="line">import org.apache.hadoop.util.ReflectionUtils;</span><br><span class="line">import org.apache.hadoop.conf.Configuration;</span><br><span class="line">import org.apache.hadoop.io.IOUtils;</span><br><span class="line">//import org.apache.hadoop.io.compress.BZip2Codec;</span><br><span class="line">import org.apache.hadoop.io.compress.CompressionCodec;</span><br><span class="line">import org.apache.hadoop.io.compress.CompressionOutputStream;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">public class StreamCompressor &#123;</span><br><span class="line">    </span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">String codecClassname = args[0];</span><br><span class="line">Class&lt;?&gt; codecClass = Class.forName(codecClassname);</span><br><span class="line">Configuration conf = new Configuration();</span><br><span class="line">CompressionCodec codec = (CompressionCodec) ReflectionUtils.newInstance(codecClass, conf);</span><br><span class="line"></span><br><span class="line">CompressionOutputStream out = codec.createOutputStream(System.out);</span><br><span class="line">IOUtils.copyBytes(System.in, out, 4096, false);</span><br><span class="line">out.finish();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>完全合格名称为第一个命令行参数。</li><li>使用ReflectionUtils新建一个codec实例，获得一个在System.out上支持压缩的压缩方法。</li><li>对IOUtils类调用copyBytes方法（这是一个静态方法）将输入数据流复制到输出压缩对象。</li><li>对CompressionOutputStream对象调用finish()方法，要求压缩方法完成到压缩数据流的写操作，但不关闭数据流。</li></ul><p><img src="/images/2019-06-28-Hadoop-IO/hadoop_codec.png" alt="compression_result"></p><p><strong><em>2. 通过CompressionCodecFactory推断CompressionCodec</em></strong></p><p>在读取一个压缩文件时，通常可以通过文件扩展名推断需要使用哪个codec。通过getCodec()方法，CompressionCodecFactory提供了一种可以将文件扩展名映射到一个CompressionCodec的方法。该方法取文件的Path对象作为参数。<br>可以通过调用静态方法CompressionCodecFactory.removeSuffix来直接生成当前目录下输出文件名。</p><p><strong><em>3. CodecPool。如果使用原生代码库并需要在应用中执行大量的压缩和解压缩操作，可以考虑使用CodecPool。</em></strong></p><p><strong><em>4. 压缩和输入分片。</em></strong><br>在考虑如何压缩将有MapReduce处理的数据时，理解压缩格式是否支持切分（splitting）十分重要。以一个存储在HDFS文件系统中且压缩前大小为1GB的文件为例。如果HDFS块大小设置为128MB，那么该文件将被存储在8个块中。把这个文件作为输入数据的MapReduce作业，将创建8个输入分片，其中每个分片作为一个单独的map任务输入被单独处理。<br>如果文件是gzip压缩的，压缩后大小为1GB，HDFS将这个文件保存为8个数据块。但将每个数据块单独作为一个输入分片是无法实现独立的map工作的，因为不支持splitting。这种情况下，mapreduce不会切分gzip压缩文件，而是使用一个map任务来处理8个HDFS数据块。<strong>这牺牲了数据的本地性</strong>，因为大多数块并没有存储在执行该map任务的节点上。并且map任务数越少，作业的粒度就越大，运行时间可能会更长。<br>bzip2文件提供不同数据块之间的同步标识，因而它支持切分。</p><h3 id="在MapReduce中使用压缩"><a href="#在MapReduce中使用压缩" class="headerlink" title="在MapReduce中使用压缩"></a>在MapReduce中使用压缩</h3><p>如果输入文件是压缩的，那么在根据文件扩展名推断出相应的codec后，MapReduce会在读取文件时自动解压缩文件。<br>要想压缩MapReduce作业的输出，应在作业配置过程中将mapreduce.output.fileoutputformat.compress属性设为true，将mapreduce.output.fileoutputformat.compress.codec属性设置为打算使用的压缩codec的类名。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileOutputFormat.setCompressOutput(job, true);</span><br><span class="line">FileOutputFormat.setOutputCompressClass(job, GzipCodec.class);</span><br></pre></td></tr></table></figure></p><p>MapReduce应用读、写的是未经压缩的数据，但如果对map阶段的中间输入进行压缩，也可以获得不少好处。由于map任务的输出需要写到磁盘并通过网络传输到reducer节点，所以通过使用LZO、LZ4或者Snappy这样的快速压缩方式，是可以获得性能提升的，因为需要传输的数据减少了。</p><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>序列化（serialization）是指将结构化对象转化为字节流以便在网络上传输或写到磁盘进行永久存储的过程。反序列化（deserialization）是指将字节流转回结构化对象的逆过程。</p><p>序列化用于分布式数据处理的两大领域：进程间通信和永久存储。</p><p>在Hadoop中，系统中多个节点上进程间的通信是通过“远程过程调用RPC”实现的。RPC协议将消息序列化成二进制流后发送到远程节点，远程节点接着讲二进制流反系列化成原始消息。RPC序列化格式的理想属性为：紧凑；快速；可扩展；支持互操作。</p><p>Hadoop使用的是自己的序列化格式Writable，绝对紧凑，速度快，但不容易用Java意外的语言进行扩展或使用。Writable是Hadoop的核心（大多数的MapReduce程序都会在key，value类型使用它）。</p><h3 id="Writable接口"><a href="#Writable接口" class="headerlink" title="Writable接口"></a>Writable接口</h3><p>Writable接口定义了两个方法，一个将其状态写入DataOutput二进制流，另一个从DataInput二进制流读取状态；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import java.io.DataOutput;</span><br><span class="line">import java.io.DataInput;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public interface Writable&#123;</span><br><span class="line">    void write(DataOutput out) throws IOException;</span><br><span class="line">    void readFields(DataInput in) throws IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WritablComparable接口和comparator。该接口允许实现直接比较数据流中的记录，无须先把数据流反序列化为对象，这样避免了新建对象的额外开销。</p><p><strong><em>1. Java基本类型的Writable封装器</em></strong></p><p><img src="/images/2019-06-28-Hadoop-IO/hadoop_writable.png" alt="hadoop_writable"><br>所有的封装包含get()和set()两个方法用于读取和存储封装的值。<br>对整数进行编码时，有两种选择，<em>定长格式和变长格式</em>，如果编码的数值相当小（-127到127）之间，边长格式就只用一个字节进行编码，否则，使用第一个字节来表示数值的正负和后边跟多少个字节。<br>例如 VIntWritable(163) 会编码成“8fa3” a=10*16, 3=3*1。</p><p><strong><em>2. Text类型</em></strong><br>Text是针对UTF-8序列的Writable类。一般可以认为他是java.lang.String的Writable等价。<br>Text类使用整形来存储字符串编码中所需要的字节数，因为最大值为2GB。<br>Text.charAt()方法返回的是一个表示Unicode编码位置的int类型，而String返回的是一个char类型值。<br>Text.find()方法，类似于String的indexOf()方法。</p><p><strong><em>3. BytesWritable类型</em></strong><br>是对二进制数据数组的封装。它的序列化格式为一个指定所含数据字节数的整数域（4个字节），后跟数据内容本身。<br>例如：长度为2的字节数组包含3和5。序列化形式为一个4字节整数（00000002）和两个字节（03和05）。</p><p><strong><em>4. NullWritable类型</em></strong><br>特殊类型，序列化长度为0。它并不从数据流中读取数据也不写入数据。充当占位符。在MapReduce中，如果不需要使用key或value的序列化地址，就可以将key或value的值声明为NullWritable，这样可以高效存储常量空值。</p><p><strong><em>5. ObjectWritable和GenericWritable</em></strong><br>ObjectWritable是Java基本类型的通用封装。它在Hadoop RPC中用于对方法的参数和返回类型进行封装和解封装。<br>如果封装的类型数量比较少并且能够提前知道，那么可以通过使用静态类型的数组，并使用对序列化后的类型的引用加入位置索引来提高性能。GenericWritable就是这种方式。</p><p><strong><em>6. Writable集合类。</em></strong><br>ArrayWritable，ArrayPrimitiveWritable，TwoDArrayWritable，MapWritable，SortedMapWritable以及EnumMapWritable。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 两排序数组中点</title>
      <link href="/2019/06/27/2019-06-27-DifficultProblem/"/>
      <url>/2019/06/27/2019-06-27-DifficultProblem/</url>
      
        <content type="html"><![CDATA[<p>记录在LeetCode上遇到的反常规思路的题。</p><a id="more"></a> <!-- 摘要 --><h3 id="4-Median-of-Two-Sorted-Arrays"><a href="#4-Median-of-Two-Sorted-Arrays" class="headerlink" title="#4. Median of Two Sorted Arrays"></a>#4. Median of Two Sorted Arrays</h3><p>There are two sorted arrays nums1 and nums2 of size m and n respectively.</p><p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p><p>You may assume nums1 and nums2 cannot be both empty.</p><p>Example 1:<br>nums1 = [1, 3]<br>nums2 = [2]<br>The median is 2.0</p><p>Example 2:<br>nums1 = [1, 2]<br>nums2 = [3, 4]<br>The median is (2 + 3)/2 = 2.5</p><p>思路：<br>思路1：可以采用O(n+m)的复杂度，也就是数个数，这是two-pointer的思路。</p><p>思路2：题目中要求O(log(n+m))的复杂度，那么就要想到要用分治法。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用maven编译MapReduce程序-统计每年最小温度 MinTemp</title>
      <link href="/2019/06/27/2019-06-27-min_temp_maven/"/>
      <url>/2019/06/27/2019-06-27-min_temp_maven/</url>
      
        <content type="html"><![CDATA[<h3 id="MapReduce程序"><a href="#MapReduce程序" class="headerlink" title="MapReduce程序"></a>MapReduce程序</h3><p>参考《Hadoop权威指南》，依旧是MapReduce基本框架。<br>在NCDC记录中每一行是一条数据记录，每一行不同的偏移量代表不同的内容。</p><a id="more"></a> <!-- 摘要 --><h3 id="Map-程序"><a href="#Map-程序" class="headerlink" title="Map 程序"></a>Map 程序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package com.fredshao.hadoop;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import org.apache.hadoop.io.IntWritable;</span><br><span class="line">import org.apache.hadoop.io.LongWritable;</span><br><span class="line">import org.apache.hadoop.io.Text;</span><br><span class="line">import org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"></span><br><span class="line">public class MinTempMapper extends Mapper&lt;LongWritable, Text, Text, IntWritable&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private static final int MISSING = 9999;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    public void map(LongWritable Key, Text Value, Context context) throws IOException, InterruptedException&#123;</span><br><span class="line">    </span><br><span class="line">    String line = Value.toString();</span><br><span class="line">    String year = line.substring(15, 19);</span><br><span class="line">    </span><br><span class="line">    int airTemp;</span><br><span class="line">    if(line.charAt(87) == &apos;+&apos;)&#123;</span><br><span class="line">    airTemp = Integer.parseInt(line.substring(88, 92)); //将字符串转化为数值温度</span><br><span class="line">    &#125; else&#123;</span><br><span class="line">    airTemp = Integer.parseInt(line.substring(87, 92));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    String quality = line.substring(92, 93); //判断该数据是否是无效空白数据</span><br><span class="line">    if(airTemp != MISSING &amp;&amp; quality.matches(&quot;[01495]&quot;))&#123;</span><br><span class="line">    context.write(new Text(year), new IntWritable(airTemp));</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Reduce程序"><a href="#Reduce程序" class="headerlink" title="Reduce程序"></a>Reduce程序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.fredshao.hadoop;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import org.apache.hadoop.io.IntWritable;</span><br><span class="line">import org.apache.hadoop.io.Text;</span><br><span class="line">import org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line"></span><br><span class="line">public class MinTempReducer extends Reducer&lt;Text, IntWritable, Text, IntWritable&gt;&#123;</span><br><span class="line"></span><br><span class="line">    public void reduce(Text Key, Iterable&lt;IntWritable&gt; Values,</span><br><span class="line">    Reducer&lt;Text, IntWritable, Text, IntWritable&gt;.Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">    </span><br><span class="line">    int minTemp = Integer.MAX_VALUE;</span><br><span class="line">    for(IntWritable value:Values)&#123;</span><br><span class="line">    minTemp = Math.min(value.get(), minTemp); //这里IntWritable并不直接是整数，需要转换</span><br><span class="line">    &#125;</span><br><span class="line">    context.write(Key, new IntWritable(minTemp));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Main函数-Job"><a href="#Main函数-Job" class="headerlink" title="Main函数 Job"></a>Main函数 Job</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package com.fredshao.hadoop;</span><br><span class="line"></span><br><span class="line">import org.apache.hadoop.conf.Configuration;</span><br><span class="line"></span><br><span class="line">import org.apache.hadoop.fs.Path;</span><br><span class="line">import org.apache.hadoop.io.IntWritable;</span><br><span class="line">import org.apache.hadoop.io.Text;</span><br><span class="line">import org.apache.hadoop.mapreduce.Job;</span><br><span class="line">import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line">import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line">import org.apache.hadoop.util.GenericOptionsParser;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class MinTemp &#123;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">    </span><br><span class="line">    //这里可以不用写的这么复杂，下次试试简化版的可不可行</span><br><span class="line">    Configuration conf = new Configuration();</span><br><span class="line">    String[] otherArgs = new GenericOptionsParser(conf, args).getRemainingArgs();</span><br><span class="line">    if(otherArgs.length != 2)&#123;</span><br><span class="line">    System.err.println(&quot;Usage: MinTemp &lt;in&gt; &lt;out&gt;&quot;);</span><br><span class="line">    System.exit(2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Job job = new Job(conf);</span><br><span class="line">    job.setJobName(&quot;Min Temperature&quot;);</span><br><span class="line">    job.setJarByClass(MinTemp.class);</span><br><span class="line">    job.setMapperClass(MinTempMapper.class);</span><br><span class="line">    job.setReducerClass(MinTempReducer.class);</span><br><span class="line">    job.setOutputKeyClass(Text.class);</span><br><span class="line">    job.setOutputValueClass(IntWritable.class);</span><br><span class="line">    FileInputFormat.addInputPath(job, new Path(otherArgs[0]));</span><br><span class="line">    FileOutputFormat.setOutputPath(job, new Path(otherArgs[1]));</span><br><span class="line">    System.exit(job.waitForCompletion(true)? 0:1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用maven进行编译"><a href="#使用maven进行编译" class="headerlink" title="使用maven进行编译"></a>使用maven进行编译</h2><p>可参考 <a href="https://floodshao.github.io/posts/Maven_first" target="_blank" rel="noopener">Maven是什么</a></p><ol><li><p>构建maven project</p><p> 首先确认已经安装解压maven，并在环境变量/etc/profile中配置 $MAVEN_HOME/bin</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在预计工程目录下命令行, 注意版本不同。我使用maven 3.6.1, 命令中是generate而不是create</span><br><span class="line">mvn archetype:generate -DgroupId=com.fredshao.hadoop -DartifactId=MinTemp</span><br><span class="line">        </span><br><span class="line">这条命令会生成pom.xml配置文件和src下根据groupId创建的包结构。而且并不用向上述博客中设置-DarchetypeArtifactId。</span><br></pre></td></tr></table></figure><p> 生成project后，将源代码放入src相应目录下。</p></li><li><p>配置pom.xml文件导入依赖包。</p><p> 从代码编写过程中我们知道我们需要hadoop-common，hadoop-hdfs，hadoop-client三个包。</p><p> pom.xml (1)mvn包创建完成的时候</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">  &lt;groupId&gt;com.fredshao.hadoop&lt;/groupId&gt; </span><br><span class="line">  &lt;artifactId&gt;MinTemp&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">  &lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;!--maven包使用规范：</span><br><span class="line">  groupid和artifactId被统称为“坐标”是为了保证项目唯一性而提出的，</span><br><span class="line">  如果你要把你项目弄到maven本地仓库去，你想要找到你的项目就必须根据这两个id去查找。</span><br><span class="line">  (1)虽然产生的项目结构文件与groupId无关，但是大家公认的规范是填写项目包名;</span><br><span class="line">  (2)artifactId填写你负责的模块名，如项目名-模块名</span><br><span class="line">  --!&gt;</span><br><span class="line"></span><br><span class="line">  &lt;name&gt;MinTemp&lt;/name&gt;</span><br><span class="line">  &lt;url&gt;http://maven.apache.org&lt;/url&gt;</span><br><span class="line"></span><br><span class="line">  &lt;properties&gt;</span><br><span class="line">    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">  &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">  &lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.8.1&lt;/version&gt;</span><br><span class="line">      &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">  &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p> pom.xml (2)导入项目依赖包 添加如下：注意版本号</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;hadoop-common&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.9.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;hadoop-hdfs&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.9.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;hadoop-client&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.9.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p> 当你建立一个 Maven 的项目，Maven 会检查你的 pom.xml 文件，以确定哪些依赖下载。首先，Maven 将从本地资源库获得 Maven 的本地资源库依赖资源，如果没有找到，然后把它会从默认的 Maven 中央存储库 – <a href="http://repo1.maven.org/maven2/" target="_blank" rel="noopener">http://repo1.maven.org/maven2/</a> <strong>查找下载</strong>。在Maven中，当你声明的库不存在于本地存储库中，也没有不存在于Maven中心储存库，该过程将停止并将错误消息输出到 Maven 控制台。 因此在maven编译的过程中要保持网络连接，在国内最好配置阿里云镜像。</p></li><li><p>mvn 编译</p><p> 在pom.xml路径下使用命令mvn clean compile进行编译。该命令将忽略之前生成的所有编译文件，重新生成编译文件进行覆盖。生成target/classes/目录下所有的编译.class文件</p></li><li><p>mvn 打包生成jar</p><p> 命令mvn package对生成的所有文件进行打包。会在target/目录下创建.jar文件</p></li></ol><h2 id="使用hadoop-jar执行"><a href="#使用hadoop-jar执行" class="headerlink" title="使用hadoop jar执行"></a>使用hadoop jar执行</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$hadoop/bin hadoop jar ~/.../target/MinTemp-1.0-SNAPSHOT.jar /input_ncdc /output_ncdc</span><br><span class="line"></span><br><span class="line">报错：</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.ClassNotFoundException: /input_ncdc</span><br><span class="line">    at java.lang.Class.forName0(Native Method)</span><br><span class="line">    at java.lang.Class.forName(Class.java:348)</span><br><span class="line">    at org.apache.hadoop.util.RunJar.run(RunJar.java:237)</span><br><span class="line">    at org.apache.hadoop.util.RunJar.main(RunJar.java:158)</span><br><span class="line"></span><br><span class="line">$hadoop/bin hadoop jar ~/.../target/MinTemp-1.0-SNAPSHOT.jar com.fredshao.hadoop.MinTemp /input_ncdc /output_ncdc</span><br><span class="line"></span><br><span class="line">报错：</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.ClassNotFoundException: com.fredshao.hadoop.MinTemp</span><br><span class="line">    at java.net.URLClassLoader.findClass(URLClassLoader.java:382)</span><br><span class="line">    at java.lang.ClassLoader.loadClass(ClassLoader.java:424)</span><br><span class="line">    at java.lang.ClassLoader.loadClass(ClassLoader.java:357)</span><br><span class="line">    at java.lang.Class.forName0(Native Method)</span><br><span class="line">    at java.lang.Class.forName(Class.java:348)</span><br><span class="line">    at org.apache.hadoop.util.RunJar.run(RunJar.java:237)</span><br><span class="line">    at org.apache.hadoop.util.RunJar.main(RunJar.java:158)</span><br></pre></td></tr></table></figure><p>以上两个错误出现的问题都是RunJar.main方法找不到该jar包的主函数。<br>解压jar包  jar xvf MinTemp-1.0-SNAPSHOT.jar, 找到MANIFEST.MF文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Archiver-Version: Plexus Archiver</span><br><span class="line">Built-By: hadoop</span><br><span class="line">Created-By: Apache Maven 3.6.1</span><br><span class="line">Build-Jdk: 1.8.0_201</span><br></pre></td></tr></table></figure></p><p>该jar包没有显示class-path，没有显示主函数。这些需要在mvn编译的时候进行控制</p><h3 id="修改pom-xml-添加主函数入口"><a href="#修改pom-xml-添加主函数入口" class="headerlink" title="修改pom.xml,添加主函数入口"></a>修改pom.xml,添加主函数入口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">添加主函数入口</span><br><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">      &lt;plugin&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.4&lt;/version&gt;</span><br><span class="line">        &lt;configuration&gt;</span><br><span class="line">          &lt;archive&gt;</span><br><span class="line">              &lt;manifest&gt;</span><br><span class="line">                &lt;mainClass&gt;com.fredshao.hadoop.MinTemp&lt;/mainClass&gt;</span><br><span class="line">              &lt;/manifest&gt;</span><br><span class="line">          &lt;/archive&gt;</span><br><span class="line">        &lt;/configuration&gt;</span><br><span class="line">       &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure><p>继续进行编译和打包。</p><h3 id="hadoop-jar运行"><a href="#hadoop-jar运行" class="headerlink" title="hadoop jar运行"></a>hadoop jar运行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop jar ~/hadoop_code/MinTemp/target/MinTemp-1.0-SNAPSHOT.jar /input_ncdc /output_ncdc_mvn</span><br></pre></td></tr></table></figure><p>然后运行成功。</p><p>jar包解压</p><p><img src="/images/2019-06-27-min_temp_maven/jar_MANIFEST.png" alt="jar_MANIFEST"></p><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p><img src="/images/2019-06-27-min_temp_maven/output_result.png" alt="output_result"></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven 初步</title>
      <link href="/2019/06/26/2019-06-26-Maven_first/"/>
      <url>/2019/06/26/2019-06-26-Maven_first/</url>
      
        <content type="html"><![CDATA[<p>Maven 进行Java项目构建<br><a id="more"></a> <!-- 摘要 --></p><h3 id="Maven是什么"><a href="#Maven是什么" class="headerlink" title="Maven是什么"></a>Maven是什么</h3><h4 id="1-Maven是基于项目对象模型（POM-project-object-model），可以通过一小段描述（配置）信息来管理项目的构建，报告和文档的软件项目管理工具。"><a href="#1-Maven是基于项目对象模型（POM-project-object-model），可以通过一小段描述（配置）信息来管理项目的构建，报告和文档的软件项目管理工具。" class="headerlink" title="1. Maven是基于项目对象模型（POM project object model），可以通过一小段描述（配置）信息来管理项目的构建，报告和文档的软件项目管理工具。"></a>1. Maven是基于<strong>项目对象模型（POM project object model）</strong>，可以通过一小段描述（配置）信息来管理项目的构建，报告和文档的软件项目管理工具。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">https://www.cnblogs.com/whgk/p/7112560.html</span><br><span class="line">为什么要使用maven</span><br><span class="line">假如你正在Eclipse下开发两个Java项目，姑且把它们称为A、B，其中A项目中的一些功能依赖于B项目中的某些类，那么如何维系这种依赖关系的呢？</span><br><span class="line">需要用哪个项目中的哪些类，也就是用别人写好了的功能代码，导入jar包即可。所以这里也如此，可以将B项目打成jar包，然后在A项目的Library下导入B的jar文件，这样，A项目就可以调用B项目中的某些类了。</span><br><span class="line">这样做有缺陷：</span><br><span class="line">如果在开发过程中，发现B中的bug，则必须将B项目修改好，并重新将B打包并对A项目进行重编译操作；</span><br><span class="line">在完成A项目的开发后，为了保证A的正常运行，就需要依赖B。发布的时候要么</span><br><span class="line">（1）将B打包进A；</span><br><span class="line">（2）要么将B也发布，源码安装，这是我们经常使用的。</span><br></pre></td></tr></table></figure><h4 id="2-区别于上述依赖模式，maven的核心功能是合理叙述项目间的依赖关系。也就是通过pom-xml文件的配置获取jar包，而不是手动去添加jar包。"><a href="#2-区别于上述依赖模式，maven的核心功能是合理叙述项目间的依赖关系。也就是通过pom-xml文件的配置获取jar包，而不是手动去添加jar包。" class="headerlink" title="2. 区别于上述依赖模式，maven的核心功能是合理叙述项目间的依赖关系。也就是通过pom.xml文件的配置获取jar包，而不是手动去添加jar包。"></a>2. 区别于上述依赖模式，maven的核心功能是合理叙述项目间的依赖关系。也就是通过pom.xml文件的配置获取jar包，而不是手动去添加jar包。</h4><h4 id="3-学习maven的最终目的就是学会如何在pom-xml文件中配置获取到我们想要的jar包。"><a href="#3-学习maven的最终目的就是学会如何在pom-xml文件中配置获取到我们想要的jar包。" class="headerlink" title="3. 学习maven的最终目的就是学会如何在pom.xml文件中配置获取到我们想要的jar包。"></a>3. 学习maven的最终目的就是学会如何在pom.xml文件中配置获取到我们想要的jar包。</h4><p>例子：<br>如何用pom.xml文件获取junit的jar包：</p><p><img src="/images/2019-06-26-Maven_first/maven_pom_junit.png" alt="1"><br>pom可以通过groupId，artifactId和version三个属性来定位一个jar包。加入pom.xml的文件属于A项目，那么A项目一定是一个maven项目。需要找到的junit项目的jar包也必须是一个maven项目，在创建每个maven项目的时候都会要求写上这三个属性值。</p><p><img src="/images/2019-06-26-Maven_first/maven_pom_junit_id.png" alt="1"></p><h3 id="Maven的安装"><a href="#Maven的安装" class="headerlink" title="Maven的安装"></a>Maven的安装</h3><p>参考Hadoop安装, 将apache-maven3.6.1压缩包解压到/usr/local/<br>按实际配置环境变量。</p><p>注意环境变量中添加的是$MAVEN_HOME/bin</p><p>命令行 mvn -v查看是否安装成功。</p><h3 id="仓库的概念"><a href="#仓库的概念" class="headerlink" title="仓库的概念"></a>仓库的概念</h3><p>通过pom.xml文件就能够找到依赖包jar。那么这些jar包在哪里呢。在<strong>仓库里</strong>。<br>仓库分为：本地仓库，第三方仓库和中央仓库</p><ol><li><p>本地仓库：一般我们会建立一个文件夹，在网上下载一个拥有相对完整的所有jar包的组合，然后放到本地仓库，之后总该本地仓库调取就可以了。</p><p> 修改本地仓库的路径：/usr/local/apache-maven/conf/settings.xml中的<localrepository></localrepository></p></li><li><p>第三方仓库：又称为内部中心仓库，也称为私服。一般是由公司自己设立的，只为本公司内部共享使用。它既可以作为公司内部构件协作和存档，也可作为公用类库镜像缓存，减少在外部访问和下载的频率。（使用私服为了减少对中央仓库的访问）</p></li><li><p>中央仓库：Maven内置了远程公用仓库：<a href="http://repo1.maven.org/maven2" target="_blank" rel="noopener">http://repo1.maven.org/maven2</a>。这个公共仓库是由Maven自己维护，里面有大量的常用类库，并包含了世界上大部分流行的开源项目构件。目前是以java为主。工程依赖的jar包如果本地仓库没有，默认从中央仓库下载</p></li></ol><h2 id="3-使用命令行创建maven项目"><a href="#3-使用命令行创建maven项目" class="headerlink" title="3 使用命令行创建maven项目"></a>3 使用命令行创建maven项目</h2><p>创建一个空白文件路径，运行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:create -DgroupId=com.wuhao.maven.quickstart -DartifactId=simple -DarchetypeArtifactId=maven-archetype-quickstart</span><br></pre></td></tr></table></figure><p><strong>注意</strong><br><strong>版本命令冲突，即在maven3.0.5以上版本舍弃了create，使用generate生成项目</strong><br>用上述命令会产生如下报错信息：<br>Could not find goal ‘create’ in plugin org.apache.maven.plugins:maven-archetype-plugin:3.0.0 among available goals crawl, create-from-project, generate, help, integration-test, jar, update-local-catalog -&gt; [Help 1]<br><strong>修改</strong><br><strong>将上述命令中create更改为generate就可以。</strong></p><ul><li>mvn：核心命令</li><li>archetype:create：创建项目，现在maven高一点的版本都弃用了create命令而使用generate命令了。</li><li>-DgroupId=com.wuhao.maven.quickstart ：创建该maven项目时的groupId是什么，该作用在上面已经解释了。一般使用包名的写法。因为包名是用公司的域名的反写，独一无二</li><li>-DartifactId=simple：创建该maven项目时的artifactId是什么，就是项目名称</li><li>-DarchetypeArtifactId=maven-archetype-quickstart：表示创建的是[maven]java项目</li><li>运行的前提：需要联网，必须上网下载一个小文件</li></ul><p>运行成功会在命令行中显示Build Success<br>在该路径下会出现simple路径，这就是我们新建立的java项目。</p><h3 id="maven项目的结构"><a href="#maven项目的结构" class="headerlink" title="maven项目的结构"></a>maven项目的结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">simple</span><br><span class="line">    ---pom.xml 核心配置，在项目根目录下</span><br><span class="line">    ---src</span><br><span class="line">        ---main</span><br><span class="line">            ---java java源代码目录</span><br><span class="line">            ---resources java配置文件目录</span><br><span class="line">        ---test</span><br><span class="line">            ---java java测试代码目录</span><br><span class="line">            ---resources 测试配置文件目录</span><br><span class="line">    ---target 输出目录，对该项目进行编译，生成.class文件放置在该输出目录下</span><br></pre></td></tr></table></figure><h3 id="maven编译"><a href="#maven编译" class="headerlink" title="maven编译"></a>maven编译</h3><h3 id="复习一下Java的编译"><a href="#复习一下Java的编译" class="headerlink" title="复习一下Java的编译"></a>复习一下Java的编译</h3><ul><li>在Linux下配置Java的编译，首先要确保jdk安装环境变量。</li><li>jdk为java开发工具包，包含jre环境和javac编译器。</li><li>jre为java运行时的环境，包括java虚拟机环境，java基础类库等。javac是java源码的编译器。</li><li>classpath表示当我们需要一个java的库（class）时，系统会自动在CLASSPATH里面搜索，如果是jar，就自动从jar里面查找，如果是普通的目录，则在目录下面按照package进行查找。</li><li>也就是说，在用命令行编译一个java源码的时候，你需要将import导入的库包含在CLASSPATH中。否则将会报[ERROR]。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># java environment</span><br><span class="line">export JAVA_HOME=/usr/java/jdk1.8.0_201-amd64</span><br><span class="line">export JRE_HOME=$JAVA_HOME/jre</span><br><span class="line">export PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH</span><br><span class="line">export CLASSPATH=$CLASSPATH:.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br></pre></td></tr></table></figure><p>例如，编译hadoop-book/ch3/URLCat.java的程序。需要找到 package org.apache.hadoop.fs。但这个在哪里找呢？反正我是没有在hadoop的安装文件里找到相关的package。所以只好尝试maven编译。</p><p><img src="/images/2019-06-26-Maven_first/javac_error.png" alt="javac_error"></p><h3 id="maven编译java文件-hadoop-book-ch3-URLCat-java编译"><a href="#maven编译java文件-hadoop-book-ch3-URLCat-java编译" class="headerlink" title="maven编译java文件 (hadoop-book/ch3/URLCat.java编译)"></a>maven编译java文件 (hadoop-book/ch3/URLCat.java编译)</h3><ol><li>命令行构造maven项目</li><li>在/main/src/java下添加URLCat.java源码</li><li><p>修改根目录 pom.xml，添加库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;hadoop-hdfs&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.9.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;hadoop-common&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.9.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>保持网络连接，命令行mvn clean compile进行编译。</p></li></ol><p><img src="/images/2019-06-26-Maven_first/maven_compile.png" alt="maven_compile"></p><ol><li>参考Hadoop相关命令进行后续操作。<a href="https://floodshao.github.io/posts/hadoop_hdfs" target="_blank" rel="noopener">Hadoop-HDFS操作</a></li></ol><h2 id="使用MyEclipse创建maven项目"><a href="#使用MyEclipse创建maven项目" class="headerlink" title="使用MyEclipse创建maven项目"></a>使用MyEclipse创建maven项目</h2><p>高版本的MyEclipse中一般都内置了maven。MyEclipse2017 中内置了maven 3.3。<br><strong>TBC</strong>在MyEclipse配置自己安装的maven。</p><h3 id="创建maven-java项目"><a href="#创建maven-java项目" class="headerlink" title="创建maven java项目"></a>创建maven java项目</h3><ol><li>在Eclipse中创建maven project。注意，要勾选maven project。有可能没有出现在tool bar中，通过other获得。</li></ol><p><img src="/images/2019-06-26-Maven_first/maven_eclipse_create_mavenproject.png" alt="3"></p><ol><li>勾选创建简单项目， create a simple project</li></ol><p><img src="/images/2019-06-26-Maven_first/maven_eclipse_tick_simpleproject.png" alt="4"></p><ol><li>设置项目参数，创建java项目</li></ol><p><img src="/images/2019-06-26-Maven_first/maven_eclipse_create_mavenproject.png" alt="5"></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>执行第一个WordCount MapReduce 例程</title>
      <link href="/2019/06/25/2019-06-25-first_word_count/"/>
      <url>/2019/06/25/2019-06-25-first_word_count/</url>
      
        <content type="html"><![CDATA[<h2 id="基本要求"><a href="#基本要求" class="headerlink" title="基本要求"></a>基本要求</h2><ol><li>完成Hadoop配置，参考<a href="https://floodshao.github.io/posts/hadoop_zookeeper_hbase_setup" target="_blank" rel="noopener">https://floodshao.github.io/posts/hadoop_zookeeper_hbase_setup</a></li><li>MapReduce基本了解。<a id="more"></a> <!-- 摘要 --></li></ol><h2 id="MapReduce基础"><a href="#MapReduce基础" class="headerlink" title="MapReduce基础"></a>MapReduce基础</h2><ol><li>MapReduce任务过程分为两个处理阶段：map阶段和reduce阶段。每个阶段都以key-value作为输入输出，其类型由程序员来选择。需要写两个函数：map函数和reduce函数。</li><li>map阶段输入<strong>原始数据</strong>。注意这里的原始数据指的是最原始的记录文本数据。一般将原始数据的每一行作为文本输入。key为某一行起始位置相对于文件起始位置的偏移量，但这个信息我们不需要。（在hadoop权威指南里，NCDC数据每一行是一条数据；在wordcount里就是一行文本，包含多个单词）</li><li>map函数的输出依然是key-value经MapReduce框架处理（combine）后，最后发送到reduce函数。这个combine处理是对key-value进行排序和分组。</li><li>reduce函数对输入的key-value进行相应的处理，得到我们想要的结果（在wordcount中就是统计每个单词出现的个数）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">MapReduce 流程：</span><br><span class="line"></span><br><span class="line">1. 将文件拆分成splits过程：key为每一行起始偏移量，value为该行的文本</span><br><span class="line"></span><br><span class="line">file1:</span><br><span class="line">    hello world         &lt;&apos;0&apos;, hello world&gt;</span><br><span class="line">    bye world      =&gt;   &lt;&apos;12&apos;, bye world&gt; </span><br><span class="line">file2:</span><br><span class="line">    hello hadoop         &lt;&apos;0&apos;, hello hadoop&gt;</span><br><span class="line">    bye hadoop      =&gt;   &lt;&apos;12&apos;, bye hadoop&gt; </span><br><span class="line"></span><br><span class="line">2. Mapper.map()方法对上述key-value进行操作：</span><br><span class="line"></span><br><span class="line">file1:</span><br><span class="line">&lt;&apos;0&apos;, hello world&gt;      &lt;&apos;hello&apos;, 1&gt; &lt;&apos;world&apos;, 1&gt;</span><br><span class="line">&lt;&apos;12&apos;, bye world&gt;   =&gt;  &lt;&apos;bye&apos;, 1&gt; &lt;&apos;world&apos;, 1&gt;</span><br><span class="line">file2:</span><br><span class="line">&lt;&apos;0&apos;, hello hadoop&gt;      &lt;&apos;hello&apos;, 1&gt; &lt;&apos;hadoop&apos;, 1&gt;</span><br><span class="line">&lt;&apos;12&apos;, bye hadoop&gt;   =&gt;  &lt;&apos;bye&apos;, 1&gt; &lt;&apos;hadoop&apos;, 1&gt;</span><br><span class="line"></span><br><span class="line">3. Mapper进行combine操作，对map方法的输出进行排序和合并：</span><br><span class="line"></span><br><span class="line">&lt;&apos;hello&apos;, 1&gt; &lt;&apos;world&apos;, 1&gt;       &lt;&apos;bye&apos;, 1&gt; &lt;&apos;hello&apos;, 1&gt; &lt;&apos;world&apos;, 2&gt;</span><br><span class="line">&lt;&apos;bye&apos;, 1&gt; &lt;&apos;world&apos;, 1&gt;     =&gt;  </span><br><span class="line"></span><br><span class="line">&lt;&apos;hello&apos;, 1&gt; &lt;&apos;hadoop&apos;, 1&gt;       &lt;&apos;bye&apos;, 1&gt; &lt;&apos;hadoop&apos;, 2&gt; &lt;&apos;hello&apos;, 1&gt;</span><br><span class="line">&lt;&apos;bye&apos;, 1&gt; &lt;&apos;hadoop&apos;, 1&gt;     =&gt;  </span><br><span class="line"></span><br><span class="line">4. Reducer先对Mapper对所有文件的输出进行排序和合并，然后根据用户编写的reduce方法进行相应操作：</span><br><span class="line"></span><br><span class="line">&lt;&apos;bye&apos;, 1&gt; &lt;&apos;hello&apos;, 1&gt; &lt;&apos;world&apos;, 2&gt;        </span><br><span class="line">&lt;&apos;bye&apos;, 1&gt; &lt;&apos;hadoop&apos;, 2&gt; &lt;&apos;hello&apos;, 1&gt;   =&gt; 排序合并，注意这里的合并是将数据分组</span><br><span class="line"></span><br><span class="line">&lt;&apos;bye&apos;, list[1, 1]&gt; &lt;&apos;hadoop&apos;, list[2]&gt; &lt;&apos;hello&apos;, list[1, 1]&gt; &lt;&apos;world&apos;, list[2]&gt;    =&gt; reduce方法定义操作</span><br><span class="line"></span><br><span class="line">&lt;&apos;bye&apos;, 2&gt; &lt;&apos;hadoop&apos;, 2&gt; &lt;&apos;hello&apos;, 2&gt; &lt;&apos;world&apos;, 2&gt;</span><br></pre></td></tr></table></figure><p>在编写的过程中，我们实际只需要写Mapper.map()和Reducer.reduce()方法。</p><h2 id="自定义map和reduce"><a href="#自定义map和reduce" class="headerlink" title="自定义map和reduce"></a>自定义map和reduce</h2><h3 id="1-map方法"><a href="#1-map方法" class="headerlink" title="1. map方法"></a>1. map方法</h3><p>Mapper源代码查看：<br>    源码路径/hadoop-2.9.2-src/hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-core/<br>    package org.apache.hadoop.mapreduce<br>    在TokenizerMapper.java中继承Mapper类重写Mapper.map()方法。<br>    Mapper产生一个intermediate pairs，输入输出类型并不要求一致。<br>    The Hadoop Map-Reduce framework spawns one map task for each {@link InputSplit} generated by the {@link InputFormat} for the job. <code>Mapper</code> implementations can access the {@link Configuration} for the job via the {@link JobContext#getConfiguration()}.</p><pre><code>%TokenizerMapper.javapackage com.fredshao.hadoop;import java.io.IOException;import java.util.StringTokenizer;import org.apache.hadoop.io.IntWritable;import org.apache.hadoop.io.Text;import org.apache.hadoop.mapreduce.Mapper;public class TokenizerMapper extends Mapper&lt;Object, Text, Text, IntWritable&gt;{    IntWritable one = new IntWritable(1);    Text word = new Text();    public void map(Object key, Text value, Context context) throws IOException, InterruptedException{        StringTokenizer itr new StringTokenizer(value.toString());        while(itr.hasMoreTokens()){            word.set(itr.nextToken());            context.write(word, one);        }    }}</code></pre><h3 id="2-reduce方法"><a href="#2-reduce方法" class="headerlink" title="2. reduce方法"></a>2. reduce方法</h3><p>Reducer源代码查看：<br>    源码路径/hadoop-2.9.2-src/hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-core/<br>    package org.apache.hadoop.mapreduce<br>    在IntSumReducer.java中继承Reducer并重写Reducer.reduce()方法。</p><pre><code>%IntSumReducer.javapackage com.fredshao.hadoop;import java.io.IOException;import org.apache.hadoop.io.IntWritable;import org.apache.hadoop.io.Text;import org.apache.hadoop.mapreduce.Reducer;public class IntSumReducer extends Reducer&lt;Text, IntWritable, Text, IntWritable&gt;{    IntWritable result = new IntWritable();    //这里Text key是输入键，Iterable是经过combine的输入值list    public void reduce(Text key, Iterable&lt;IntWritable&gt; values, Context context) throws IOException, InterruptedException{        int sum = 0;        for(IntWritable val:values){            sum += val.get();        }        result.set(sum);        context.write(key, result);    }}</code></pre><h3 id="3-main函数，建立mapreduce执行入口"><a href="#3-main函数，建立mapreduce执行入口" class="headerlink" title="3. main函数，建立mapreduce执行入口"></a>3. main函数，建立mapreduce执行入口</h3><p>MapReduce中job的使用。MapReduce.Job类<br>It allows the user to configure the job, submit it, control its execution, and query the state. The set methods only work until the job is submitted, afterwards they will throw an IllegalStateException. 在mapreduce执行前对job进行设定。<br>job类一般的配置：</p><ol><li><p>建立新的job：</p><ul><li>Job job = Job.getInstance();</li><li>job.setJarByClass(MyJob.class); //程序入口</li></ul></li><li><p>设定job相关参数</p><ul><li>job.setJobName(“myjob”);</li><li>job.setInputPath(new Path(“in”));</li><li>job.setOutputPath(new Path(“out”));   </li><li>job.setMapperClass(MyJob.MyMapper.class);</li><li>job.setReducerClass(MyJob.MyReducer.class);</li></ul></li><li><p>提交job，submit the job</p><ul><li>job.waitForCompletion(true);</li></ul></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">%WordCount.java</span><br><span class="line"></span><br><span class="line">package com.fredshao.hadoop;</span><br><span class="line"></span><br><span class="line">import org.apache.hadoop.conf.Configuration;</span><br><span class="line">import org.apache.hadoop.fs.Path;</span><br><span class="line">import org.apache.hadoop.io.IntWritable;</span><br><span class="line">import org.apache.hadoop.io.Text;</span><br><span class="line">import org.apache.hadoop.mapreduce.Job;</span><br><span class="line">import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line">import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line">import org.apache.hadoop.util.GenericOptionsParser;</span><br><span class="line"></span><br><span class="line">public class WordCount &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">    Configuration conf = new Configuration();</span><br><span class="line">    String[] otherArgs = new GenericOptionsParser(conf, args).getRemainingArgs();</span><br><span class="line">    if(otherArgs.length != 2)&#123;</span><br><span class="line">    System.err.println(&quot;Usage: wordcount &lt;in&gt; &lt;out&gt;&quot;);</span><br><span class="line">    System.exit(2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Job job = new Job(conf, &quot;wordcount&quot;);</span><br><span class="line">    job.setJarByClass(WordCount.class);</span><br><span class="line">    job.setMapperClass(TokenizerMapper.class);</span><br><span class="line">    job.setReducerClass(IntSumReducer.class);</span><br><span class="line">    job.setCombinerClass(IntSumReducer.class);</span><br><span class="line">    job.setOutputKeyClass(Text.class);</span><br><span class="line">    job.setOutputValueClass(IntWritable.class);</span><br><span class="line">    FileInputFormat.addInputPath(job, new Path(otherArgs[0]));</span><br><span class="line">    FileOutputFormat.setOutputPath(job, new Path(otherArgs[1]));</span><br><span class="line">    System.exit(job.waitForCompletion(true)?0:1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="程序打包流程"><a href="#程序打包流程" class="headerlink" title="程序打包流程"></a>程序打包流程</h2><p>将上述mapreduce包含的3个程序进行打包：</p><ol><li><p>编译需要的hadoop jar包：</p><p> Hadoop 2.x 版本中jar不再集中在一个 hadoop-core-*.jar 中，而是分成多个 jar。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$HADOOP_HOME/share/hadoop/common/hadoop-common-2.4.1.jar</span><br><span class="line">$HADOOP_HOME/share/hadoop/mapreduce/hadoop-mapreduce-client-core-2.4.1.jar</span><br><span class="line">$HADOOP_HOME/share/hadoop/common/lib/commons-cli-1.2.jar</span><br><span class="line"></span><br><span class="line">从上述import，io，fs和util来自common，mapreduce来自mapreduce-client-core.</span><br><span class="line">commons-cli-1.2.jar是跟maven编译相关的jar包，目前不知道有什么作用。</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>使用javac进行编译</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -classpath /path1:/path2:/path3 -d classes/ src/*.java</span><br></pre></td></tr></table></figure><p> 注意事项：</p><ul><li>如果使用myeclipse进行开发的话，那么如果编写不报错，会自动在相同目录下生成bin文件夹，里边是编译好的class。直接使用就好了</li><li>-d 是生成的class文件的地址</li><li>-classpath是源代码中依赖库的路径，用：隔开</li></ul></li><li><p>将class打包成jar</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar -cvf WordCount.java classes</span><br></pre></td></tr></table></figure></li></ol><pre><code>classes是需要打包的所有编译成功的类的目录地址</code></pre><h2 id="MapReduce执行"><a href="#MapReduce执行" class="headerlink" title="MapReduce执行"></a>MapReduce执行</h2><p><strong><em>1. hadoop环境启动：</em></strong></p><p>在这里，与之前在<a href="https://floodshao.github.io/posts/hadoop_zookeeper_hbase_setup" target="_blank" rel="noopener">https://floodshao.github.io/posts/hadoop_zookeeper_hbase_setup</a>的配置有些不同。</p><ul><li><p>core-site.xml中：master和slave中配置相同</p><pre><code> &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://nn1.hadop:9000&lt;/value&gt;</code></pre></li><li><p>hdfs-site.xml中：</p><pre><code> &lt;property&gt;     &lt;name&gt;dfs.name.dir&lt;/name&gt;     &lt;value&gt;/home/hadoop/hadoop/name&lt;/value&gt; &lt;/property&gt; &lt;property&gt;     &lt;name&gt;dfs.data.dir&lt;/name&gt;     &lt;value&gt;/home/hadoop/hadoop/data&lt;/value&gt; &lt;/property&gt;</code></pre></li></ul><p>成功启动hadoop集群的标志是：<br><img src="/images/2019-06-25-first_word_count/hadoop_env_before_word_count.png" alt="hadoop_env_before_word_count"><br>在启动集群的过程中，出现了namenode无法启动，datanode无法启动，以及下图中出现的完全没有分配存储空间的问题：<br><img src="/images/2019-06-25-first_word_count/hadoop_fs_error.png" alt="hadoop_fs_error"></p><p>采取的措施如下：</p><ol><li>查看netstat -tlpn，master是否在监听nn1.hadoop:9000端口。基本上出现上述问题都是看不到。因为hadoop集群启动成功一定会自动监听9000端口</li><li>将hdfs-site中的name.dir和data.dir所指向的物理位置全部删除</li><li>将/hadoop/logs全部删除</li><li>重新初始化hadoop namenode -format</li><li>注意不要多次重复初始化namenode，这样很容易继续导致上述问题</li><li>然后再次进行hadoop集群初始化</li></ol><p><img src="/images/2019-06-25-first_word_count/hadoop_fs_correct.png" alt="hadoop_fs_correct"></p><p><strong><em>2. 执行：</em></strong><br>注意mapreduce处理的文件必须是hdfs部署下的文件。<br>先查看hdfs相关操作：$HADOOP_HOME/bin/<br>hadoop fs -ls / #hdfs根目录ls<br>hadoop fs -put [本地文件files] [hdfs文件/input] #将files放入input中 </p><p><strong><em>3. 执行wordcount：</em></strong><br>注意要带上package信息，因为在程序中添加了package信息。jar参数表示指定jar包的位置，主类为com.fredshao.hadoop.WordCount。运行程序处理/input目录下的文件，将结果写入/output。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hadoop/bin/hadoop jar wordcount/WordCount.jar com.fredshao.hadoop.WordCount /input /output</span><br></pre></td></tr></table></figure></p><p><img src="/images/2019-06-25-first_word_count/word_count_command.png" alt="word_count_command"></p><p><strong><em>4. 查看运行结果</em></strong><br><img src="/images/2019-06-25-first_word_count/word_count_success.png" alt="word_count_success"><br>在/output目录下有两个文件，结果就存放在/output/part-r-00000中。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyEclipse 安装</title>
      <link href="/2019/06/24/2019-06-24-MyEclipse_install/"/>
      <url>/2019/06/24/2019-06-24-MyEclipse_install/</url>
      
        <content type="html"><![CDATA[<p>本安装仅供学习交流使用，如继续使用请支持正版购买。</p><h2 id="安装系统：-Mac"><a href="#安装系统：-Mac" class="headerlink" title="安装系统： Mac"></a>安装系统： Mac</h2><p>默认已经安装了Java jdk1.8，并设置好了环境变量。如果没有设置好，请参考mac jdk1.8安装<br>安装文件下载：<br>链接： <a href="https://pan.baidu.com/s/1dKuEMdzjwPitjxdzubTxZA" target="_blank" rel="noopener">https://pan.baidu.com/s/1dKuEMdzjwPitjxdzubTxZA</a><br>密码： 334l       MyEclipse2017CI9-Mac</p><a id="more"></a> <!-- 摘要 --><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><ol><li>下载dmg文件进行安装,同时下载破解文件进行解压</li><li>等待安装完毕后，关闭MyEclipse进行破解</li><li>在/Applications/MyEclipse 2017 CI/MyEclipse 2017 CI.app/Contents/Profile/Plugins/中替换破解文件中的crack</li><li><p>双击运行cracker2017.jar 在username中随便输入，后边的professional改为blue。<br> <img src="/images/2019-06-24-MyEclipse_install/username.png" alt="1"></p></li><li><p>双击SystemId生成注册信息，并激活Activate<br> <img src="/images/2019-06-24-MyEclipse_install/click_systemid.png" alt="2"></p></li><li><p>左上角Tools点击保存activation信息, 1_save_properties<br> <img src="/images/2019-06-24-MyEclipse_install/save_properties.png" alt="3"></p></li><li><p>查看激活状态。状态栏Help-&gt;Subscription Information</p></li></ol><h2 id="Mac-上利用MyEclipse进行hadoop-java开发"><a href="#Mac-上利用MyEclipse进行hadoop-java开发" class="headerlink" title="Mac 上利用MyEclipse进行hadoop java开发"></a>Mac 上利用MyEclipse进行hadoop java开发</h2><ol><li>下载或自行编译hadoop-eclipse-plugin-2.9.2.jar。 一般搜索该jar包都能搜到，自行编译请参考<a href="https://github.com/winghc/hadoop2x-eclipse-plugin" target="_blank" rel="noopener">https://github.com/winghc/hadoop2x-eclipse-plugin</a>。自行编译需要线性安装ant，而且非常慢。我在网上下载的包可以使用，所以应该问题不大。</li><li>找到/Applications/My Eclipse/My Eclipse Drop-ins/dropins，将上述jar包放入dropins中。</li><li><p>重启MyEclipse，查看Preference, 是否存在Hadoop Map/Reduce选项。如果存在，则说明插件安装成功。</p><p> <img src="/images/2019-06-24-MyEclipse_install/hadoop_me_preference.png" alt="hadoop_me_preference"><br> 如上图所示，添加hadoop安装目录。这里不一定要将hadoop安装目录解压到/usr/local/等目录，只要能够找到该目录就可以了。</p></li><li><p>如果只是在me上验证程序，不进行部署的话，到这里就可以了。如果需要在mac上进行hadoop部署的话需要进行后续。参考<a href="https://www.cnblogs.com/chaofn/p/4580554.html" target="_blank" rel="noopener">https://www.cnblogs.com/chaofn/p/4580554.html</a></p></li><li>添加一个map/reduce project。<br> 测试import org.apache.hadoop.io.IntWritable;<br> 如果能够找到，说明添加库成功。</li></ol><h2 id="MyEclipse设置自动补全"><a href="#MyEclipse设置自动补全" class="headerlink" title="MyEclipse设置自动补全"></a>MyEclipse设置自动补全</h2><p>在Preferences下找到下图中红框的内容，原本只有一个’.’,表示只有填写’.’才会触发自动补全，我们要做到是添加所有字母’a-z’外加一个’.’，这样就可以在任何时候都触发自动补全。<br> <img src="/images/2019-06-24-MyEclipse_install/me_autocompletion.png" alt="me_autocompletion"></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyEclipse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop + ZooKeeper + HBase 分布式集群搭建</title>
      <link href="/2019/06/23/2019-06-23-hadoop_zookeeper_hbase_setup/"/>
      <url>/2019/06/23/2019-06-23-hadoop_zookeeper_hbase_setup/</url>
      
        <content type="html"><![CDATA[<p>Hadoop + ZooKeeper + HBase 分布式集群搭建<br><a id="more"></a> <!-- 摘要 --></p><p>参考：<a href="https://blog.csdn.net/lisonglisonglisong/article/details/46974723" target="_blank" rel="noopener">https://blog.csdn.net/lisonglisonglisong/article/details/46974723</a></p><h2 id="搭建说明"><a href="#搭建说明" class="headerlink" title="搭建说明"></a>搭建说明</h2><ol><li>Hadoop是分布式操作系统（基础是hdfs文件系统，和yarn环境资源协调服务），ZooKeeper是分布式应用程序协调服务，HBase是分布式面向列的开源数据库。</li><li><p>环境搭建说明：</p><ul><li><strong>集群环境至少需要3个节点</strong>（也就是3台服务器设备）：1个Master，2个Slave，节点之间局域网连接，可以相互ping通</li><li><strong>三个节点均使用CentOS7操作系统</strong>，为便于维护和批量操作，在3个节点上的集群环境配置使用相同的路径。具体配置路径如下：<ul><li>hadoop: /usr/local/hadoop</li><li>zookeeper: /usr/local/zookeeper</li><li>hbase: /usr/local/hbase</li></ul></li><li><strong>三个节点使用hadoop用户进行相关集群操作</strong>，上述配置路径的用户组全部要设为hadoop:hadoop<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R hadoop:hadoop /usr/local/hadoop</span><br></pre></td></tr></table></figure></li></ul></li><li><p>三个节点的ip设置<br> 在/etc/hosts中设置如下ip地址</p><p> | hostname | ip | user | role |<br> | —- | —- | —- | —- |<br> | nn1.hadoop | 192.168.0.204 | hadoop | master |<br> | s2.hadoop | 192.168.0.202 | hadoop | slave |<br> | s3.hadoop | 192.168.0.203 | hadoop | slave |</p></li></ol><p>设置三个用户的ssh免密登录：可参考<a href="https://floodshao.github.io/posts/ssh_remote_access" target="_blank" rel="noopener">https://floodshao.github.io/posts/ssh_remote_access</a></p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(1) 在.ssh下id_rsa私钥和id_rsa.pub公钥 </span><br><span class="line">    </span><br><span class="line">hadoop#~/.ssh ssh-keygen -t rsa</span><br><span class="line">    </span><br><span class="line">(2) 客户端为A，服务端为B，A与B免密沟通要将A的公钥放在B的authorized_keys中。例如，在s2服务器上：</span><br><span class="line">    </span><br><span class="line">hadoop#~/.ssh scp -p id_rsa.pub hadoop@nn1.hadoop:~/.ssh/authorized_keys</span><br><span class="line">    </span><br><span class="line">(3) 登录B端验证：</span><br><span class="line">    </span><br><span class="line">ssh hadoop@nn1.hadoop</span><br></pre></td></tr></table></figure></code></pre><ol><li><p>关闭服务器的防火墙：zookeeper在维护服务器间通信时可能会因为防火墙的存在而导致维护失败。一般会关闭防火墙。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">centos 7关闭防火墙命令：</span><br><span class="line">查看防火墙状态：systemctl status firewalld.service</span><br><span class="line">执行关闭命令：systemctl stop firewalld.service</span><br><span class="line">执行开启命令：systemctl start firewalld.service</span><br><span class="line">执行开机禁止防火墙启动命令：systemctl disable firewalld.service</span><br></pre></td></tr></table></figure></li><li><p>环境搭建准备：</p><ul><li>java环境</li><li>/etc/hosts在三个节点上同时配置节点映射</li><li>集群之间建立免密ssh连接：master到slave，slave到master，slave之间不必进行免密ssh认证</li><li>hadoop编译安装（master上）</li><li>zookeeper解压安装（master上）</li><li>hbase解压安装（master上）</li></ul></li></ol><h2 id="Hadoop环境配置-usr-local-hadoop-用户属hadoop-hadoop"><a href="#Hadoop环境配置-usr-local-hadoop-用户属hadoop-hadoop" class="headerlink" title="Hadoop环境配置 /usr/local/hadoop 用户属hadoop:hadoop"></a>Hadoop环境配置 /usr/local/hadoop 用户属hadoop:hadoop</h2><p>将Hadoop配置为全分布模式，参考《Hadoop权威指南》第十章。<br>环境配置文件位于/etc/，相关配置文件解释。</p><div class="table-container"><table><thead><tr><th>File Name</th><th>Description</th><th>Format</th><th>Remark</th></tr></thead><tbody><tr><td>hadoop-env.sh</td><td>运行hadoop的环境变量</td><td>Bash</td><td>默认JAVA_HOME要转换为绝对路径，否则会在启动hadoop时出现java报错</td></tr><tr><td>mapred-env.sh</td><td>运行mapreduce的环境变量，覆盖hadoop-env.sh</td><td>Bash</td><td></td></tr><tr><td>yarn-env.sh</td><td>运行yarn的环境变量，覆盖hadoop-env.sh</td><td>Bash</td><td></td></tr><tr><td>core-site.xml</td><td>Hadoop Core配置项，HDFS，YARN，MapReduce的I/O设置</td><td>xml</td><td></td></tr><tr><td>hdfs-site.xml</td><td>hadoop守护进程配置，包括namenode，辅助namenode和datanode</td><td>xml</td><td></td></tr><tr><td>mapred-site.xml</td><td>mapreduce守护进程配置</td><td>xml</td><td></td></tr><tr><td>yarn-site.xml</td><td>yarn守护进程配置，包括资源管理器，web应用服务和节点管理器</td><td>xml</td><td></td></tr><tr><td>slaves</td><td>运行datanode和节点管理器的机器列表</td><td>纯文本</td><td></td></tr><tr><td>hadoop-metrics2.properties</td><td></td><td>java属性</td><td></td></tr><tr><td>log4j.properties</td><td>系统日志文件</td><td>java属性</td><td></td></tr><tr><td>hadoop-policy.xml</td><td>安全模式下运行hadoop时的访问控制列表的配置项</td><td>xml</td></tr></tbody></table></div><ol><li><p>core.site.xml配置为全分布模式</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">   &lt;property&gt;</span><br><span class="line">       &lt;name&gt;fs.default.name&lt;/name&gt;</span><br><span class="line">       &lt;value&gt;hdfs://nn1.hadoop:9000&lt;/value&gt; &lt;!--hdfs://namenode/--!&gt;</span><br><span class="line">   &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></li><li><p>hadoop-env.sh配置</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">原本JAVA_HOME的配置为$JAVA_HOME，要改为绝对路径</span><br><span class="line">export JAVA_HOME=/usr/java/jdk1.8.0_201-amd64</span><br></pre></td></tr></table></figure></li><li><p>hdfs-site.xml</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;dfs.name.dir&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;/home/hadoop/name&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;dfs.data.dir&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;/home/hadoop/data&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;dfs.replication&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;3&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></li><li><p>mapred-site.xml</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">    &lt;name&gt;mapred.job.tracker&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;nn1.hadoop:9001&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></li><li><p>添加masters文件</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nn1.hadoop</span><br></pre></td></tr></table></figure></li><li><p>修改slaves文件</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s2.hadoop</span><br><span class="line">s3.hadoop</span><br></pre></td></tr></table></figure></li><li><p>将hadoop相关配置完全配置到所有服务器中</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r /usr/local/hadoop/etc/hadoop/ s2.hadoop:/usr/local/hadoop/etc/hadoop/</span><br></pre></td></tr></table></figure></li><li><p>启动hadoop集群</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">（1）格式化namenode，第一次启动hadoop服务前执行的操作，以后不需要执行。</span><br><span class="line">hadoop#/usr/local/hadoop/bin/ hadoop namenode -format</span><br><span class="line">（2）启动hadoop集群</span><br><span class="line">hadoop#/usr/local/hadoop/sbin/ start-all.sh</span><br><span class="line">（3）通过jps查看hadoop进程是否正常执行：</span><br><span class="line">Master namenode运行的java进程：</span><br><span class="line"></span><br><span class="line">8083 NameNode</span><br><span class="line">8788 SecondaryNameNode</span><br><span class="line">16855 DataNode</span><br><span class="line">7656 ResourceManager</span><br><span class="line">11353 Jps</span><br><span class="line">524 Main</span><br><span class="line"></span><br><span class="line">Slave datanode运行的java进程：</span><br><span class="line"></span><br><span class="line">3616 DataNode</span><br><span class="line">3751 NodeManager</span><br><span class="line">4203 ResourceManager</span><br><span class="line">19757 Jps</span><br></pre></td></tr></table></figure></li></ol><h2 id="ZooKeeper环境配置-usr-local-zookeeper-用户属-hadoop-hadoop"><a href="#ZooKeeper环境配置-usr-local-zookeeper-用户属-hadoop-hadoop" class="headerlink" title="ZooKeeper环境配置 /usr/local/zookeeper/ 用户属 hadoop:hadoop"></a>ZooKeeper环境配置 /usr/local/zookeeper/ 用户属 hadoop:hadoop</h2><ol><li><p>修改配置文件/conf/zoo.cfg</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在配置文件中添加如下配置</span><br><span class="line">dataDir=/data/</span><br><span class="line"></span><br><span class="line">server.1=nn1.hadoop:2888:3888</span><br><span class="line">server.2=s2.hadoop:2888:3888</span><br><span class="line">server.3=s3.hadoop:2888:3888</span><br></pre></td></tr></table></figure><p> 将zookeeper所有的安装目录复制到3台服务器中。</p></li><li><p>新建并编辑myid文件，在上述/dataDir/下建立myid纯文本文件</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">master为”1“ ， slave为”2“， ”3“，对应于上述server编号</span><br><span class="line">echo &quot;1&quot; &gt; /data/myid</span><br></pre></td></tr></table></figure></li><li><p>启动zookeeper集群，注意这个要批量操作，在3台机器上全部启动</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop#/usr/local/zookeeper/bin/ zkServer.sh start</span><br></pre></td></tr></table></figure><p> 这里可能出现两个问题：</p><ul><li>SLF4J包冲突 <a href="https://blog.csdn.net/chuyouyinghe/article/details/79134894" target="_blank" rel="noopener">解决办法</a></li><li>防火墙问题，参考上述环境设置</li></ul></li><li><p>如何判断zookeeper集群启动成功</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> 批量启动zookeeper的命令（shell脚本）：</span><br><span class="line"> ./ssh_all_group.sh &quot;/usr/local/zookeeper/bin/zkServer.sh start&quot;</span><br><span class="line"> </span><br><span class="line"> zookeeper启动成功标志是在三个服务上都运行QuarumPeerMain</span><br><span class="line"> </span><br><span class="line"> [hadoop@nn1 ssh_learning]$ ./ssh_all_group.sh &quot;jps | grep Quorum&quot;</span><br><span class="line">ssh hadoop@nn1.hadoop jps | grep Quorum</span><br><span class="line">11598 QuorumPeerMain</span><br><span class="line">OK</span><br><span class="line">ssh hadoop@s2.hadoop jps | grep Quorum</span><br><span class="line">20110 QuorumPeerMain</span><br><span class="line">OK</span><br><span class="line">ssh hadoop@s3.hadoop jps | grep Quorum</span><br><span class="line">19952 QuorumPeerMain</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></li></ol><h2 id="HBase集群安装与配置-usr-local-hbase-用户属hadoop-hadoop"><a href="#HBase集群安装与配置-usr-local-hbase-用户属hadoop-hadoop" class="headerlink" title="HBase集群安装与配置 /usr/local/hbase/ 用户属hadoop:hadoop"></a>HBase集群安装与配置 /usr/local/hbase/ 用户属hadoop:hadoop</h2><ol><li><p>/conf/hbase-env.sh</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/java/jdk1.8.0_201-amd64</span><br><span class="line">export HBASE_CLASSPATH=/usr/local/hadoop/etc/hadoop/</span><br><span class="line">export HBASE_MANAGES_ZK=false</span><br></pre></td></tr></table></figure></li><li><p>/conf/hbase-site.xml</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">            &lt;name&gt;hbase.rootdir&lt;/name&gt;</span><br><span class="line">            &lt;value&gt;hdfs://nn1.hadoop:9000/hbase&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">            &lt;name&gt;hbase.master&lt;/name&gt;</span><br><span class="line">            &lt;value&gt;nn1.hadoop&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">            &lt;name&gt;hbase.cluster.distributed&lt;/name&gt;</span><br><span class="line">            &lt;value&gt;true&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">            &lt;name&gt;hbase.zookeeper.property.clientPort&lt;/name&gt;</span><br><span class="line">            &lt;value&gt;2181&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">            &lt;name&gt;hbase.zookeeper.quorum&lt;/name&gt;</span><br><span class="line">            &lt;value&gt;nn1.hadoop,s2.hadoop,s3.hadoop&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">            &lt;name&gt;zookeeper.session.timeout&lt;/name&gt;</span><br><span class="line">            &lt;value&gt;60000000&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">            &lt;name&gt;dfs.support.append&lt;/name&gt;</span><br><span class="line">            &lt;value&gt;true&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></li><li><p>同步分发hbase到所有的服务器</p></li></ol><h2 id="启动集群服务"><a href="#启动集群服务" class="headerlink" title="启动集群服务"></a>启动集群服务</h2><ol><li><p>集群启动zookeeper服务</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ssh_all_group.sh &quot;/usr/local/zookeeper/bin/zkServer.sh start&quot;</span><br></pre></td></tr></table></figure></li><li><p>集群启动hadoop服务</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ssh_all_group.sh &quot;/usr/local/hadoop/sbin/start-all.sh&quot;</span><br></pre></td></tr></table></figure></li><li><p>启动hbase服务</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/hbase/bin/start-hbase.sh</span><br></pre></td></tr></table></figure></li><li><p>集群启动成功的标志：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Master java服务列表</span><br><span class="line">13969 Jps</span><br><span class="line">8083 NameNode</span><br><span class="line">8788 SecondaryNameNode</span><br><span class="line">13782 HMaster   //hbase master进程</span><br><span class="line">16855 DataNode</span><br><span class="line">7656 ResourceManager</span><br><span class="line">524 Main</span><br><span class="line">11598 QuorumPeerMain //zookeeper 进程</span><br><span class="line"></span><br><span class="line">Slave java服务列表</span><br><span class="line">3616 DataNode</span><br><span class="line">19952 QuorumPeerMain //zookeeper 进程</span><br><span class="line">22102 HRegionServer //hbase slave进程</span><br><span class="line">3751 NodeManager</span><br><span class="line">22346 Jps</span><br><span class="line">4203 ResourceManager</span><br></pre></td></tr></table></figure><p> 这时出现问题：有的slave服务器并不能启动HRegionServer。原因是因为服务器之间时间不同步。</p><p> 查看服务器时间命令： date</p><p> 参考<a href="https://blog.csdn.net/liu857279611/article/details/70789504" target="_blank" rel="noopener">https://blog.csdn.net/liu857279611/article/details/70789504</a> 设置服务器时间同步</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root权限下执行：</span><br><span class="line">1. 安装ntpdate工具</span><br><span class="line">yum -y install ntp ntpdate</span><br><span class="line">2. 设置系统时间与网络时间同步</span><br><span class="line">ntpdate cn.pool.ntp.org</span><br><span class="line">3. 将系统时间写入硬件时间</span><br><span class="line">hwclock --systohc</span><br></pre></td></tr></table></figure></li><li><p>启动hbase shell验证</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/hbase/bin/hbase shell</span><br></pre></td></tr></table></figure><p> <img src="/images/2019-06-23-hadoop_zookeeper_hbase_setup/hbase_shell.png" alt="image_size"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop ZooKeeper初步</title>
      <link href="/2019/06/21/2019-06-21-hadoop_zookeeper/"/>
      <url>/2019/06/21/2019-06-21-hadoop_zookeeper/</url>
      
        <content type="html"><![CDATA[<h2 id="Hadoop-zookeeper"><a href="#Hadoop-zookeeper" class="headerlink" title="Hadoop zookeeper"></a>Hadoop zookeeper</h2><p>zookeeper是Hadoop的分布式协调服务，可以用来构建一般的分布式应用。</p><p>写分布式应用的主要困难在于会出现”部分失败“。当一条消息在网络中的两个节点之间传送时，如果出现网络错误，发送者无法知道接收者是否已经收到这条消息。接收者可能在网络出错之前已经收到了这条消息，也有可能没收到，或者接收者进程已经死掉。发送者能够获得真实情况的唯一途径就是重新连接接收者，并发送询问。这种情况就是部分失败。</p><p>部分失败是分布式系统固有的特征。zookeeper提供一组工具，使你的构建分布式应用时能够对部分失败进行正确处理。</p><a id="more"></a> <!-- 摘要 --><p>zookeeper具有以下特点：</p><ul><li>zookeeper是简单的。 zookeeper的核心是一个精简的文件系统，提供一些简单的操作和一些额外的抽象操作（如排序和通知）</li><li>zookeeper是富有表现力的。 zookeeper的基本操作是一组丰富的”构件“（building block），可用于实现多种协调数据结构和协议。</li><li>zookeeper具有高可用性。</li><li>zookeeper采用松耦合交互方式。在zookeeper支持的交互过程中，参与者不需要彼此了解。一个进程可以在zookeeper中留下一条信息，在该进程结束后，另外一个进程还可以读取这条消息。</li><li>zookeeper是一个资源库，提供了一个通用协调模式实现方法的开源共享库，使程序员免于写这类通用的协议。</li></ul><p>zookeeper的节点为什么设置为基数：<br>zookeeper有这样一个特性：集群中只要有过半的机器是正常工作的，那么整个集群对外就是可用的。如果有2个zookeeper，那么只要有1个死了zookeeper就不能用了，因为1没有过半，所以2个zookeeper的死亡容忍度为0；同理，要是有3个zookeeper，一个死了，还剩下2个正常的，过半了，所以3个zookeeper的容忍度为1。</p><h2 id="zookeeper的安装与运行"><a href="#zookeeper的安装与运行" class="headerlink" title="zookeeper的安装与运行"></a>zookeeper的安装与运行</h2><p>首次尝试使用zookeeper，最简单的方式是在一台zookeeper服务器上以独立模式运行。</p><ol><li>从apache官网下载zookeeper稳定版，上传至服务器nn1。将zookeeper包发送至所有的节点（zookeeper机器）上。</li><li>在所有zookeeper机器上，将压缩包解压至/usr/local/。（可以创建软链接）将/usr/local/zookeeper的权限改为770</li><li><p>修改每个机器上zookeeper的配置：</p><ul><li><p>zookeeper/bin是执行脚本所在的位置</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- zkCleanup.sh</span><br><span class="line">-- zkcli.cmd</span><br><span class="line">-- zkcli.sh</span><br><span class="line">-- zkEnv.cmd</span><br><span class="line">-- zkEnv.sh</span><br><span class="line">-- zkServer.cmd</span><br></pre></td></tr></table></figure></li><li><p>zookeeper/conf是配置文件目录</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- configuration.xsl</span><br><span class="line">-- log4j.properties</span><br><span class="line">-- zoo_sample.cfg #这个是重要的配置文件</span><br></pre></td></tr></table></figure><p>可将zookeeper的可执行脚本文件添加进命令行路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export ZOOKEEPER_HOME=/usr/local/zookeeper-3.4.9</span><br><span class="line">export PATH=$PATH:$ZOOKEEPER_HOME/bin</span><br></pre></td></tr></table></figure><p>在运行zookeeper服务之前，需要创建配置文件，习惯上命名为/zookeeper/conf/zoo.cfg。这是一个标注Java属性文件。常用的配置文件内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ticktime=2000 #指定zookeeper中的基本时间单元（ms） </span><br><span class="line">dataDir=/data/ #数据目录，zookeeper存储持久数据的本地文件系统位置</span><br><span class="line">clientPort=2181 #client提供服务的端口号，zookeeper监听客户端连接的端口</span><br><span class="line">server.1=nn0.hadoop:2888:3888 #server提供服务的端口号</span><br><span class="line">server.2=nn1.hadoop:2888:3888</span><br><span class="line">server.3=s1.hadoop:2888:3888</span><br></pre></td></tr></table></figure></li></ul></li><li><p>配置好conf之后，我们可以启动一个本地zookeeper服务器。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@nn1 zookeeper]# zkServer.sh start</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /usr/local/zookeeper/bin/../conf/zoo.cfg</span><br><span class="line">Starting zookeeper ... STARTED</span><br></pre></td></tr></table></figure><p> 同时可以用以下命令来监听端口：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo ruok | telnet localhost 2181</span><br><span class="line"></span><br><span class="line">第一次运行时出现问题，connection problem</span><br></pre></td></tr></table></figure></li><li><p>在每个机器上创建/data目录，并把权限改成hadoop:hadoop</p></li><li>在新建的/data目录下生成myid文件（注意这个只能手动在每个机器的/data目录下创建，不能使用批量脚本）</li><li><p>给每个机器设置好环境变量：<br> env 查看当前shell环境下已有的环境变量<br> 1） /etc/profile 全局环境变量，针对整个系统<br> 2） ~/.bash_profile 当前用户的环境变量<br> 加载顺序是先加载系统，再加载自己的环境变量。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">使用hadoop软件生态环境所使用的环境变量</span><br><span class="line">export HADOOP_HOME=/usr/local/hadoop</span><br><span class="line">export HADOOP_COMMON_HOME=$&#123;HADOOP_HOME&#125;</span><br><span class="line">export HADOOP_HDFS_HOME=$&#123;HADOOP_HOME&#125;</span><br><span class="line">export HADOOP_MAPRED_HOME=$&#123;HADOOP_HOME&#125;</span><br><span class="line">export HADOOP_YARN_HOME=$&#123;HADOOP_HOME&#125;</span><br><span class="line">export HADOOP_CONF_DIR=$&#123;HADOOP_HOME&#125;/etc/hadoop</span><br><span class="line">export HDFS_CONF_DIR=$&#123;HADOOP_HOME&#125;/etc/hadoop</span><br><span class="line">export YARN_CONF_DIR=$&#123;HADOOP_HOME&#125;/etc/hadoop</span><br><span class="line">export LD_LIBRARY_PATH=$HADOOP_HOME/lib/native:/usr/lib64</span><br><span class="line">   </span><br><span class="line">#这个现在还没有安装</span><br><span class="line">export HBASE_HOME=/usr/local/hbase</span><br><span class="line">export HIVE_HOME=/usr/local/hive</span><br></pre></td></tr></table></figure><p> 将上述环境变量导入每台机器。可以通过将profile和op.sh批量复制到各台机器上然后再批量执行op.sh。注意要给op.sh加执行权限。</p></li><li><p>在每个机器上启动zookeeper服务并查看启动结果</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1. 注意要使用免密登录，要注意用户权限的问题</span><br><span class="line">2. 批量操作</span><br><span class="line"></span><br><span class="line">% [hadoop@nn1 ssh_learning]$ ./ssh_all.sh /usr/local/zookeeper/bin/zkServer.sh start</span><br><span class="line"></span><br><span class="line"># 报错信息，找不到zoo.cfg文件，说明之前没有更改zoo.cfg</span><br><span class="line">ssh hadoop@s1.hadoop &quot;/usr/local/zookeeper/bin/zkServer.sh start&quot;</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /usr/local/zookeeper/bin/../conf/zoo.cfg</span><br><span class="line">grep: /usr/local/zookeeper/bin/../conf/zoo.cfg: No such file or directory</span><br><span class="line">mkdir: cannot create directory ‘’: No such file or directory</span><br><span class="line">Starting zookeeper ... /usr/local/zookeeper/bin/zkServer.sh: line 149: /zookeeper_server.pid: Permission denied</span><br><span class="line">FAILED TO WRITE PID</span><br><span class="line">FAIL</span><br><span class="line"></span><br><span class="line"># 将zoo.cfg导入后通过</span><br><span class="line">ssh hadoop@s1_hadoop /usr/local/zookeeper/bin/zkServer.sh</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /usr/local/zookeeper/bin/../conf/zoo.cfg</span><br><span class="line">Usage: /usr/local/zookeeper/bin/zkServer.sh &#123;start|start-foreground|stop|restart|status|upgrade|print-cmd&#125;</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></li></ol><ul><li>查看java程序进程 jps 或查看进程命令 ps aux | grep zookeeper</li><li>查看zk输出日志 /data/zookeeper.out</li><li>/data/zookeeper_server.pid 是存储当前zk服务的进程id</li></ul><h2 id="zookeeper的使用"><a href="#zookeeper的使用" class="headerlink" title="zookeeper的使用"></a>zookeeper的使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ZK服务命令</span><br><span class="line">% zkServer.sh status 查看机器zk运行的状态</span><br><span class="line">% zkServer.sh stop 整体停止服务</span><br><span class="line">% zkServer.sh restart 重启zk服务</span><br><span class="line">% zkServer.sh status 查看zk服务状态</span><br><span class="line"></span><br><span class="line">ZK客户端命令</span><br><span class="line">% zkCli.sh -server 启动zkclient，并连接集群</span><br><span class="line">（1）显示根目录下文件： ls</span><br><span class="line">（2）显示根目录下文件：ls2 查看当前节点数据并能看到更新次数等数据</span><br><span class="line">（3）创建文件，并设置初始内容：create /zk &quot;test&quot;创建一个新的znode节点”zk“ 以及与它关联的字符串</span><br><span class="line">（4）获取文件内容：get /zk 确认znode是否包含我们所创建的字符串</span><br><span class="line">（5）修改文件内容：set /zk &quot;zkbzk&quot; 对zk所关联的字符串进行设置</span><br><span class="line">（6）删除文件：delete /zk 将刚才创建的znode删除</span><br><span class="line">（7）退出客户端： quit</span><br><span class="line">（8）帮助命令：help</span><br></pre></td></tr></table></figure><h2 id="ZooKeeper-示例"><a href="#ZooKeeper-示例" class="headerlink" title="ZooKeeper 示例"></a>ZooKeeper 示例</h2><ul><li>一组服务器用于为客户端提供某种服务。我们希望每个客户端都能找到其中一台服务器。那么问题在于如何维护这组服务器的成员列表。</li></ul><p>ZooKeeper中的组成员关系</p><p>将zk看做一个具有高可用性特征的文件系统。该文件系统中没有文件和目录，而是统一使用”节点“（node），znode。znode既可以作为保存数据的容器（如文件），也可以作为保存其他znode的容器（目录）。所有的znode构成一个层次化的命名空间。</p><p>创建一个以组名为节点名的znode为父节点，然后以组成员名（服务器名）为节点名来创建作为子节点的znode。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop Yarn 初步</title>
      <link href="/2019/06/21/2019-06-21-hadoop_yarn/"/>
      <url>/2019/06/21/2019-06-21-hadoop_yarn/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是YARN"><a href="#什么是YARN" class="headerlink" title="什么是YARN"></a>什么是YARN</h2><p>YARN = Yet Another Resource Negotiator 是Hadoop集群资源管理系统。YARN在Hadoop2被引入，最初是为了改善MapReduce的实现，但具有足够的通用性，同样可以支持其他的分布式计算模式。</p><p>YARN提供<strong>请求</strong>和<strong>使用</strong>集群资源的API，但这些API很少直接用于用户代码。用户代码中的分布式计算框架提供的更高层API，这些API建立在YARN之上并向用户隐藏了资源管理细节。</p><a id="more"></a> <!-- 摘要 --><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">YARN的应用</span><br><span class="line"></span><br><span class="line">Application层  MapReduce -- Spark -- Tez -- ...</span><br><span class="line">Compute层      YARN</span><br><span class="line">Storage层      HDFS 和 HBase</span><br></pre></td></tr></table></figure><h2 id="YARN应用运行机制"><a href="#YARN应用运行机制" class="headerlink" title="YARN应用运行机制"></a>YARN应用运行机制</h2><p>YARN通过两类长期运行的守护进程提供自己的核心服务:</p><ul><li>管理集群上资源使用的资源管理器（resource manager）</li><li>运行在集群中所有节点上且能够启动和监控容器的节点管理器（node manager）</li></ul><p>容器用于执行特定应用程序的进程，每个容器都有资源限制（内存、CPU等）。一个容器可以是一个Unix进程，也可以是一个Linux cgroup，取决于YARN的配置。</p><p><img src="/images/2019-06-21-hadoop_yarn/yarn_flow_chart.png" alt="yarn_flow_chart"></p><h3 id="运行机制："><a href="#运行机制：" class="headerlink" title="运行机制："></a>运行机制：</h3><ol><li>客户端联系资源管理器，要求一个application master进程。</li><li>资源管理器找到一个容器来启动application master的节点管理器。</li><li>application master一旦运行起来之后能做什么依赖于应用本身。YARN本身不会为应用的各部分彼此之间的通信提供任何手段。大多数重要的YARN应用使用某种形式的远程通信机制来向客户端传递状态更新和返回结果，但通信机制都是专属与各应用的。</li></ol><h4 id="资源请求："><a href="#资源请求：" class="headerlink" title="资源请求："></a>资源请求：</h4><p>YARN有一个灵活的资源请求模型。 YARN允许一个应用为所申请的容器指定本地限制。（本地化对于确保分布式数据处理算法高效实用集群带宽非常重要）。</p><p>通常，当一个容器用于处理HDFS数据块时，应用将会向这样的节点申请容器：存储该数据块三个复本的节点，或是存储这些复本的机架中的一个节点。</p><h4 id="应用生命期："><a href="#应用生命期：" class="headerlink" title="应用生命期："></a>应用生命期：</h4><p>YARN应用的生命周期差异性很大，按照应用到用户运行的作业之间的映射关系对应用进行分类。</p><ol><li>一个用户作业对应一个application master。这是MApReduce采用的方式。</li><li>作业的每个工作流或每个用户对话对应一个应用。比第一个效率高，因为容器可以在作业之间重用，并且可能缓存作业之间的中间数据。Spark采用的方式。</li><li>多个用户共享一个长期运行的应用。</li></ol><h4 id="构建YARN应用"><a href="#构建YARN应用" class="headerlink" title="构建YARN应用"></a>构建YARN应用</h4><p>从无到有编写一个YARN应用是一件相当复杂的事情。很多应用都简化了YARN的开发。当一个应用有着复杂的调度需求的时候，YARN项目自身一部分的distributed shell应用为如何写YARN应用做了一个示范。</p><h4 id="YARN的好处"><a href="#YARN的好处" class="headerlink" title="YARN的好处"></a>YARN的好处</h4><p>可扩展性； 可用性；利用率；多租户</p><h3 id="YARN中的调度"><a href="#YARN中的调度" class="headerlink" title="YARN中的调度"></a>YARN中的调度</h3><p>调度选项： </p><ul><li>FIFO调度器：不需要任何配置，但是不适合共享集群。大的应用会占用集群中的所有资源。共享集群中更适合使用容量调度或公平调度。</li><li>容量调度器：预留一定量的资源，一个独立的专门队列保证小作业一提交就可以启动。</li><li>公平调度器：不需要预留一定量的资源，调度器在所有运行的作业之间动态平衡资源。</li></ul><h2 id="YARN的操作"><a href="#YARN的操作" class="headerlink" title="YARN的操作"></a>YARN的操作</h2><h3 id="YARN的主要配置"><a href="#YARN的主要配置" class="headerlink" title="YARN的主要配置"></a>YARN的主要配置</h3><p>文件路径 /usr/local/hadoop/etc/hadoop/</p><ol><li>yarn-site.xml</li><li>yarn-env.sh</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">yarn-site.xml</span><br><span class="line">&lt;property&gt; </span><br><span class="line">    &lt;name&gt;yarn.scheduler.minimum-allocation-vcores&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;1&lt;/value&gt;</span><br><span class="line">    &lt;description&gt;单个任务可申请的最小虚拟CPU数&lt;/description&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;property&gt; </span><br><span class="line">    &lt;name&gt;yarn.scheduler.maximum-allocation-vcores&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;2&lt;/value&gt;</span><br><span class="line">    &lt;description&gt;单个任务可申请的最大虚拟CPU数，此参数对应yarn.nodemanager.resource.cpu-vcores,建议最大为一个物理CPU的数量&lt;/description&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;property&gt; </span><br><span class="line">    &lt;name&gt;yarn.nodemanager.resource.memory-mb&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;1024&lt;/value&gt;</span><br><span class="line">    &lt;description&gt;该节点上可分配的物理内存总量&lt;/description&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;property&gt; </span><br><span class="line">    &lt;name&gt;yarn.nodemanager.resource.cpu-vcores&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;3&lt;/value&gt;</span><br><span class="line">    &lt;description&gt;该节点上YARN可以使用的虚拟CPU个数，一个物理CPU对应3个虚拟CPU&lt;/description&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;property&gt; </span><br><span class="line">    &lt;name&gt;yarn.scheduler.maximum-allocation-mb&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;43008&lt;/value&gt;</span><br><span class="line">    &lt;description&gt;单个任务可申请的最多物理内存量&lt;/description&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yarn-env.sh</span><br><span class="line"></span><br><span class="line"># resource manager 内存</span><br><span class="line">export YARN_RESOURCEMANAGER_HEAPSIZE=512</span><br><span class="line"># nodemanager 内存</span><br><span class="line">export YARN_NODEMANAGER_HEAPSIZE=256</span><br></pre></td></tr></table></figure><h3 id="启动YARN"><a href="#启动YARN" class="headerlink" title="启动YARN"></a>启动YARN</h3><ol><li><p>首先在各机器上启动zookeeper </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">% /usr/local/zookeeper/zkServer.sh start</span><br></pre></td></tr></table></figure></li><li><p>在nn1上启动yarn。 start-yarn.sh</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">报错找不到JAVA_HOME，这是因为在hadoop-env.sh中环境变量设置不正确</span><br><span class="line">[hadoop@nn1 hadoop]$ start-yarn.sh</span><br><span class="line">starting yarn daemons</span><br><span class="line">resourcemanager running as process 7168. Stop it first.</span><br><span class="line">localhost: Error: JAVA_HOME is not set and could not be found.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">更改：/usr/local/hadoop/etc/hadoop/hadoop-env.sh</span><br><span class="line">export JAVA_HOME=$&#123;JAVA_HOME&#125;</span><br><span class="line">改为</span><br><span class="line">export JAVA_HOME=/usr/java/.... </span><br><span class="line"></span><br><span class="line">[hadoop@nn1 ~]$ start-yarn.sh</span><br><span class="line">starting yarn daemons</span><br><span class="line">resourcemanager running as process 7168. Stop it first.</span><br><span class="line">localhost: starting nodemanager, logging to /usr/local/hadoop-2.9.2/logs/yarn-hadoop-nodemanager-nn1.hadoop.out</span><br></pre></td></tr></table></figure></li></ol><p>查看各节点的进程信息是否有resourceManager和nodeManager</p><p>TBC 出现问题</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSH 远程登录</title>
      <link href="/2019/06/21/2019-06-21-ssh_remote_access/"/>
      <url>/2019/06/21/2019-06-21-ssh_remote_access/</url>
      
        <content type="html"><![CDATA[<p>ssh远程登录连接<br><a id="more"></a> <!-- 摘要 --></p><h2 id="ssh-登录方式"><a href="#ssh-登录方式" class="headerlink" title="ssh 登录方式"></a>ssh 登录方式</h2><h4 id="1-ssh密码登录"><a href="#1-ssh密码登录" class="headerlink" title="1. ssh密码登录:"></a>1. ssh密码登录:</h4><ul><li>客户端连接上服务器之后，服务器将自己的公钥传输给客户端</li><li>客户端输入服务器密码，用公钥加密之后传输给服务器</li><li>服务器根据自己的私钥解锁密码，如果密码正确就让客户端登录</li></ul><h4 id="2-公钥认证登录："><a href="#2-公钥认证登录：" class="headerlink" title="2. 公钥认证登录："></a>2. 公钥认证登录：</h4><p><strong>一定要明白客户端与服务器之间的连接是通过公钥和私钥实现认证登录的。</strong><br>客户端相当于A端，服务器相当于B端。A、B要实现相互认证就要通过一组公私钥。<br>（1）客户端即A端生成RSA公钥和私钥。<br>在~/.ssh文件夹下，通过ssh-keygen -t rsa命令生成一组公私钥。Id_rsa为私钥，id_rsa.pub为公钥<br>（2）客户端将自己的公钥存放在服务器。在生成了公私钥之后要实现AB两端的交互认证，需要A端保留自己的私钥，然后把公钥存放在B端。<br>在B端的.ssh目录下会有authorized_keys+know_hosts这两个文件<br>Authorized_keys用来存放远程免密登录的公钥。<br>known_hosts用来存放已知的主机公钥清单，作为A端和B端都会自动生成这个文件，每次和远端服务器进行一次免密ssh连接之后就会在这个文件的最后追加对方主机的信息（不重复）<br>以上通过scp将内容写进对方的文件中<br>命令: scp -p ~/.ssh/id_rsa.pub root@<remote_ip>:/root/.ssh/authorized_keys<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Scp: secure copy 用于linux下进行远程拷贝文件的命令。</span><br><span class="line">常用命令参数 -p 保留原文件的修改时间，访问时间和访问权限</span><br><span class="line">   </span><br><span class="line">需要注意的是：</span><br><span class="line">这是文件和目录的权限，要保证能够读写读写的话最低要600</span><br><span class="line">（写权限4，读权限2， 执行权限1. 三个数字分别对应文件所属主用户，文件所属组用户和其他用户）</span><br><span class="line">设置authorized_keys权限 600</span><br><span class="line">设置.ssh目录权限700</span><br><span class="line">   </span><br><span class="line">如果嫌每次连接的时候很麻烦，我们可以利用ssh的用户配置文件config来管理多个ssh会话。ssh的用户配置文件是放在.ssh文件夹里，配置写法如下</span><br><span class="line">Host 别名</span><br><span class="line">HostName 主机ip, 主机ip可以是保存在/etc/hosts中的名字</span><br><span class="line">Port 端口 （这个可能不用配置）</span><br><span class="line">User 用户名</span><br><span class="line">IdentityFile 密钥文件的路径</span><br></pre></td></tr></table></figure></remote_ip></p><p>两台服务器交互验证的细节如下：<br>（1）客户端请求连接服务器，服务器将一个随机字符串发送给客户端<br>（2）客户端根据自己的私钥加密这个随机字符串之后再发送给服务器<br>（3）服务器接受到加密后的字符串之后用公钥解密，如果正确就让客户端登录，否则拒绝。这样就不用使用密码了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">出现问题：</span><br><span class="line">ssh connection refused 一般来说是因为服务器没有安装ssh服务</span><br><span class="line">如果确认安装，那么大概率是因为断线了</span><br><span class="line">找到/etc/ssh/sshd_config文件。</span><br><span class="line">将ClientAliveInterval 0改为30，表示客户端每隔多少秒向服务器发送一个心跳数据</span><br><span class="line">将ClientAliveCountMax 3改为86400表示客户端多少秒没有响应，服务器自动切断连接。</span><br><span class="line">之后重启sshd服务 service sshd restart</span><br></pre></td></tr></table></figure></p><h2 id="出现的问题"><a href="#出现的问题" class="headerlink" title="出现的问题"></a>出现的问题</h2><ul><li>client与server0的连接经常中断，但是与server1等其他服务器连接很稳定。因为我使用了桥接网络，所以需要检查是不是server的ip出现了冲突。因为批量操作，一般需要将server和client的ip设置为静态ip，所以经常会出现网络内ip冲突的问题。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟机网络的设置模式</title>
      <link href="/2019/06/21/2019-06-21-virtual_network/"/>
      <url>/2019/06/21/2019-06-21-virtual_network/</url>
      
        <content type="html"><![CDATA[<h2 id="虚拟机网络设置"><a href="#虚拟机网络设置" class="headerlink" title="虚拟机网络设置"></a>虚拟机网络设置</h2><p>以Virtual Box为例，VirtualBox有4种网络模式：NAT， Bridged Adapter, Internal, Host-only。</p><a id="more"></a> <!-- 摘要 --><h2 id="NAT-lt-网络地址转换模式-gt"><a href="#NAT-lt-网络地址转换模式-gt" class="headerlink" title="NAT &lt;网络地址转换模式&gt;"></a>NAT &lt;网络地址转换模式&gt;</h2><p>VirtualBox中的虚拟机并不真实存在于网络中，宿主机和宿主机网络中的任何主机都不能直接访问虚拟机，<strong>各虚拟主机也互不相通</strong>。虚拟机能够访问宿主机，以及宿主机能访问任何主机。虚拟机访问网络是先通过VirtualBox转换后在发送出去，数据接收也是先由VirtualBox接收后再转发给虚拟主机。<br><strong>对外，虚拟机的ip与宿主机一致。</strong></p><h2 id="Bridged-Adapter-lt-桥接模式-gt"><a href="#Bridged-Adapter-lt-桥接模式-gt" class="headerlink" title="Bridged Adapter &lt;桥接模式&gt;"></a>Bridged Adapter &lt;桥接模式&gt;</h2><p>虚拟机通过VirtualBox桥接到宿主机的一个网卡中，就像真是存在于宿主机网络中的一台主机一样。<strong>桥接模式相当于虚拟机与宿主机以独立主机的身份连接在同一个网段内，ip对局域网路由可见。虚拟机与宿主机ip地址不同。</strong></p><h2 id="Internal-lt-内部模式-gt"><a href="#Internal-lt-内部模式-gt" class="headerlink" title="Internal &lt;内部模式&gt;"></a>Internal &lt;内部模式&gt;</h2><p>虚拟机与外界完全分开，虚拟机与宿主机网络不能互通。默认不分配ip，需要自己手动设置。</p><h2 id="Host-only-Adapter-lt-宿主机模式-gt"><a href="#Host-only-Adapter-lt-宿主机模式-gt" class="headerlink" title="Host-only Adapter &lt;宿主机模式&gt;"></a>Host-only Adapter &lt;宿主机模式&gt;</h2><p>VirtualBox在宿主机中虚拟一个host-only网卡，然后把虚拟机连接在host-only网卡上。这种情况下<strong>宿主机上所有的虚拟机是可以相互通信的，但是虚拟机和真实的网络是被隔离开的。</strong></p><p>虚拟机与主机的关系：默认不能相互访问，双方不属于同一ip段。host-only网卡默认ip段为192.168.56.X 子网掩码为255.255.255.0。</p><p>虚拟机与网络主机的关系：默认不能相互访问</p><p>虚拟机之间可以相互访问，处于同一网段。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VirtualMachine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NUSRI专利申请培训</title>
      <link href="/2019/06/11/2019-06-11-NUSRI%E4%B8%93%E5%88%A9%E5%9F%B9%E8%AE%AD/"/>
      <url>/2019/06/11/2019-06-11-NUSRI%E4%B8%93%E5%88%A9%E5%9F%B9%E8%AE%AD/</url>
      
        <content type="html"><![CDATA[<h2 id="技术交底书（Invention-Disclosure-Preparation-guide-note）"><a href="#技术交底书（Invention-Disclosure-Preparation-guide-note）" class="headerlink" title="技术交底书（Invention Disclosure Preparation guide/note）"></a>技术交底书（Invention Disclosure Preparation guide/note）</h2><ul><li>专利保护的是技术方案，专利文件是<strong>定义</strong>发明创造的一个文件，并赋予专利发明人相关权利。</li><li>专利是一个交换：<ol><li>贡献给公众技术方案（通过说明书，和附图，摘要）。主张教会别人，让人能看懂。</li><li>主张专利保护权益（通过权利要求书）。</li></ol></li><li>专利要呈现：<strong>新颖性Novelty</strong>，<strong>创造性Inventiveness（非显而易见性）</strong>，实用性</li><li>关于技术方案的描述要包含：<ol><li>具体实施方案详细说明（基本要求一个人按照技术交底书能够复现该技术方案，需要提供丰富的内容）</li><li>结构、功能、方法</li><li>附图（黑色线图）</li></ol></li><li>在专利申请之前，如果以任何形式为公众所知，都会影响新颖性：Publications。公开的东西就已经是公开的了，拿不回来。</li></ul><a id="more"></a> <!-- 摘要 --><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">专利文件结构</span><br><span class="line">--著录项目</span><br><span class="line">    --申请人、发明人</span><br><span class="line">    --相关申请（优先权等）</span><br><span class="line">--说明书</span><br><span class="line">    --名称</span><br><span class="line">    --技术领域</span><br><span class="line">    --背景技术</span><br><span class="line">    --发明概要</span><br><span class="line">    --（目的）</span><br><span class="line">    --优点</span><br><span class="line">    --附图说明</span><br><span class="line">    --详细说明</span><br><span class="line">--权利要求书</span><br><span class="line">--附图</span><br><span class="line">--摘要</span><br></pre></td></tr></table></figure><h3 id="新颖性"><a href="#新颖性" class="headerlink" title="新颖性"></a>新颖性</h3><ul><li>在世界范围内，该专利文件中的权利要求书所要求的内容与所有公开文件进行对比。由专利审查员以专利文件提交日为基准进行专利检索。</li><li>在比对过程中，新颖性指的是：在该专利要求书中要求的技术特征没有在对比文件中找到。核心为：有没有不同的地方。</li></ul><h3 id="创造性"><a href="#创造性" class="headerlink" title="创造性"></a>创造性</h3><ul><li>先承认技术方案有新颖性，创造性指的是：不同的程度。只有非显而易见的特征才能被认为是创造性。具有一定的抽象性。</li><li>一般认为以下几类”不同“会被认为不具备创造性：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在不改变结构的情况下：</span><br><span class="line">1. 单纯的数量增加</span><br><span class="line">2. 单纯的材料替换（已知材料）</span><br><span class="line">3. 单纯的尺度变换</span><br></pre></td></tr></table></figure><ul><li>不可授予专利的发明创造主题：<ol><li>纯粹的科学发现（发明创造是不存在的东西而造出来，科学发现是客观存在的但是首次发现的，唯物主义论调）</li><li>智力活动方法（理论公式计算，模拟推导。除商业方法和计算机软件，在有些国际是能够申请专利，较为开放。在美国，近几年大数据相关等主题会归类在不可授予专利的主题）</li><li>极大地影响人的生命的方法</li></ol></li></ul><h3 id="专利文件理解、技术方案对比的常见误区："><a href="#专利文件理解、技术方案对比的常见误区：" class="headerlink" title="专利文件理解、技术方案对比的常见误区："></a>专利文件理解、技术方案对比的常见误区：</h3><ol><li>只读权利要求书 Only look at the claims (info disclosed but not claimed - may still be relevant)</li><li>附图不同 Drawings are different</li><li>有图无问 Features not explained in the text but shown in the drawings</li><li>有文无图 Features not shown in the drawings but mentioned in the text</li><li>字面理解 Literal meanings of the feature</li><li>使用不同技术术语描述的相同技术特征 Using different terms</li><li>This patent itself is not patentable</li></ol><h2 id="Q-amp-A："><a href="#Q-amp-A：" class="headerlink" title="Q&amp;A："></a>Q&amp;A：</h2><p>有限次重复不具备新颖性：</p><ol><li>有文件指示某条路可以走通，只是你现在没有拿到它，那么你的工作只是沿着这条路走，就不具备新颖性，一般会认为”本领域人员进行不具备创造性的劳动就可以得到的结果“</li><li>如果有文件指示该条路不通，但你走通了，这个就具有新颖性</li></ol>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 专利 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS 7 安装图像化界面使得能够使用浏览器</title>
      <link href="/2019/06/06/2019-06-06-CentOS7_GUI/"/>
      <url>/2019/06/06/2019-06-06-CentOS7_GUI/</url>
      
        <content type="html"><![CDATA[<p>CentOS 7 图形化界面安装<br><a id="more"></a> <!-- 摘要 --><br>参考博客：<a href="https://www.cnblogs.com/ding2016/p/6649789.html?utm_source=itdadao&amp;utm_medium=referral" target="_blank" rel="noopener">CentOS7/RHEL7最小化系统安装gnome图形界面</a></p><ol><li>测试环境，一台安装了最小化系统的CenOS7虚拟机</li><li><p>命令行查看需要安装的软件包</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%yum grouplist</span><br><span class="line">在Available Environment Group中，选择显示GNOME Desktop</span><br></pre></td></tr></table></figure></li><li><p>安装软件包</p><pre><code> %yum groupinstall -y &quot;GNOME Desktop&quot;</code></pre></li><li><p>重启登录reboot</p></li><li>（hdfs操作）在命令行中启动hadoop守护程序</li><li>命令行输入startx或者init5 命令，进入图形化界面</li><li>使用firefox浏览器进行hadoop相关组件的访问。</li><li><p>注意不要启动默认图形界面，还是用命令行比较好控制。</p><p> 启动hadoop namenode Web端口查看</p><p> <img src="/images/2019-06-06-CentOS7_GUI/hadoop_namenode_50070.png" alt="hadoop_namenode_50070"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CentOS7 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop HDFS 初始与操作</title>
      <link href="/2019/06/06/2019-06-06-hadoop_hdfs/"/>
      <url>/2019/06/06/2019-06-06-hadoop_hdfs/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是HDFS"><a href="#什么是HDFS" class="headerlink" title="什么是HDFS"></a>什么是HDFS</h2><p>什么是HDFS（Hadoop Distributed File System）？当数据集的大小超过一台独立的物理计算机的存储能力时，就有必要对它进行分区（partition）并存储到若干台单独的计算机上。管理网络中多态计算机存储的文件系统成为分布式文件系统（distributed filesystem）。HDFS是Hadoop自带的分布式文件系统。</p><a id="more"></a> <!-- 摘要 --><h3 id="数据块"><a href="#数据块" class="headerlink" title="数据块"></a>数据块</h3><p>HDFS采用128MB的数据块。其目的是为了最小化寻址开销。如果块足够大，从磁盘传输数据的时间会明显大于定位这个快开始位置所需要的时间。因此，传输一个由多个快组成的大文件的时间取决于磁盘传输速率。</p><h3 id="namenode和datanode"><a href="#namenode和datanode" class="headerlink" title="namenode和datanode"></a>namenode和datanode</h3><ul><li>HDFS集群有两类节点以<strong>管理节点（namenode）-工作节点（datanode）</strong>模式运行。</li><li>namenode管理文件系统的命名空间。它维护文件系统树和整颗树内的所有文件和目录。这些信息以两个文件的形式永久保存在本地磁盘：命名空间镜像文件和编辑日志文件。</li><li>client代表用户通过namenode与datanode进行交互来访问整个文件系统。客户端提供一个类似于POSIX（可一直操作系统界面）的文件系统接口。用户在编程的时候无需知道namenode和datanode也可实现其功能。</li><li>datanode是文件系统的工作节点。他们根据需要存储并检索数据块，并定期向namenode发送他们所存储的块的列表。</li><li>namenode用来控制datanode的块来重建文件。如果没有namenode，文件系统将无法使用，甚至运行namenode服务的机器出现损坏，文件系统上的所有文件将会丢失，因为一个文件被分成了多个数据块存储在多个datanode上，我们并不知道如何根据datanode的数据块来重建文件。因此要对namenode实现容错。</li></ul><h3 id="HDFS的高可用性"><a href="#HDFS的高可用性" class="headerlink" title="HDFS的高可用性"></a>HDFS的高可用性</h3><p>在hadoop2中，实现HDFS的高可用性，即实现了namenode容错快速重建。</p><ol><li>联合使用多个文件系统备份namenode元数据。</li><li>使用备用namenode创建监测点防止数据丢失。</li><li>hadoop2实现（active-standby）namenode。即当活动namenode失效，备用namenode就会接管它的任务开始服务客户端。但需要datanode同时向两个namenode发送数据块处理报告。</li></ol><h2 id="Hadoop模式配置"><a href="#Hadoop模式配置" class="headerlink" title="Hadoop模式配置"></a>Hadoop模式配置</h2><p>参考Hadoop权威指南附录A</p><p>Hadoop的各个组件都可以利用xml文件进行配置，放置在hadoop根目录/etc/hadoop/。</p><ul><li>core-site.xml文件用于配置通用属性</li><li>hdfs-site.xml文件用于配置HDFS属性</li><li>mapred-site.xml文件用于配置MapReduce属性</li><li>yarn-site.xml文件用于配置YARN属性。</li></ul><p>Hadoop有三种运行模型：</p><ul><li>独立模式：无需运行任何守护进程，所有程序都在同一个JVM上执行。在独立模式下测试和调试MapReduce程序很方便，因此该模式在开发阶段比较合适</li><li>伪分布模式：Hadoop守护进程运行在本地机器上，模拟一个小规模的集群。</li><li>全分布模式：Hadoop守护进程运行在一个集群上。</li></ul><p>不同的模式下关键配置属性</p><div class="table-container"><table><thead><tr><th>组件名称</th><th>属性名称</th><th>独立模式</th><th>伪分布模式</th><th>全分布模式</th></tr></thead><tbody><tr><td>Common</td><td>fs.defaultFS</td><td>file:///</td><td>hdfs://localhost/</td><td>hdfs://namenode/</td></tr><tr><td>HDFS</td><td>dfs.replication（文件备份数量）</td><td>N/A</td><td>1</td><td>3(默认)</td></tr><tr><td>MapReduce</td><td>mapreduce.framework.name</td><td>local（默认）</td><td>Yarn</td><td>yarn</td></tr><tr><td>YARN</td><td>yarn.resourcemanager.hostname</td><td>N/A</td><td>Localhost</td><td>resourcemanager</td></tr><tr><td></td><td>yarn.nodemanager.aux-services</td><td>N/A</td><td>mapreduce_shuffle</td><td>mapreduce_shffule</td></tr></tbody></table></div><p>独立模式无需运行任何守护进程，因此在独立模式下不需要更多操作。</p><h3 id="伪分布模式"><a href="#伪分布模式" class="headerlink" title="伪分布模式"></a>伪分布模式</h3><p>在上述四个*-site.xml文件中添加上述表中的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">core-site.xml</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;fs.defaultFS&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;hdfs://localhost/&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line"></span><br><span class="line">hdfs-site.xml</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;dfs.replication&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;1&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line"></span><br><span class="line">mapred-site.xml</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;mapreduce.framework.name&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;yarn&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line"></span><br><span class="line">yarn-site.xml</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;localhost&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.nodemanaer.aux-services&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;mapreduce_shuffle&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><ol><li><p>配置ssh</p><p> 伪分布模式下必须启动守护进程，启动守护进程的前提是ssh。在伪分布模式下，主机就是本地计算机localhost。需要保证用户能够用ssh连接到本地主机。具体就是将/usr/root/用户的id_rsa.pub添加到/usr/root/的authorized_keys中实现免密登录。</p></li><li><p>格式化HDFS文件系统，其实就是格式化namenode节点</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdfs namenode -format</span><br></pre></td></tr></table></figure></li><li><p>启动和终止守护进程</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">启动守护进程</span><br><span class="line">start-dfs.sh</span><br><span class="line">start-yatn.sh</span><br><span class="line">mr-jobhistory-daemon.sh start historyserver</span><br><span class="line"></span><br><span class="line">终止守护进程</span><br><span class="line">mr-jobhistory-daemon.sh stop historyserver</span><br><span class="line">stop-yarn.sh</span><br><span class="line">stop-dfs.sh</span><br></pre></td></tr></table></figure></li></ol><ul><li>本地计算机localhost将启动守护进程，一个namenode，一个附属namenode，一个datanode（hdfs）， 一个资源管理器，一个节点管理器（yarn）和一个历史服务器（mapreduce）。可以在hadoop安装目录下的logs中检查文件日志来检查守护进程是否成功。</li><li><p>或者通过Web界面：<br><a href="http://localhost:50070/查看namenode，" target="_blank" rel="noopener">http://localhost:50070/查看namenode，</a><br><a href="http://localhost:8088/查看资源管理器" target="_blank" rel="noopener">http://localhost:8088/查看资源管理器</a><br><a href="http://localhost:19888/查看历史服务器" target="_blank" rel="noopener">http://localhost:19888/查看历史服务器</a></p><p>  但问题是CentOS7最小安装是命令行模式，不会有浏览器让你查看。解答：<a href="https://floodshao.github.io/CentOS7_GUI" target="_blank" rel="noopener">CentOS 7 最小化安装添加图像化界面</a></p></li></ul><ol><li>创建用户目录 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hadoop fs -mkdir -p /user/$USER</span><br><span class="line">第一次不知道我就使用了/user/root/ 但为了避免歧义，还是选择其他名字吧</span><br></pre></td></tr></table></figure></li></ol><h2 id="HDFS命令行接口"><a href="#HDFS命令行接口" class="headerlink" title="HDFS命令行接口"></a>HDFS命令行接口</h2><p>HDFS有很多接口，其中命令行是最简单的。<br>文件系统基本操作: hadoop fs -help 来获取命令帮助</p><ol><li><p>HDFS文件目录显示</p><p> 命令：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop fs -ls /user/root</span><br></pre></td></tr></table></figure><p> <img src="/images/2019-06-06-hadoop_hdfs/hdfs_dir.png" alt="hdfs_dir"></p><ul><li>第1列为文件权限模式，与POSIX模式相同（777），目录为d</li><li>第2列为该文件的备份数（由于我们选择了伪分布模式，在dfs.replication配置中选择了1）</li><li><p>第3，4列为文件所属用户和组别。</p><p><strong>对于文件而言，你不能在HDFS中执行文件，所以所有文件都不可执行。对于目录而言，要访问一个目录的子项，必须需要x权限。</strong></p></li><li><p>默认情况下，Hadoop运行时安全措施处于停用模式，意味着客户端身份是没有经过认证的。由于客户端是远程的，一个客户端可以在远程系统上通过创建和任何一个合法用户同名的账号来进行访问。无论怎样，为了防止用户或者自动工具及程序意外修改或删除文件系统的重要部分，启动权限控制很重要（dfs.permissions.enabled默认属性）</p></li><li>super-user的概念，超级用户是namenode进程的标识，对于超级用户，系统不会执行任何权限检查。</li></ul></li></ol><h2 id="HDFS文件系统："><a href="#HDFS文件系统：" class="headerlink" title="HDFS文件系统："></a>HDFS文件系统：</h2><ul><li>Hadoop有一个抽象的文件系统，HDFS只是其中的一个实现。Hadoop对文件系统提供了多个接口，它一般使用URI方案来选取合适的文件系统实例进行交互。</li><li>通过Java API可以调用大部分Hadoop文件系统的交互操作。</li></ul><p>参考Hadoop权威指南第三章的代码。</p><p>这里重点说明一下使用maven编译hadoop程序的流程。以编译ch3-URLCat.java为例：</p><ol><li>按照上述hadoop流程建立hdfs守护程序，采用伪分布模式</li><li>建立maven项目工程，并在/src/main/java/下编写URLCat.java程序</li><li>使用命令 <em>%mvn clean compile</em> 在根目录下对项目进行编译。此时会在文件根目录生成一个target目录。注意每一次clean compile都会完全清除target目录下的所有内容，然后再对项目进行编译。</li><li><p>编译不成功，显示error找不到包，此时需要在pom.xml文件中添加dependencies.如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;hadoop-hdfs&lt;/artifactId&gt;</span><br><span class="line">     &lt;version&gt;2.9.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;hadoop-common&lt;/artifactId&gt;</span><br><span class="line">     &lt;version&gt;2.9.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p> 保持网络连接，继续用上述编译命令进行编译，会从apache网站下载相关包（国内注意配置阿里云镜像）</p></li><li><p>编译成功，在target中生成class文件</p></li><li>在hadoop权威指南中直接用hadoop URLCat hdfs://localhost/user/root/quangle.txt来执行了命令，是因为它把整个项目生成了一个jar包放在了classpath里。</li><li>目前我们新建的项目还没有生成jar包，就需要把该生成的URLCat.class文件打包成jar包。<br> <em>%jar -cvf xxx.jar xxx.class</em></li><li>运行Hadoop命令 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop jar xxx.jar xxx hdfs://localhost/user/root/quangle.txt</span><br></pre></td></tr></table></figure></li></ol><h2 id="Hadoop文件系统数据流"><a href="#Hadoop文件系统数据流" class="headerlink" title="Hadoop文件系统数据流"></a>Hadoop文件系统数据流</h2><p>附上两张关于hdfs的读写操作：</p><p><img src="/images/2019-06-06-hadoop_hdfs/hdfs_read.png" alt="hdfs_dir"></p><p><img src="/images/2019-06-06-hadoop_hdfs/hdfs_write.png" alt="hdfs_dir"></p><p>其实通俗的讲，就是namenode保存了文件重建的方法，并在读写过程中将中将如何重建告诉主机中的文件系统，文件系统按照该重建方法从datanode中读取或写入数据。这一过程对客户端来说是透明的。<br>守护程序就是namenode与datanode不断进行沟通，更新在哪个datanode上存着那一部分数据。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop下载与安装（源码安装）</title>
      <link href="/2019/06/05/2019-06-05-hadoop_download_install_instruction/"/>
      <url>/2019/06/05/2019-06-05-hadoop_download_install_instruction/</url>
      
        <content type="html"><![CDATA[<p><strong>本安装教程基于：</strong></p><ol><li>海牛部落Hadoop系列教程（四）：编译Hadoop源码 <a href="http://www.hainiubl.com/topics/82" target="_blank" rel="noopener">http://www.hainiubl.com/topics/82</a></li><li>Hadoop权威指南中文版</li></ol><p><strong>安装环境：</strong></p><ul><li>物理机 MacOS 10.13.6</li><li>虚拟机 VirtualBox</li><li>虚拟机系统 CentOS 7</li></ul><p>在安装的过程中查询很多博客，会发现采用安装文件安装后期会有很多问题，所以采用了Hadoop源码安装，其安装需要通过Maven管理来实现。</p><a id="more"></a> <!-- 摘要 --><h2 id="相关文件下载："><a href="#相关文件下载：" class="headerlink" title="相关文件下载："></a>相关文件下载：</h2><p><img src="/images/2019-06-05-hadoop_download_install_instruction/download_lists.png" alt="1"></p><h3 id="相关下载网址："><a href="#相关下载网址：" class="headerlink" title="相关下载网址："></a>相关下载网址：</h3><p><strong>Hadoop：</strong> <a href="https://hadoop.apache.org/releases.html" target="_blank" rel="noopener">https://hadoop.apache.org/releases.html</a> （2019年），选择Source下载，并选择网站提供的合适镜像进行下载</p><p><strong>Apache-ant：</strong> <a href="http://ant.apache.org/" target="_blank" rel="noopener">http://ant.apache.org/</a></p><p><strong>Apache-maven：</strong> <a href="http://maven.apache.org/download.cgi" target="_blank" rel="noopener">http://maven.apache.org/download.cgi</a></p><p><strong>Findbugs：</strong> <a href="http://findbugs.sourceforge.net/downloads.html" target="_blank" rel="noopener">http://findbugs.sourceforge.net/downloads.html</a></p><p><strong>Protobuf：</strong> <a href="https://github.com/protocolbuffers/protobuf/releases" target="_blank" rel="noopener">https://github.com/protocolbuffers/protobuf/releases</a> 注意版本选择</p><p><strong>Snappy：</strong> <a href="https://github.com/google/snappy/releases" target="_blank" rel="noopener">https://github.com/google/snappy/releases</a> 注意版本选择，CentOS 7 的自带cmake工具为2.8， 而最新snappy-1.1.7需要cmake3.0以上版本。为避免麻烦选择1.1.3版本</p><p><strong>java jdk：</strong> Oracle官网进行下载，注意请选择jdk1.8。原因：在安装过程中发现maven配置安装需要使用jdk1.8。使用1.7会出现如下问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Unrecognized VM option &apos;MaxMetaspaceSize=512M&apos;</span><br><span class="line">Error: Could not create the Java Virtual Machine.</span><br><span class="line">Error: A fatal exception has occurred. Program will exit.</span><br></pre></td></tr></table></figure><p>MaxMetaspaceSize为Java8中新引入的参数，如果当前环境使用的是java7或更低版本,把编译环境改为java8后就OK了。<br><a href="http://www.codingwhy.com/view/785.html" target="_blank" rel="noopener">http://www.codingwhy.com/view/785.html</a></p><h3 id="远程登录虚拟主机，使用rz工具将所有文件上传"><a href="#远程登录虚拟主机，使用rz工具将所有文件上传" class="headerlink" title="远程登录虚拟主机，使用rz工具将所有文件上传"></a>远程登录虚拟主机，使用rz工具将所有文件上传</h3><p>查看CentOS 7 基本工具配置：<br><img src="/images/2019-06-05-hadoop_download_install_instruction/rz_upload.png" alt="2"></p><h2 id="工具与Hadoop安装"><a href="#工具与Hadoop安装" class="headerlink" title="工具与Hadoop安装"></a>工具与Hadoop安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">解压与压缩命令：</span><br><span class="line">tar xvzf xxx.tar.gz -C dest_dir #解压路径</span><br><span class="line">tar cvzf dest_file.tar.gz -C source_dir #压缩文件</span><br></pre></td></tr></table></figure><ol><li><p>切换到root权限下，将Hadoop源码包解压到/usr/local</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xvzf hadoop-2.9.2-src.tar.gz -C /usr/local</span><br></pre></td></tr></table></figure><p> 查看/usr/local/hadoop-2.9.2-src/BUILDING.txt查看Requirements：<br> <img src="/images/2019-06-05-hadoop_download_install_instruction/hadoop_building_requirements.png" alt="3"></p></li><li><p>安装源码编译需要的本地库</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y install svn ncurses-devel gcc*</span><br><span class="line">yum -y install lzo-devel zlib-devel autoconf automake libtool cmake openssl-devel bzip2</span><br></pre></td></tr></table></figure><p> 注意，如果zlib-devel和openssl-devel没有安装，会出现安装报错，executable通常显示“cmake”<br> <a href="http://www.voidcn.com/article/p-bkvnropx-bog.html" target="_blank" rel="noopener">http://www.voidcn.com/article/p-bkvnropx-bog.html</a></p></li><li><p>安装包部分<br> 3.1 protobuf 安装， 将protobuf压缩包解压至/usr/local/</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tar xvzf protobuf-2.5.0.tar.gz -C /usr/local</span><br><span class="line">cd ./protobuf-2.5.0/</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line">protoc --version #查看版本信息验证安装成功</span><br></pre></td></tr></table></figure><p> 3.2 apache-ant 安装, 解压至/usr/local<br> 3.3 findbugs安装, 解压至/usr/local</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/findbugs-3.0.1/bin/findbugs -version #查看版本验证</span><br></pre></td></tr></table></figure><p> 3.4 maven安装, 解压至/usr/local<br> 3.5 nappy安装, 解压至/usr/local</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tar xvzf snappy-1.1.3.tar.gz -C /usr/local</span><br><span class="line">cd ./snappy-1.1.3/</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line">ls -lh /usr/local/lib | grep snappy</span><br><span class="line">注意这是采用1.1.3的安装方法，最新的1.1.7需要通过cmake3.0编译</span><br></pre></td></tr></table></figure><p> 3.6 java jdk安装<br> 参考linux java jdk安装：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version #查看java版本</span><br></pre></td></tr></table></figure></li><li><p>环境变量配置 vim /etc/profile</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 检查java路径是否正确</span><br><span class="line">export JAVA_HOME=/usr/java/jdk1.8.0_201-amd64</span><br><span class="line">export JRE_HOME=$JAVA_HOME/jre</span><br><span class="line">export PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH</span><br><span class="line"># hadoop编译环境</span><br><span class="line">export CLASSPATH=$CLASSPATH:./:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line">export MAVEN_HOME=/usr/local/apache-maven-3.6.1</span><br><span class="line">export FINDBUGS_HOME=/usr/local/findbugs-3.0.1</span><br><span class="line">export PROTOBUF_HOME=/usr/local/protobuf-2.5.0</span><br><span class="line">export ANT_HOME=/usr/local/apache-ant-1.9.14</span><br><span class="line">export PATH=$PATH:$MAVEN_HOME/bin:$FINDBUGS_HOME/bin:$ANT_HOME/bin</span><br><span class="line">export MAVEN_OPTS=&quot;-Xmx2g -XX:MaxMetaspaceSize=512M -XX:ReservedCodeCacheSize=512m&quot;</span><br></pre></td></tr></table></figure><p> 启用环境变量 source /etc/profile</p></li><li><p>使用maven进行编译<br> 在/usr/local/hadoop/BUILDING.txt文件中说明了如何使用Maven进行编译<br> <img src="/images/2019-06-05-hadoop_download_install_instruction/maven_build_instructions.png" alt="4"><br> <img src="/images/2019-06-05-hadoop_download_install_instruction/maven_build_instructions_1.png" alt="5"></p><p> 基本命令：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/hadoop-2.9.2-src/</span><br><span class="line">mvn clean package -Pdist,native -DskipTests -Dtar -Dbundle.snappy -Dsnappy.lib=/usr/local/lib</span><br></pre></td></tr></table></figure><p> 在编译下载过程中，发现使用了apache的源，下载非常缓慢，在网络不良的时候还会发生安装错误，于是要配置国内阿里云的maven镜像：</p><p> 5.1 在/usr/local/maven/conf中，找到settings.xml<br> 在<mirrors>中添加路径</mirrors></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;mirror&gt;</span><br><span class="line">        &lt;id&gt;nexus-aliyun&lt;/id&gt;</span><br><span class="line">        &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;</span><br><span class="line">        &lt;name&gt;Nexus aliyun&lt;/name&gt;</span><br><span class="line">        &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;</span><br><span class="line">&lt;/mirror&gt;</span><br><span class="line">--------------------- </span><br><span class="line">作者：行走的IT 人 </span><br><span class="line">来源：CSDN </span><br><span class="line">原文：https://blog.csdn.net/tengxing007/article/details/72588242 </span><br><span class="line">版权声明：本文为博主原创文章，转载请附上博文链接！</span><br></pre></td></tr></table></figure><p> 并且在/usr/local/hadoop/pom.xlm文件下添加</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> &lt;repository&gt;</span><br><span class="line">     &lt;id&gt;nexus-aliyun&lt;/id&gt;</span><br><span class="line">     &lt;name&gt;Nexus aliyun&lt;/name&gt;</span><br><span class="line">     &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;</span><br><span class="line"> &lt;/repository&gt;</span><br><span class="line">--------------------- </span><br><span class="line">作者：行走的IT 人 </span><br><span class="line">来源：CSDN </span><br><span class="line">原文：https://blog.csdn.net/tengxing007/article/details/72588242 </span><br><span class="line">版权声明：本文为博主原创文章，转载请附上博文链接！</span><br></pre></td></tr></table></figure><p> 然后再使用mvn命令进行安装，注意是在hadoop路径下。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package -Pdist,native -DskipTests -Dtar -Dbundle.snappy -Dsnappy.lib=/usr/local/lib</span><br></pre></td></tr></table></figure><p> 源码安装好之后，二进制配置文件位于/hadoop-2.9.2-src/hadoop-dist/target/hadoop-2.9.2/<br> 配置hadoop环境变量</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export HADOOP_HOME=/usr/local/hadoop-2.9.2-src/hadoop-dist/target/hadoop-2.9.2</span><br><span class="line">export PATH=$PATH:$HADOOP_HOME/bin:$HADOOP_HOME/sbin</span><br></pre></td></tr></table></figure><p> 可以用 hadoop version来检查是否安装成功<br> <img src="/images/2019-06-05-hadoop_download_install_instruction/hadoop_version.png" alt="hadoop_version"></p><p> Hadoop的各个组件均可以利用XML文件进行配置。</p><ul><li>Core-site.xml文件用用配置通用属性，</li><li>hdfs-site.xml用于配置HDFS属性，</li><li>mapred-site.xml用于配置madpreduce属性，</li><li><p>yarn-site.xml用于配置YARN属性。<br>这些配置文件都放在/etc/hadoop子目录中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">完整配置文件</span><br><span class="line"># set hadoop path</span><br><span class="line">export HADOOP_HOME=/usr/local/hadoop-2.9.2-src/hadoop-dist/target/hadoop-2.9.2</span><br><span class="line">export HADOOP_COMMON_HOME=$HADOOP_HOME</span><br><span class="line">export HADOOP_HDFS_HOME=$HADOOP_HOME</span><br><span class="line">export HADOOP_MAPRED_HOME=$HADOOP_HOME</span><br><span class="line">export HADOOP_YARN_HOME=$HADOOP_HOME</span><br><span class="line">export HADOOP_CONF_DIR=$HADOOP_HOME/etc/hadoop</span><br><span class="line">export HDFS_CONF_DIR=$HADOOP_HOME/etc/hadoop</span><br><span class="line">export YARN_CONF_DIR=$HADOOP_HOME/etc/hadoop</span><br><span class="line">export LD_LIBRARY_PATH=$HADOOP_HOME/lib/native:/usr/lib64</span><br><span class="line"></span><br><span class="line">export PATH=$PATH:$HADOOP_HOME/bin:$HADOOP_HOME/sbin</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="安装中出现的错误"><a href="#安装中出现的错误" class="headerlink" title="安装中出现的错误"></a>安装中出现的错误</h2><ol><li>在第一次配置的过程中，出现多次网络中断或异常终止的状况，这是因为使用了apache的源，即使开了vpn下载速度也受限。所以在国内请务必配置阿里云的镜像。</li><li><p>在使用apache源的情况下，如果安装出错，继续执行上述mvn命令仍然可以继续安装，但可能会出一些比较奇怪的错。我出现的问题在：</p><p> <img src="/images/2019-06-05-hadoop_download_install_instruction/hadoop_install_error.png" alt="6"></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ERROR] Failed to execute goal org.apache.maven.plugins:maven-antrun-plugin:1.7:run (tar) on project hadoop-dist: An Ant BuildException has occured: exec returned: 1</span><br><span class="line">[ERROR] around Ant part ...&lt;exec failonerror=&quot;true&quot; dir=&quot;/usr/local/hadoop-2.9.2-src/hadoop-dist/target&quot; executable=&quot;bash&quot;&gt;... @ 21:99 in /usr/local/hadoop-2.9.2-src/hadoop-dist/target/antrun/build-main.xml</span><br></pre></td></tr></table></figure><p> 在help文档中查到这不是maven内核的问题，而是antrun插件的问题，所以寻找到了如下博客 <a href="http://www.voidcn.com/article/p-bkvnropx-bog.html" target="_blank" rel="noopener">http://www.voidcn.com/article/p-bkvnropx-bog.html</a> 。该博客中说明在jdk1.8的环境下可能会出现相同的错误，于是我卸载了之前装的jdk1.8安装了jdk1.7（源码安装），但java直接不能使用。</p><p> 解决方法：清空虚拟机，并重新按照上边步骤来，使用rpm安装jdk1.8. 一定要配置阿里云mirror.然后耐心等待，就装好了。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Welcome to My Github Blog</title>
      <link href="/2019/06/01/2019-06-01-Welcome/"/>
      <url>/2019/06/01/2019-06-01-Welcome/</url>
      
        <content type="html"><![CDATA[<h3 id="这是一个Test页面"><a href="#这是一个Test页面" class="headerlink" title="这是一个Test页面"></a>这是一个Test页面</h3><p>博客中连接站内文章可以采用post_link这个工具</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% post_link 文章文件名（不要后缀） 文章标题（可选） %&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World Test</title>
      <link href="/2019/01/01/2019-01-01-hello-world/"/>
      <url>/2019/01/01/2019-01-01-hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
